<AccessControl.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (access/AccessControl.compact)

pragma language_version >= 0.18.0;

/**
 * @module AccessControl
 * @description Manages role-based access control using a Merkle tree to store role commitments.
 * Provides circuits for granting and revoking roles, with Admin-only restrictions.
 */
module AccessControl {
  import CompactStandardLibrary;

  import "./interfaces/IAccessControl";

  /**
   * @description Witness function to update a user’s role and its index in private state.
   * @param {Bytes<32>} userRoleCommit - The commitment hash of the user-role pair.
   * @param {Role} role - The role to set.
   * @param {Uint<64>} index - The index in the Merkle tree.
   * @returns {[]} - An empty array indicating success.
   */
  export witness wit_updateRole(userRoleCommit: Bytes<32>, role: Role, index: Uint<64>): [];

  /**
   * @description Witness function to retrieve the Merkle path for a user-role commitment.
   * @param {Bytes<32>} userRoleCommit - The commitment hash of the user-role pair.
   * @returns {Maybe<MerkleTreePath<10, Bytes<32>>>} - The path if it exists, otherwise None.
   */
  export witness wit_getRoleMerklePath(userRoleCommit: Bytes<32>): Maybe<MerkleTreePath<10,
                                                                                        Bytes<32>>>;

  /**
   * @description Witness to provide user’s secret key for nullifier generation.
   */
  export witness wit_getSecretKey(): Bytes<32>;

  /**
   * @description Initializes the AccessControl contract by granting the Admin role to an initial user.
   * @param {ZswapCoinPublicKey} initialAdmin - The public key of the initial admin.
   * @returns {[]} - An empty array indicating success.
   * @throws {RoleError} - If the contract is already initialized.
   */
  export circuit initialize(initialAdmin: ZswapCoinPublicKey): [] {
    assert(!isInitialized, "AccessControl: AccessControl contract is initialized!");
    isInitialized = true;
    return _grantRole(initialAdmin, Role.Admin);
  }

  /**
   * @description Grants a role to a user, restricted to Admin callers.
   * @param {ZswapCoinPublicKey} user - The public key of the user to grant the role to.
   * @param {Role} role - The role to grant (Admin, Lp, Trader, or None).
   * @returns {[]} - An empty array indicating success.
   * @throws {RoleError} - If the contract is not initialized, caller is not Admin, or the role tree is full.
   */
  export circuit grantRole(user: ZswapCoinPublicKey, role: Role): [] {
    assert(isInitialized, "AccessControl: Role contract is not initialized yet!");
    assert(onlyAdmin(), "AccessControl: Caller does not have an Admin role!");

    return _grantRole(user, role);
  }

  /**
   * @description Internal helper to grant a role by inserting it into the Merkle tree.
   * @param {ZswapCoinPublicKey} user - The public key of the user.
   * @param {Role} role - The role to grant.
   * @returns {[]} - An empty array indicating success.
   */
  circuit _grantRole(user: ZswapCoinPublicKey, role: Role): [] {
    assert(!roleCommits.isFull(), "AccessControl: Role commitments tree is full!");

    const nullifier = disclose(hashNullifier(user, role));
    // TODO: Now I have to use disclose(Nullifier) here, would that leak the sk at the end?!
    assert(!roleNullifiers.member(nullifier), "AccessControl: Role already granted!");

    roleNullifiers.insert(nullifier);

    const userRoleCommit = disclose(hashUserRole(user, role));
    const currentIndex = index;

    roleCommits.insertIndex(userRoleCommit, currentIndex);
    wit_updateRole(userRoleCommit, role, currentIndex);

    return index.increment(1);
  }

  /**
   * @description Revokes a role from a user, restricted to Admin callers.
   * @param {ZswapCoinPublicKey} user - The public key of the user to revoke the role from.
   * @param {Role} role - The role to revoke.
   * @returns {[]} - An empty array indicating success.
   * @throws {RoleError} - If the contract is not initialized, caller is not Admin, or user lacks the role.
   * @todo Implement revocation logic with a queue for index reuse.
   */
  circuit revokeRole(user: ZswapCoinPublicKey, role: Role): [] {
    assert(isInitialized, "AccessControl: Role contract is not initialized yet!");
    assert(onlyAdmin(), "AccessControl: Caller does not have an Admin role!");
    assert(hasRole(user, role), "AccessControl: User does not have a role!");
  }

  /**
   * @description Internal helper to revoke a role (not implemented).
   * @param {ZswapCoinPublicKey} user - The public key of the user.
   * @param {Role} role - The role to revoke.
   * @returns {[]} - An empty array indicating success.
   * @todo Implement using a queue to manage freed indices.
   */
  circuit _revokeRole(user: ZswapCoinPublicKey, role: Role): [] {
    const userRoleCommit = hashUserRole(user, role);
    /// TODO: A Queue is needed.
  }

  /**
   * @description Computes a commitment hash for a user and role.
   * @param {ZswapCoinPublicKey} user - The public key of the user.
   * @param {Role} role - The role to hash.
   * @returns {Bytes<32>} - A 32-byte hash of the user-role pair.
   * @todo Revisit to add salt or randomness for privacy.
   */
  export circuit hashUserRole(user: ZswapCoinPublicKey, role: Role): Bytes<32> {
    // TODO: Revisit to enhance privacy by adding salt or randomness for shielding user identity
    return persistentHash<Vector<2, Bytes<32>>>([user.bytes, hashRole(role)]);
  }

  /**
   * @description Hashes a role enum value.
   * @param {Role} role - The role to hash.
   * @returns {Bytes<32>} - A 32-byte hash of the role.
   */
  circuit hashRole(role: Role): Bytes<32> {
    return persistentHash<Vector<1, Role>>([role]);
  }

  /**
   * @description Checks if the caller has the Admin role.
   * @returns {Boolean} - True if the caller is an Admin, false otherwise.
   */
  export circuit onlyAdmin(): Boolean {
    return hasRole(ownPublicKey(), Role.Admin);
  }

  /**
   * @description Checks if the caller has the Lp role.
   * @returns {Boolean} - True if the caller is an Lp, false otherwise.
   */
  export circuit onlyLp(): Boolean {
    return hasRole(ownPublicKey(), Role.Lp);
  }

  /**
   * @description Checks if the caller has the Trader role.
   * @returns {Boolean} - True if the caller is a Trader, false otherwise.
   * @note Contains a syntax error: missing Role enum reference.
   */
  export circuit onlyTrader(): Boolean {
    return hasRole(ownPublicKey(), Role.Trader); // Fixed syntax error
  }

  /**
   * @description Verifies if a user has a specific role.
   * @param {ZswapCoinPublicKey} user - The public key of the user to check.
   * @param {Role} role - The role to verify.
   * @returns {Boolean} - True if the user has the role, false otherwise.
   * @throws {RoleError} - If the role path or Merkle root is invalid.
   */
  circuit hasRole(user: ZswapCoinPublicKey, role: Role): Boolean {
    const userRoleCommit = hashUserRole(user, role);
    const userRolePath = disclose(wit_getRoleMerklePath(userRoleCommit));
    const ind = index;

    assert((userRolePath.is_some &&
            roleCommits.checkRoot(getPathRoot(userRolePath.value)) &&
            userRoleCommit == userRolePath.value.leaf), "AccessControl: Unauthorized user!");

    return true;
  }

  /**
   * @description Computes a nullifier for a user and role using secret knowledge.
   */
  circuit hashNullifier(user: ZswapCoinPublicKey, role: Role): Bytes<32> {
    const sk = wit_getSecretKey();
    return persistentHash<Vector<4, Bytes<32>>>(
             [pad(32, "role-nullifier"), hashRole(role), user.bytes, sk]);
  }

  // TODO: Should be in a general Compact utils contract for MerkleTree.
  /**
   * @description Computes the Merkle tree root from a path.
   * @param {MerkleTreePath<10, Bytes<32>>} path - The Merkle path to compute the root from.
   * @returns {MerkleTreeDigest} - The root digest of the Merkle tree.
   * @todo Move to a utils.compact module for reusability.
   */
  circuit getPathRoot(path: MerkleTreePath<10, Bytes<32>>): MerkleTreeDigest {
    return merkleTreePathRoot<10, Bytes<32>>(path);
  }
}

</AccessControl.compact>

<Index.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (access/Index.compact)

pragma language_version >= 0.18.0;

/**
 * @module Index
 * @description Re-exports ledger-related types and state from IAccessControl.compact for use in contracts and TypeScript.
 * @remarks This file provides a centralized export of IAccessControl's public ledger state, 
 * making it accessible for TypeScript type generation via compactc. So no need to export them in a Mock*.compact.
 */

import "./interfaces/IAccessControl";

/**
 * @description Exports public ledger state and types from IAccessControl for contract and TypeScript integration.
 */
export { Role, // Enum defining user roles (Admin, Lp, Trader, None)
         isInitialized, // Boolean indicating contract initialization
         roleCommits, // Merkle tree storing role commitments
         roleNullifiers, // Set of nullifiers tracking used user-role pairs
         index // Counter for the next Merkle tree index
         };

</Index.compact>

<IAccessControl.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (access/interfaces/IAccessControl.compact)

pragma language_version >= 0.18.0;

module IAccessControl {
  import CompactStandardLibrary;

  /**
     * @description Defines the possible roles a user can have in the system.
     * @enum {number}
     */
  export enum Role {
    Admin,
    Lp,
    Trader,
    None
  };

  /**
   * @description Indicates whether the contract has been initialized.
   * @type {Boolean}
   */
  export ledger isInitialized: Boolean;

  /**
   * @description Merkle tree storing commitments of user-role pairs, with a fixed depth of 10.
   * @type {MerkleTree<10, Bytes<32>>}
   */
  export ledger roleCommits: MerkleTree<10, Bytes<32>>;

  /**
   * @description A set of nullifiers tracking used user-role pairs to prevent duplicate role assignments.
   * @type {Set<Bytes<32>>}
   */
  export ledger roleNullifiers: Set<Bytes<32>>;

  /**
   * @description Counter tracking the next available index for inserting into the role tree.
   * @type {Counter}
   */
  export ledger index: Counter;
}

</IAccessControl.compact>

<AccessControl.mock.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (access/test/AccessControl.mock.compact)

pragma language_version >= 0.18.0;

import CompactStandardLibrary;

import "../AccessControl" prefix AccessControl_;

import "../interfaces/IAccessControl";

// Export circuits for testing purposes
export { AccessControl_hashUserRole, roleCommits, isInitialized, index, Role };

/**
 * @description Constructs the contract by initializing the AccessControl module with an initial admin.
 * @param {ZswapCoinPublicKey} initialAdmin - The public key of the initial admin.
 * @returns {[]} - An empty array indicating successful initialization.
 * @throws {RoleError} - If the contract is already initialized (inherited from AccessControl).
 */
constructor(initialAdmin: ZswapCoinPublicKey) {
  return AccessControl_initialize(initialAdmin);
}

/**
 * @description Test circuit to grant a role to a user, wrapping AccessControl's grantRole.
 * @param {ZswapCoinPublicKey} user - The public key of the user to grant the role to.
 * @param {Role} role - The role to grant (Admin, Lp, Trader, or None).
 * @returns {[]} - An empty array indicating success.
 * @throws {RoleError} - If the contract is not initialized, caller is not Admin, or the role tree is full.
 */
export circuit testGrantRole(user: ZswapCoinPublicKey, role: Role): [] {
  return AccessControl_grantRole(user, role);
}

</AccessControl.mock.compact>

<LunarswapFactory.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (lunarswap-v1/LunarswapFactory.compact)

pragma language_version >= 0.18.0;

/**
 * @title LunarswapFactory
 * @description Factory contract for creating and managing trading pairs in the Lunarswap protocol.
 * 
 * @remarks
 * The LunarswapFactory is responsible for the creation, storage, and management of all trading pairs
 * in the protocol. It implements a factory pattern where each unique token pair has a corresponding
 * pair contract that handles the actual trading logic and liquidity management.
 * 
 * Key Features:
 * - Pair creation and initialization
 * - Pair storage and retrieval
 * - Reserve management and updates
 * - Deterministic pair identification through token sorting
 */
module LunarswapFactory {
  import CompactStandardLibrary;

  import "../../../compact-contracts/contracts/src/utils/Utils" prefix Utils_;

  import "./types/TPair";

  import LunarswapPair prefix LunarswapPair_;
  import LunarswapLibrary prefix LunarswapLibrary_;

  /**
   * @title pool ledger
   * @description Stores all trading pairs in the factory, mapping a unique pair pairId (Bytes<32>)
   *              to its corresponding Pair struct. This ledger enables efficient lookup and management
   *              of all created pairs within the Lunarswap protocol.
   *
   * @type {Map<Bytes<32>, Pair>}
   */
  export ledger pool: Map<Bytes<32>, Pair>;

  /**
   * @title reserves ledger
   * @description Maintains the reserves for each trading pair. It maps a unique pair pairId (Bytes<32>)
   *              to a nested map of token color (Bytes<32>) to its QualifiedCoinInfo. This structure allows
   *              for tracking and updating the reserves of each token within every pair.
   *
   * @type {Map<reserveType, QualifiedCoinInfo>}
   * @type {Map<Bytes<32>, QualifiedCoinInfo>}
   */
  export ledger reserves: Map<Bytes<32>, QualifiedCoinInfo>;

  /**
   * @title initialize circuit
   * @description Initializes the Lunarswap factory with LP token configuration.
   * 
   * @remarks
   * This circuit sets up the initial configuration for LP tokens including name,
   * symbol, decimals, and nonce. It should only be called once during contract deployment.
   *
   * @circuitInfo k=11, rows=1200
   *
   * @param {Bytes<32>} lpTokenNonce      - The nonce for LP token generation.
   * @param {Opaque<"string">} lpTokenName - The name of the LP token.
   * @param {Opaque<"string">} lpTokenSymbol - The symbol of the LP token.
   * @param {Uint<8>} lpTokenDecimals     - The number of decimals for LP tokens.
   *
   * @returns [] - No return values.
   */
  export circuit initialize(
                   lpTokenNonce: Bytes<32>,
                   lpTokenName: Opaque<"string">,
                   lpTokenSymbol: Opaque<"string">,
                   lpTokenDecimals: Uint<8>
                   ): [] {
    return LunarswapPair_initialize(lpTokenNonce, lpTokenName, lpTokenSymbol, lpTokenDecimals);
  }

  /**
   * @title getAllPairLength circuit
   * @description Returns the total number of trading pairs in the factory.
   * 
   * @remarks
   * This circuit provides a count of all registered trading pairs stored in the liquidity pool.
   *
   * @circuitInfo k=11, rows=300
   *
   * @returns {Uint<64>} - The total number of trading pairs.
   */
  export circuit getAllPairLength(): Uint<64> {
    return pool.size();
  }

  /**
   * @title isIdentityExists circuit
   * @description Checks if a trading pair exists for the given pairId hash.
   * 
   * @remarks
   * This circuit verifies whether a pair with the specified pairId hash exists
   * in the liquidity pool.
   *
   * @circuitInfo k=11, rows=400
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the pair.
   *
   * @returns {Boolean} - True if the pair exists, false otherwise.
   */
  export circuit isIdentityExists(pairId: Bytes<32>): Boolean {
    return pool.member(pairId);
  }

  /**
   * @title getPair circuit
   * @description Retrieves the pair information for a given pairId hash.
   * 
   * @remarks
   * This circuit returns the complete pair data including reserves and metadata.
   * The pair must exist for this circuit to succeed.
   *
   * @circuitInfo k=11, rows=600
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the pair.
   *
   * @throws {Error} "LunarswapFactory: getPair() - Pair does not exist" if the pair doesn't exist.
   *
   * @returns {Pair} - The pair information including reserves and metadata.
   */
  export circuit getPair(pairId: Bytes<32>): Pair {
    assert(isIdentityExists(pairId), "LunarswapFactory: getPair() - Pair does not exist");
    return pool.lookup(pairId);
  }

  /**
   * @title getReserves circuit
   * @description Returns the current reserves for a trading pair.
   * 
   * @remarks
   * This circuit retrieves the reserves for a pair identified by its pairId hash
   * and token information. The reserves are returned in the order of token0 and token1.
   *
   * @circuitInfo k=11, rows=800
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the pair.
   * @param {Bytes<32>} reserve0Id - The id of the first reserve.
   * @param {Bytes<32>} reserve1Id - The id of the second reserve.
   *
   * @throws {Error} "LunarswapFactory: getPair() - Pair does not exist" if the pair doesn't exist.
   *
   * @returns {[QualifiedCoinInfo, QualifiedCoinInfo]} - The reserves for token0 and token1 respectively.
   */
  export circuit getReserves(pairId: Bytes<32>, reserve0Id: Bytes<32>, reserve1Id: Bytes<32>): [QualifiedCoinInfo,
                                                                                                QualifiedCoinInfo] {
    assert(isIdentityExists(pairId), "LunarswapFactory: getReserves() - Pair does not exist");
    assert(reserves.member(reserve0Id), "LunarswapFactory: getReserves() - Reserve0 does not exist");
    assert(reserves.member(reserve1Id), "LunarswapFactory: getReserves() - Reserve1 does not exist");
    const reserve0 = reserves.lookup(reserve0Id);
    const reserve1 = reserves.lookup(reserve1Id);
    return [reserve0, reserve1];
  }

  /**
   * @title createPair circuit
   * @description Creates a new trading pair for the given tokens.
   * 
   * @remarks
   * This circuit initializes a new trading pair with zero reserves and stores it
   * in the liquidity pool. The pair is identified by a unique hash generated from
   * the sorted token colors.
   *
   * Requirements:
   * - The token colors must be valid (non-zero)
   * - The pair must not already exist
   *
   * @circuitInfo k=11, rows=1500
   *
   * @param {Bytes<32>} pairId - The unique pairId hash for the new pair.
   * @param {CoinInfo} token0    - The first token in the pair.
   * @param {CoinInfo} token1    - The second token in the pair.
   *
   * @throws {Error} "LunarswapFactory: Invalid token color" if either token color is zero.
   *
   * @returns {Pair} - The created pair.
   */
  export circuit createPair(pairId: Bytes<32>, token0: CoinInfo, token1: CoinInfo): Pair {
    // TODO: I am not sure if the Coin.Color can be set to zero.
    // TODO: UPDATE that assert is paused because the tDust token is zero address color.
    // assert (!Utils_isKeyOrAddressZero(right<ZswapCoinPublicKey, ContractAddress>( ContractAddress { bytes: token0.color }))) "LunarswapFactory: Invalid token color";
    const pair = LunarswapPair_initializePair(pairId, token0, token1);
    pool.insert(pairId, pair);
    return pair;
  }

  /**
   * @title updatePair circuit
   * @description Updates an existing trading pair with new data.
   * 
   * @remarks
   * This circuit updates the pair data in the liquidity pool. The pair must already
   * exist for this operation to succeed.
   *
   * Requirements:
   * - The pair must already exist in the liquidity pool
   *
   * @circuitInfo k=11, rows=1000
   *
   * @param {Pair} pair     - The updated pair data.
   * @param {Bytes<32>} pairId          - The unique pairId hash of the pair.
   *
   * @throws {Error} "LunarswapFactory: updatePair() - Pair does not exist" if the pair doesn't exist.
   *
   * @returns {Pair} - The updated pair data.
   */
  export circuit updatePair(pairId: Bytes<32>, pair: Pair): Pair {
    assert(isIdentityExists(pairId), "LunarswapFactory: updatePair() - Pair does not exist");
    pool.insert(pairId, disclose(pair));
    return pair;
  }

  /**
   * @title removePair circuit
   * @description Removes a trading pair from the liquidity pool.
   * 
   * @remarks
   * This circuit removes a pair from the liquidity pool based on the pair's
   * token information. The pair must exist for this operation to succeed.
   *
   * Requirements:
   * - The pair must exist in the liquidity pool
   *
   * @circuitInfo k=11, rows=800
   *
   * @param {Pair} pair - The pair to remove.
   *
   * @throws {Error} "LunarswapFactory: removePair() - Pair does not exist" if the pair doesn't exist.
   *
   * @returns [] - No return values.
   */
  export circuit removePair(pair: Pair): [] {
    const pairId = LunarswapLibrary_getIdentity(pair.token0Type, pair.token1Type, true);
    assert(isIdentityExists(pairId), "LunarswapFactory: removePair() - Pair does not exist");
    return pool.remove(pairId);
  }
}

</LunarswapFactory.compact>

<LunarswapLibrary.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (lunarswap-v1/LunarswapLibrary.compact)

pragma language_version >= 0.18.0;

/**
 * @title LunarswapLibrary
 * @description Utility library providing mathematical functions, token operations, and helper functions for the Lunarswap protocol.
 * 
 * @remarks
 * The LunarswapLibrary contains essential utility functions used throughout the Lunarswap protocol.
 * It provides mathematical operations, token manipulation utilities, sorting functions, and pairId
 * generation that are fundamental to the protocol's operation.
 * 
 * Key Functionalities:
 * - Mathematical operations (addition, multiplication, division, square root)
 * - Token sorting and ordering utilities
 * - Coin splitting and value manipulation
 * - Pair pairId generation and management
 * - Price calculation and quoting
 * - Type conversion between CoinInfo and QualifiedCoinInfo
 */
module LunarswapLibrary {
  import CompactStandardLibrary;

  import "../math/Uint128" prefix Uint128_;
  import "../math/Bytes32" prefix Bytes32_;

  // Struct for split coin result
  struct SplitCoinResult {
    used: CoinInfo,
    remainder: CoinInfo
  }

  struct SplitQualifiedCoinResult {
    used: QualifiedCoinInfo,
    remainder: QualifiedCoinInfo
  }

  /**
   * @title splitCoin circuit
   * @description Splits a coin into two parts: used amount and remainder.
   * 
   * @remarks
   * This circuit divides a coin into two new coins: one with the specified amount
   * and another with the remaining value. Both coins maintain the same color but
   * have different nonces.
   *
   * Requirements:
   * - The amount to split must not exceed the coin's value
   *
   * @circuitInfo k=11, rows=1000
   *
   * @param {CoinInfo} _coin   - The coin to split.
   * @param {Uint<128>} _amount - The amount to extract from the coin.
   *
   * @throws {Error} "LunarswapLibrary: splitCoin() - Insufficient amount" if amount exceeds coin value.
   *
   * @returns {SplitCoinResult} - The split result containing used and remainder coins.
   */
  export circuit splitCoin(coin: CoinInfo, amount: Uint<128>): SplitCoinResult {
    assert(amount <= coin.value, "LunarswapLibrary: splitCoin() - Insufficient amount");
    const used = CoinInfo { color: coin.color, value: amount, nonce: evolveNonce(0, coin.nonce) };
    const remainder =
                  CoinInfo { color: coin.color,
                             value: Uint128_sub(coin.value, amount),
                             nonce: evolveNonce(1, coin.nonce) };
    return SplitCoinResult { used, remainder };
  }

  /**
   * @title splitQualifiedCoin circuit
   * @description Splits a QualifiedCoinInfo into two parts: used amount and remainder.
   * 
   * @remarks
   * This circuit divides a QualifiedCoinInfo into two new QualifiedCoinInfo objects: one with the specified amount
   * and another with the remaining value. Both coins maintain the same color and contract address but
   * have different nonces.
   *
   * Requirements:
   * - The amount to split must not exceed the coin's value
   *
   * @circuitInfo k=11, rows=1000
   *
   * @param {QualifiedCoinInfo} _coin   - The qualified coin to split.
   * @param {Uint<128>} _amount - The amount to extract from the qualified coin.
   *
   * @throws {Error} "LunarswapLibrary: splitQualifiedCoin() - Insufficient amount" if amount exceeds coin value.
   *
   * @returns {{used: QualifiedCoinInfo, remainder: QualifiedCoinInfo}} - The split result containing used and remainder qualified coins.
   */
  export circuit splitQualifiedCoin(qualifiedCoin: QualifiedCoinInfo, amount: Uint<128>): SplitQualifiedCoinResult {
    assert(amount <= qualifiedCoin.value, "LunarswapLibrary: splitQualifiedCoin() - Insufficient amount");
    const used = QualifiedCoinInfo { color: qualifiedCoin.color,
                                     value: amount,
                                     nonce: evolveNonce(0, qualifiedCoin.nonce),
                                     mt_index: qualifiedCoin.mt_index };
    const remainder =
                  QualifiedCoinInfo { color: qualifiedCoin.color,
                                      value: Uint128_sub(qualifiedCoin.value, amount),
                                      nonce: evolveNonce(1, qualifiedCoin.nonce),
                                      mt_index: qualifiedCoin.mt_index };
    return SplitQualifiedCoinResult { used, remainder };
  }

  /**
   * @title sortCoins circuit
   * @description Sorts two coins to ensure consistent ordering in pair operations.
   * 
   * @remarks
   * This circuit sorts coins by their color values to ensure deterministic ordering
   * in pair operations. The token with the smaller color becomes token0, and the
   * larger becomes token1.
   *
   * Requirements:
   * - The coins must have different colors
   *
   * @circuitInfo k=11, rows=600
   *
   * @param {CoinInfo} _tokenA - The first token to sort.
   * @param {CoinInfo} _tokenB - The second token to sort.
   *
   * @throws {Error} "LunarswapLibrary: sortCoins() - Identical addresses" if tokens have same color.
   *
   * @returns {[CoinInfo, CoinInfo]} - The sorted tokens [token0, token1].
   */
  // Helper circuit to sort two coins
  // TODO: I think it worth adding this as a generic utility for ContractAddress
  export circuit sortCoins(_tokenA: CoinInfo, _tokenB: CoinInfo): [CoinInfo, CoinInfo] {
    assert(_tokenA.color != _tokenB.color, "LunarswapLibrary: sortCoins() - Identical addresses");
    const token0 = disclose(Bytes32_lt(_tokenA.color, _tokenB.color)) ? _tokenA : _tokenB;
    const token1 = disclose(Bytes32_lt(_tokenA.color, _tokenB.color)) ? _tokenB : _tokenA;

    return [token0, token1];
  }

  /**
   * @title sortCoinsAndAmounts circuit
   * @description Sorts coins and their corresponding amounts to maintain consistency.
   * 
   * @remarks
   * This circuit sorts both coins and their amounts together to ensure the amounts
   * correspond to the correct sorted tokens. This is essential for maintaining
   * proper token ordering in pair operations.
   *
   * Requirements:
   * - The coins must have different colors
   *
   * @circuitInfo k=11, rows=800
   *
   * @param {CoinInfo} _tokenA   - The first token to sort.
   * @param {CoinInfo} _tokenB   - The second token to sort.
   * @param {Uint<128>} _amountA - The amount corresponding to tokenA.
   * @param {Uint<128>} _amountB - The amount corresponding to tokenB.
   *
   * @throws {Error} "LunarswapLibrary: sortCoinsAndAmounts() - Identical addresses" if tokens have same color.
   *
   * @returns {[CoinInfo, CoinInfo, Uint<128>, Uint<128>]} - The sorted tokens and amounts [token0, token1, amount0, amount1].
   */
  export circuit sortCoinsAndAmounts(
                   _tokenA: CoinInfo, _tokenB: CoinInfo, _amountA: Uint<128>, _amountB: Uint<128>): [CoinInfo,
                                                                                                     CoinInfo,
                                                                                                     Uint<128>,
                                                                                                     Uint<128>] {
    assert(_tokenA.color != _tokenB.color, "LunarswapLibrary: sortCoinsAndAmounts() - Identical addresses");
    if (disclose(Bytes32_lt(_tokenA.color, _tokenB.color))) {
       // tokenA is token0
       return [_tokenA, _tokenB, _amountA, _amountB];
    } else {
       // tokenB is token0
       return [_tokenB, _tokenA, _amountB, _amountA];
    }
  }

  /**
   * @title sortQualifiedCoins circuit
   * @description Sorts two qualified coins to ensure consistent ordering.
   * 
   * @remarks
   * This circuit sorts qualified coins by their color values, similar to sortCoins
   * but for QualifiedCoinInfo types which include Merkle tree indices.
   *
   * Requirements:
   * - The coins must have different colors
   *
   * @circuitInfo k=11, rows=700
   *
   * @param {QualifiedCoinInfo} _tokenA - The first qualified token to sort.
   * @param {QualifiedCoinInfo} _tokenB - The second qualified token to sort.
   *
   * @throws {Error} "LunarswapLibrary: sortQualifiedCoins() - Identical addresses" if tokens have same color.
   *
   * @returns {[QualifiedCoinInfo, QualifiedCoinInfo]} - The sorted qualified tokens [token0, token1].
   */
  export circuit sortQualifiedCoins(_tokenA: QualifiedCoinInfo, _tokenB: QualifiedCoinInfo): [QualifiedCoinInfo,
                                                                                              QualifiedCoinInfo] {
    assert(_tokenA.color != _tokenB.color, "LunarswapLibrary: sortQualifiedCoins() - Identical addresses");
    const token0 = disclose(Bytes32_lt(_tokenA.color, _tokenB.color)) ? _tokenA : _tokenB;
    const token1 = disclose(Bytes32_lt(_tokenA.color, _tokenB.color)) ? _tokenB : _tokenA;
    return [token0, token1];
  }

  /**
   * @title addCoinValue circuit
   * @description Adds a value to a coin and returns a new CoinInfo.
   * 
   * @remarks
   * This circuit is functionally identical to addToCoin, creating a new coin with
   * an increased value by adding the specified amount to the original coin's value.
   *
   * @circuitInfo k=11, rows=600
   *
   * @param {CoinInfo} _coin   - The original coin.
   * @param {Uint<128>} _amount - The amount to add to the coin.
   *
   * @returns {CoinInfo} - A new coin with the increased value.
   */
  // Helper circuit to update a coin's value and return a new CoinInfo
  export circuit addCoinValue(_coin: CoinInfo, _amount: Uint<128>): CoinInfo {
    return CoinInfo { color: _coin.color,
                      value: Uint128_addChecked(_coin.value, _amount),
                      nonce: evolveNonce(0, _coin.nonce) };
  }

  /**
   * @title addQualifiedCoinValue circuit
   * @description Adds a value to a qualified coin and returns a new QualifiedCoinInfo.
   * 
   * @remarks
   * This circuit creates a new qualified coin with an increased value by adding the
   * specified amount to the original coin's value. The new coin maintains the same
   * color and Merkle tree index but has a different nonce.
   *
   * @circuitInfo k=11, rows=700
   *
   * @param {QualifiedCoinInfo} _coin   - The original qualified coin.
   * @param {Uint<128>} _amount - The amount to add to the coin.
   *
   * @returns {QualifiedCoinInfo} - A new qualified coin with the increased value.
   */
  export circuit addQualifiedCoinValue(coin: QualifiedCoinInfo, amount: Uint<128>): QualifiedCoinInfo {
    return QualifiedCoinInfo { color: coin.color,
                               value: Uint128_addChecked(coin.value, amount),
                               nonce: evolveNonce(0, coin.nonce),
                               mt_index: coin.mt_index };
  }

  /**
   * @title subQualifiedCoinValue circuit
   * @description Subtracts a value from a qualified coin and returns a new QualifiedCoinInfo.
   * 
   * @remarks
   * This circuit creates a new qualified coin with a decreased value by subtracting the
   * specified amount from the original coin's value. The new coin maintains the same
   * color and Merkle tree index but has a different nonce.
   *
   * @circuitInfo k=11, rows=700
   *
   * @param {QualifiedCoinInfo} _coin   - The original qualified coin.
   * @param {Uint<128>} _amount - The amount to subtract from the coin.
   *
   * @returns {QualifiedCoinInfo} - A new qualified coin with the decreased value.
   */
  export circuit subQualifiedCoinValue(coin: QualifiedCoinInfo, amount: Uint<128>): QualifiedCoinInfo {
    assert(amount <= coin.value, "LunarswapLibrary: subQualifiedCoinValue() - Insufficient amount");
    return QualifiedCoinInfo { color: coin.color,
                               value: Uint128_sub(coin.value, amount),
                               nonce: evolveNonce(0, coin.nonce),
                               mt_index: coin.mt_index };
  }

  /**
   * @title getIdentity circuit
   * @description Generates a unique pairId hash for a token pair.
   * 
   * @remarks
   * This circuit creates a deterministic hash that uniquely identifies a trading pair
   * by combining a constant prefix with the sorted token colors. This ensures consistent
   * pair identification across the protocol.
   *
   * @circuitInfo k=11, rows=800
   *
   * @param {CoinInfo} token0 - The first token in the pair (sorted).
   * @param {CoinInfo} token1 - The second token in the pair (sorted).
   *
   * @returns {Bytes<32>} - The unique pairId hash for the pair.
   */
  export circuit getIdentity(type0: Bytes<32>, type1: Bytes<32>, isPairId: Boolean): Bytes<32> {
    // TODO: maybe we can use another cheaper way here.
    if (isPairId) {
       return persistentHash<Vector<3, Bytes<32>>>([pad(32, "pair-id"), type0, type1]);
    } else {
       return persistentHash<Vector<3, Bytes<32>>>([pad(32, "reserve-id"), type0, type1]);
    }
  }

  /**
   * @title quote circuit
   * @description Calculates the expected output amount for a given input amount and reserves.
   * 
   * @remarks
   * This circuit implements the constant product formula to calculate the expected
   * output amount when swapping tokens. It uses the formula: amount1 = (amount0 * reserve1) / reserve0.
   *
   * Requirements:
   * - The input amount must be greater than zero
   * - Both reserves must be greater than zero
   *
   * @circuitInfo k=11, rows=1000
   *
   * @param {Uint<128>} amount0  - The input amount of token0.
   * @param {Uint<128>} reserve0 - The current reserve of token0.
   * @param {Uint<128>} reserve1 - The current reserve of token1.
   *
   * @throws {Error} "LunarswapLibrary: quote() - Insufficient amount" if amount0 is zero.
   * @throws {Error} "LunarswapLibrary: quote() - Insufficient liquidity" if reserves are zero.
   *
   * @returns {Uint<128>} - The expected output amount of token1.
   */
  export circuit quote(amount0: Uint<128>, reserve0: Uint<128>, reserve1: Uint<128>): Uint<128> {
    assert(amount0 > 0, "LunarswapLibrary: quote() - Insufficient amount");
    assert(reserve0 > 0 && reserve1 > 0, "LunarswapLibrary: quote() - Insufficient liquidity");
    return disclose(Uint128_div(Uint128_mulChecked(amount0, reserve1), reserve0));
  }

  /**
   * @title getAmountOut circuit
   * @description Calculates the expected output amount for a given input amount and reserves.
   * 
   * @remarks
   * This circuit implements the constant product formula to calculate the expected
   * output amount when swapping tokens. The calculation is as follows:
   *   amountInWithFee = amountIn * 997
   *   numerator = amountInWithFee * reserveOut
   *   denominator = reserveIn * 1000 + amountInWithFee
   *   amountOut = numerator / denominator
   *
   * @circuitInfo k=11, rows=1000
   *
   * @param {Uint<128>} amountIn  - The input amount of token0.
   * @param {Uint<128>} reserveIn - The current reserve of token0.
   * @param {Uint<128>} reserveOut - The current reserve of token1.
   *
   * @throws {Error} "LunarswapLibrary: getAmountOut() - Insufficient amount" if amountIn is zero.
   * @throws {Error} "LunarswapLibrary: getAmountOut() - Insufficient liquidity" if reserves are zero.
   *
   * @returns {Uint<128>} - The expected output amount of token1.
   */
  export circuit getAmountOut(amountIn: Uint<128>, reserveIn: Uint<128>, reserveOut: Uint<128>): Uint<128> {
    assert(amountIn > 0, "LunarswapLibrary: getAmountOut() - Insufficient amount");
    assert(reserveIn > 0 && reserveOut > 0, "LunarswapLibrary: getAmountOut() - Insufficient liquidity");
    const amountInWithFee = Uint128_mulChecked(amountIn, 997);
    const numerator = Uint128_mulChecked(amountInWithFee, reserveOut);
    const denominator = Uint128_addChecked(Uint128_mulChecked(reserveIn, 1000), amountInWithFee);
    return disclose(Uint128_div(numerator, denominator));
  }

  /**
   * @title getAmountIn circuit
   * @description Calculates the expected input amount for a given output amount and reserves.
   * 
   * @remarks
   * This circuit implements the constant product formula to calculate the expected 
   * input amount when swapping tokens. The calculation is as follows:
   *   amountOutWithFee = amountOut * 997
   *   numerator = amountOutWithFee * reserveIn * 1000
   *   denominator = reserveOut * amountOutWithFee - 997
   *   amountIn = numerator / denominator + 1
   *
   * @circuitInfo k=11, rows=1000
   *
   * @param {Uint<128>} amountOut  - The output amount of token1.
   * @param {Uint<128>} reserveIn - The current reserve of token0.
   * @param {Uint<128>} reserveOut - The current reserve of token1.
   *
   * @throws {Error} "LunarswapLibrary: getAmountIn() - Insufficient amount" if amountOut is zero.
   * @throws {Error} "LunarswapLibrary: getAmountIn() - Insufficient liquidity" if reserves are zero.
   *
   * @returns {Uint<128>} - The expected input amount of token0.
   */
  export circuit getAmountIn(amountOut: Uint<128>, reserveIn: Uint<128>, reserveOut: Uint<128>): Uint<128> {
    assert(amountOut > 0, "LunarswapLibrary: getAmountIn() - Insufficient amount");
    assert(reserveIn > 0 && reserveOut > 0, "LunarswapLibrary: getAmountIn() - Insufficient liquidity");
    const numerator = Uint128_mulChecked(Uint128_mulChecked(reserveIn, amountOut), 1000);
    const denominator = Uint128_mulChecked(Uint128_sub(reserveOut, amountOut), 997);
    return Uint128_addChecked(disclose(Uint128_div(numerator, denominator)), 1);
  }

  /**
   * @title upcastCoinInfo circuit
   * @description Converts a CoinInfo to a QualifiedCoinInfo.
   * 
   * @remarks
   * This circuit converts a regular CoinInfo to a QualifiedCoinInfo by adding a
   * Merkle tree index. This is useful when working with shielded operations that
   * require qualified coin information.
   *
   * @circuitInfo k=11, rows=500
   *
   * @param {CoinInfo} _coin - The coin to convert.
   *
   * @returns {QualifiedCoinInfo} - The converted qualified coin with mt_index set to 0.
   */
  export circuit upcastCoinInfo(_coin: CoinInfo): QualifiedCoinInfo {
    return QualifiedCoinInfo { color: _coin.color,
                               value: _coin.value,
                               nonce: evolveNonce(0, _coin.nonce),
                               mt_index: 0 };
  }

  /**
   * @title downcastCoinInfo circuit
   * @description Converts a QualifiedCoinInfo to a CoinInfo.
   * 
   * @remarks
   * This circuit converts a QualifiedCoinInfo to a regular CoinInfo by removing
   * the Merkle tree index. This is useful when working with unshielded operations.
   *
   * @circuitInfo k=11, rows=500
   *
   * @param {QualifiedCoinInfo} _coin - The qualified coin to convert.
   *
   * @returns {CoinInfo} - The converted regular coin without mt_index.
   */
  export circuit downcastCoinInfo(_coin: QualifiedCoinInfo): CoinInfo {
    return CoinInfo { color: _coin.color, value: _coin.value, nonce: evolveNonce(0, _coin.nonce) };
  }
}

</LunarswapLibrary.compact>

<LunarswapLiquidity.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (lunarswap-v1/LunarswapLiquidity.compact)

pragma language_version >= 0.18.0;

/**
 * @title LunarswapLiquidity
 * @description Liquidity Provider (LP) token management system for the Lunarswap protocol.
 * 
 * @remarks
 * The LunarswapLiquidity module manages the creation, minting, burning, and tracking of liquidity
 * provider tokens. These tokens represent a user's share of liquidity in a trading pair and
 * entitle holders to a portion of trading fees and the underlying assets.
 * 
 * Key Features:
 * - LP token minting for liquidity providers
 * - LP token burning for liquidity removal
 * - Total supply tracking per trading pair
 * - Token metadata management (name, symbol, decimals)
 * - Nonce-based token generation
 * - UTXO-based token model
 */
module LunarswapLiquidity {
  import CompactStandardLibrary;

  import "../../../compact-contracts/contracts/src/archive/ShieldedToken" prefix ShieldedToken_;
  import "../math/Uint128" prefix Uint128_;
  import "../math/Bytes32" prefix Bytes32_;

  /**
   * @ledger _counter
   * @description
   * Internal counter used for LP token nonce evolution and minting operations.
   */
  ledger _counter: Counter;

  /**
   * @ledger lpTokenNonce
   * @description
   * The global nonce used for LP token generation and uniqueness.
   */
  export ledger lpTokenNonce: Bytes<32>;

  /**
   * @ledger lpTotalSupply
   * @description
   * Mapping of trading pair hash (pairId) to the total supply and metadata of LP tokens for that pair.
   * The key is the pair hash (Bytes<32>), and the value is the QualifiedCoinInfo for the LP token.
   */
  export ledger lpTotalSupply: Map<Bytes<32>, QualifiedCoinInfo>;

  /**
   * @ledger lpTokenName
   * @description
   * The name of the LP token (e.g., "Lunarswap LP Token").
   */
  export ledger lpTokenName: Opaque<"string">;

  /**
   * @ledger lpTokenSymbol
   * @description
   * The symbol of the LP token (e.g., "LUNAR-LP").
   */
  export ledger lpTokenSymbol: Opaque<"string">;

  /**
   * @ledger lpTokenDecimals
   * @description
   * The number of decimals used for LP tokens (e.g., 18).
   */
  export ledger lpTokenDecimals: Uint<8>;

  /**
   * @ledger lpTokenType
   * @description
   * The color/type identifier for the LP token (Bytes<32>).
   */
  export ledger lpTokenType: Bytes<32>;

  /**
   * @title initialize circuit
   * @description Initializes the LP token system with basic configuration.
   * 
   * @remarks
   * This circuit sets up the initial configuration for LP tokens including name,
   * symbol, decimals, and nonce. It should only be called once during contract deployment.
   *
   * @param {Bytes<32>} nonce_      - The nonce for LP token generation.
   * @param {Opaque<"string">} name_ - The name of the LP token.
   * @param {Opaque<"string">} symbol_ - The symbol of the LP token.
   * @param {Uint<8>} decimals_     - The number of decimals for LP tokens.
   *
   * @returns [] - No return values.
   */
  export circuit initialize(
                   nonce_: Bytes<32>,
                   name_: Opaque<"string">,
                   symbol_: Opaque<"string">,
                   decimals_: Uint<8>
                   ): [] {
    lpTokenNonce = nonce_;
    lpTokenName = name_;
    lpTokenSymbol = symbol_;
    lpTokenDecimals = decimals_;
    return [];
  }

  /**
   * @title initializePairLpToken circuit
   * @description Initializes LP token tracking for a new trading pair.
   * 
   * @remarks
   * This circuit sets up the total supply tracking for a new trading pair by
   * initializing the supply to zero in the total supply map.
   *
   * Requirements:
   * - The pair pairId must not already have LP tokens initialized
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the trading pair.
   *
   * @throws {Error} "LunarswapLiquidity: initializePairLpToken() - Lp token already exists" if LP tokens already exist for this pair.
   *
   * @returns [] - No return values.
   */
  export circuit initializePairLpToken(pairId: Bytes<32>): [] {
    assert(!lpTotalSupply.member(pairId), "LunarswapLiquidity: initializePairLpToken() - Lp token already exists");
    lpTotalSupply.insert(pairId, default<QualifiedCoinInfo>);
    return [];
  }

  /**
   * @title totalSupply circuit
   * @description Returns the total supply of LP tokens for a specific pair.
   * 
   * @remarks
   * This circuit retrieves the total supply of liquidity provider tokens for a given
   * trading pair pairId.
   *
   * Requirements:
   * - The pair pairId must have LP tokens initialized
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the trading pair.
   *
   * @throws {Error} "LunarswapLiquidity: totalSupply() - Lp token not found" if LP tokens don't exist for this pair.
   *
   * @returns {Uint<128>} - The total supply of LP tokens for the pair.
   */
  export circuit totalSupply(pairId: Bytes<32>): QualifiedCoinInfo {
    assert(lpTotalSupply.member(pairId), "LunarswapLiquidity: totalSupply() - Lp token not found");
    return lpTotalSupply.lookup(pairId);
  }

  /**
   * @title mint circuit
   * @description Mints new LP tokens and sends them to the specified recipient.
   * 
   * @remarks
   * This circuit creates new LP tokens for a trading pair and sends them to the
   * specified recipient. It also updates the total supply for the pair.
   *
   * Requirements:
   * - The pair pairId must have LP tokens initialized
   * - The amount must be greater than zero
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the trading pair.
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} recipient - The recipient of the minted LP tokens.
   * @param {Uint<128>} amount - The amount of LP tokens to mint.
   *
   * @returns {CoinInfo} - The minted LP token coin.
   */
  export circuit mint(pairId: Bytes<32>,
                      recipient: Either<ZswapCoinPublicKey, ContractAddress>,
                      amount: Uint<64> // TODO: that has changed to Uint<64> because of the mintToken circuit new version
                      ): CoinInfo {
    _counter.increment(1);
    const newNonce = evolveNonce(_counter, lpTokenNonce);
    // pairId dealt as a domainSep in the mintToken circuit
    const ret = mintToken(pairId, amount, newNonce, recipient);

    if (Bytes32_isZero(lpTokenType)) {
      lpTokenType = ret.color;
    }

    const newTotalSupply =
                  QualifiedCoinInfo { nonce: ret.nonce,
                                      color: ret.color,
                                      value: Uint128_addChecked(
                                               lpTotalSupply.lookup(pairId).value, amount),
                                      mt_index: lpTotalSupply.lookup(pairId).mt_index, };
    lpTotalSupply.insert(pairId, newTotalSupply);

    return ret;
  }

  /**
   * @title burn circuit
   * @description Burns LP tokens and returns the underlying assets.
   * 
   * @remarks
   * This circuit burns LP tokens by receiving them and updating the total supply.
   * The burned tokens are sent to the burn address, and any change is returned
   * to the contract's own address.
   *
   * Requirements:
   * - The coin value must be sufficient for the burn amount
   * - The pair pairId must have LP tokens initialized
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the trading pair.
   * @param {CoinInfo} coin - The LP token coin to burn.
   * @param {Uint<128>} amount - The amount of LP tokens to burn.
   *
   * @throws {Error} "LunarswapLiquidity: burn() - Insufficient coin value" if coin value is less than burn amount.
   * @throws {Error} "LunarswapLiquidity: totalSupply() - Lp token not found" if LP tokens don't exist for this pair.
   *
   * @returns {SendResult} - The result of the burn operation including any change.
   */
  export circuit burn(pairId: Bytes<32>, coin: CoinInfo, amount: Uint<128>): SendResult {
    assert(lpTotalSupply.member(pairId), "LunarswapLiquidity: totalSupply() - Lp token not found");
    assert(coin.value >= amount, "LunarswapLiquidity: burn() - Insufficient coin value");

    receive(coin);

    const newTotalSupply =
                  QualifiedCoinInfo { nonce: coin.nonce,
                                      color: coin.color,
                                      value: Uint128_sub(lpTotalSupply.lookup(pairId).value, amount),
                                      mt_index: lpTotalSupply.lookup(pairId).mt_index, // TODO: needs review
                                      };
    lpTotalSupply.insert(pairId, newTotalSupply);

    const ret = sendImmediate(coin, burnAddress(), amount);
    if (ret.change.is_some) {
      const tmpAddr = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
      sendImmediate(ret.change.value, tmpAddr, ret.change.value.value);
    }
    return ret;
  }
}

</LunarswapLiquidity.compact>

<LunarswapPair.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (lunarswap-v1/LunarswapPair.compact)

pragma language_version >= 0.18.0;

/**
 * @title LunarswapPair
 * @description Core trading pair implementation for the Lunarswap protocol, handling liquidity provision and pair state management.
 * 
 * @remarks
 * The LunarswapPair module implements the core logic for individual trading pairs in the Lunarswap protocol.
 * It manages liquidity provision, LP token minting, fee collection, and maintains the pair's state including
 * reserves, cumulative price data, and trading statistics.
 * 
 * Key Features:
 * - Liquidity provision and LP token minting
 * - Protocol fee calculation and distribution
 * - Reserve management and updates
 * - Price oracle functionality through VWAP tracking
 * - Trading volume and price cumulative tracking
 */
module LunarswapPair {
  import CompactStandardLibrary;

  import "../../../compact-contracts/contracts/src/utils/Utils" prefix Utils_;
  import "../math/Uint128" prefix Uint128_;
  import "../math/Max" prefix Max_;

  import "./types/TPair";

  import LunarswapLibrary prefix LunarswapLibrary_;
  import LunarswapLiquidity prefix LunarswapLiquidity_;

  /**
   * @title initialize circuit
   * @description Initializes the Lunarswap pair system with LP token configuration.
   * 
   * @remarks
   * This circuit sets up the initial configuration for LP tokens including name,
   * symbol, decimals, and nonce. It should only be called once during contract deployment.
   *
   * TODO: access control needed. 
   * TODO: use initialize contract to prevent double initialize.
   *
   * @circuitInfo k=11, rows=1200
   *
   * @param {Bytes<32>} lpTokenNonce      - The nonce for LP token generation.
   * @param {Opaque<"string">} lpTokenName - The name of the LP token.
   * @param {Opaque<"string">} lpTokenSymbol - The symbol of the LP token.
   * @param {Uint<8>} lpTokenDecimals     - The number of decimals for LP tokens.
   *
   * @returns [] - No return values.
   */
  export circuit initialize(
                   lpTokenNonce: Bytes<32>,
                   lpTokenName: Opaque<"string">,
                   lpTokenSymbol: Opaque<"string">,
                   lpTokenDecimals: Uint<8>
                   ): [] {
    return LunarswapLiquidity_initialize(lpTokenNonce, lpTokenName, lpTokenSymbol, lpTokenDecimals);
  }

  /**
   * @title initializePair circuit
   * @description Initializes a new trading pair with zero reserves.
   * 
   * @remarks
   * This circuit creates a new trading pair structure with zero reserves and
   * initializes the LP token tracking for the pair. The pair is ready to accept
   * the first liquidity provision.
   *
   * @circuitInfo k=11, rows=1000
   *
   * @param {Bytes<32>} pairId - The unique pairId hash for the new pair.
   * @param {CoinInfo} token0 - The first token in the pair.
   * @param {CoinInfo} token1 - The second token in the pair.
   *
   * @returns {Pair} - The initialized pair with zero reserves and metadata.
   */
  export circuit initializePair(pairId: Bytes<32>, token0: CoinInfo, token1: CoinInfo): Pair {
    LunarswapLiquidity_initializePairLpToken(pairId);
    const reserve0Id = LunarswapLibrary_getIdentity(pairId, token0.color, false);
    const reserve1Id = LunarswapLibrary_getIdentity(pairId, token1.color, false);

    return Pair { token0Type: token0.color,
                  token1Type: token1.color,
                  // TODO: calculate the expected lpTokenType
                  lpTokenType: default<Bytes<32>>,
                  reserve0Id: reserve0Id,
                  reserve1Id: reserve1Id,
                  price0VolCumulative: default<Uint<128>>,
                  price1VolCumulative: default<Uint<128>>,
                  volume0Cumulative: default<Uint<128>>,
                  volume1Cumulative: default<Uint<128>>,
                  kLast: default<Uint<128>>, };
  }

  /**
   * @title _update circuit
   * @description Updates the pair state with new balances, metadata, and cumulative statistics.
   * 
   * @remarks
   * This internal circuit combines the functionality of _updatePairPrice and _updatePair
   * to provide a single interface for updating pair state. It updates cumulative price
   * and volume data, then creates a new pair state with the updated values.
   *
   * @param {Pair} pair           - The current pair state.
   * @param {Boolean} isFeeOn     - Whether protocol fees are enabled.
   * @param {CoinInfo} token0 - The first token being added.
   * @param {CoinInfo} token1 - The second token being added.
   * @param {Uint<128>} liquidity  - The new liquidity amount.
   * @param {Uint<128>} balance0   - The new balance of token0.
   * @param {Uint<128>} balance1   - The new balance of token1.
   * @param {QualifiedCoinInfo} reserve0   - The current reserve of token0.
   * @param {QualifiedCoinInfo} reserve1   - The current reserve of token1.
   * @param {Uint<128>} kLast      - The k value from the last fee calculation.
   *
   * @returns {Pair} - The updated pair state.
   */
  circuit _update(pair: Pair,
                  lpTokenType: Bytes<32>,
                  isFeeOn: Boolean,
                  amount0In: Uint<128>,
                  amount1In: Uint<128>,
                  balance0: Uint<128>,
                  balance1: Uint<128>,
                  reserve0: QualifiedCoinInfo,
                  reserve1: QualifiedCoinInfo,
                  kLast: Uint<128>,
                  ): Pair {
    const [price0VolCumulative, price1VolCumulative, volume0Cumulative, volume1Cumulative] =
                  _updatePairPrice(pair, reserve0, reserve1, amount0In, amount1In);
    const updatedKLast = isFeeOn ? Uint128_mulChecked(balance0, balance1) : 0;
    return Pair { token0Type: pair.token0Type,
                  token1Type: pair.token1Type,
                  lpTokenType: lpTokenType,
                  reserve0Id: pair.reserve0Id,
                  reserve1Id: pair.reserve1Id,
                  price0VolCumulative: price0VolCumulative,
                  price1VolCumulative: price1VolCumulative,
                  volume0Cumulative: volume0Cumulative,
                  volume1Cumulative: volume1Cumulative,
                  kLast: updatedKLast, };
  }

  /**
   * @title _updatePairPrice circuit
   * @description Updates cumulative price and volume data for the pair.
   * 
   * @remarks
   * This internal circuit updates the cumulative price and volume statistics
   * for the trading pair using VWAP (Volume Weighted Average Price). 
   * These values are used for price oracle functionality and tracking trading activity.
   *
   * @param {Pair} pair         - The current pair state.
   * @param {QualifiedCoinInfo} reserve0 - The current reserve of token0.
   * @param {QualifiedCoinInfo} reserve1 - The current reserve of token1.
   * @param {Uint<128>} amount0In - The amount of token0 being traded in.
   * @param {Uint<128>} amount1In - The amount of token1 being traded in.
   *
   * @returns {[Uint<128>, Uint<128>, Uint<128>, Uint<128>]} - Updated cumulativalus [price0VolCumulative, price1VolCumulative, volume0Cumulative, volume1Cumulative].
   */
  circuit _updatePairPrice(
            pair: Pair,
            reserve0: QualifiedCoinInfo,
            reserve1: QualifiedCoinInfo,
            amount0In: Uint<128>,
            amount1In: Uint<128>,
            ): [Uint<128>, Uint<128>, Uint<128>, Uint<128>] {
    if (reserve0.value != 0 && reserve1.value != 0) {
       const price0 = disclose(Uint128_div(reserve1.value, reserve0.value));
       const price1 = disclose(Uint128_div(reserve0.value, reserve1.value));

       const price0VolCumulative =
                     Uint128_addChecked(
                       pair.price0VolCumulative, Uint128_mulChecked(price0, amount0In));
       const price1VolCumulative =
                     Uint128_addChecked(
                       pair.price1VolCumulative, Uint128_mulChecked(price1, amount1In));

       const volume0Cumulative = Uint128_addChecked(pair.volume0Cumulative, amount0In);
       const volume1Cumulative = Uint128_addChecked(pair.volume1Cumulative, amount1In);

       return [price0VolCumulative, price1VolCumulative, volume0Cumulative, volume1Cumulative];
    }
    else {
       return [pair.price0VolCumulative,
               pair.price1VolCumulative,
               pair.volume0Cumulative,
               pair.volume1Cumulative];
    }
  }
}

</LunarswapPair.compact>

<TPair.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (lunarswap-v1/LunarswapTypes.compact)

pragma language_version >= 0.18.0;

module TPair {
  import CompactStandardLibrary;

  /**
  * @struct Pair
  * @description
  * Represents a Lunarswap trading pair, tracking cumulative price and volume statistics,
  * as well as the last recorded product of reserves (kLast) for fee calculations.
  *
  * @field {Bytes<32>} token0Type - The color (type) of the first token in the pair.
  * @field {Bytes<32>} token1Type - The color (type) of the second token in the pair.
  * @field {Bytes<32>} lpTokenType - The color (type) of the LP token in the pair.
  * @field {Uint<128>} price0VolCumulative - Cumulative sum of (price0 * volume), representing Token 1 per Token 0.
  * @field {Uint<128>} price1VolCumulative - Cumulative sum of (price1 * volume), representing Token 0 per Token 1.
  * @field {Uint<128>} volume0Cumulative - Cumulative trading volume of token0.
  * @field {Uint<128>} volume1Cumulative - Cumulative trading volume of token1.
  * @field {Uint<128>} kLast - Last recorded value of reserve0 * reserve1, used for protocol fee calculations.
  */
  export struct Pair {
    token0Type: Bytes<32>,
    token1Type: Bytes<32>,
    lpTokenType: Bytes<32>,
    reserve0Id: Bytes<32>,
    reserve1Id: Bytes<32>,
    price0VolCumulative: Uint<128>,
    price1VolCumulative: Uint<128>,
    volume0Cumulative: Uint<128>,
    volume1Cumulative: Uint<128>,
    kLast: Uint<128>,
  }
}

</TPair.compact>

<Bytes32.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/Bytes32.compact)

pragma language_version >= 0.18.0;

/**
 * @title Bytes32 module
 * @description Comprehensive utility functions for working with Bytes<32> types.
 * Includes conversion functions, equality checks, and comparison operations using field conversion.
 * 
 * @remarks
 * This module provides a complete set of utilities for 32-byte manipulation and comparison.
 * Comparison operations convert bytes to field elements and then to unsigned integers for ordering.
 * All functions are designed to work specifically with 32-byte arrays.
 * 
 * TODO: Implement secure U256 conversion circuits:
 * - toU256(): Convert Bytes<32> to U256 (more accurate than converting to Field, which is only 254 bits)
 * - fromU256(): Convert U256 to Bytes<32>
 *   These conversions will be supported when casting Bytes<k> to Vector<k, Uint<8>> is released.
 *   See PR: https://github.com/midnightntwrk/compactc/pull/1090. 
 *   Once this PR's feature is released, arithmetic operations such as add, sub, mul, div,
 *   and rem will also be supported for Bytes<32> via U256 conversion.
 * 
 * Supported Mathematical Operations:
 * - Conversions:
 *   - toField(): Converts Bytes<32> to a Field using field conversion.
 *   - toBytes(): Converts a Field to Bytes<32> using upgrade_from_transient.
 * - Comparisons:
 *   - eq(): Checks if two Bytes<32> values are equal.
 *   - lt(): Checks if one Bytes<32> value is less than another.
 *   - lte(): Checks if one Bytes<32> value is less than or equal to another.
 *   - gt(): Checks if one Bytes<32> value is greater than another.
 *   - gte(): Checks if one Bytes<32> value is greater than or equal to another.
 * - Utility:
 *   - isZero(): Checks if a Bytes<32> value is zero.
 */
module Bytes32 {
  import CompactStandardLibrary;

  import "./interfaces/IUint256";

  import Field254 prefix Field254_;

  /**
   * @title fromBytes circuit
   * @description Converts Bytes<32> to a Field using field conversion.
   * 
   * @remarks
   * This function performs a type conversion from bytes to field elements.
   * The conversion uses the degrade_to_transient built-in function.
   * Special handling is included for zero bytes to avoid field size overflow.
   *
   * @param {Bytes<32>} a - The bytes value to convert to a field element.
   *
   * @returns {Field} - The field representation of the bytes.
   * 
   * @throws {Error} "Bytes32: toField() - inputs exceed the field size" - When the input bytes represent a value that exceeds the field size after conversion.
   */
  export circuit fromBytes(a: Bytes<32>): Field {
    // Inline the isZero logic to avoid invalid context error
    if (isZero(a)) {
      return 0 as Field;
    }
    const aField = degradeToTransient(a);
    assert(aField != (0 as Field), "Bytes32: toField() - inputs exceed the field size");
    return aField;
  }

  /**
   * @title toBytes circuit
   * @description Converts a Field to Bytes<32> using upgrade_from_transient.
   * 
   * @remarks
   * This function performs a type conversion from field elements to bytes.
   * The conversion uses the upgrade_from_transient built-in function.
   * The output is always 32 bytes regardless of the input field size.
   *
   * @param {Field} a - The field value to convert to bytes.
   *
   * @returns {Bytes<32>} - The bytes representation of the field (32 bytes).
   */
  export circuit toBytes(a: Field): Bytes<32> {
    return upgradeFromTransient(a);
  }

  /**
   * @title eq circuit
   * @description Compares two Bytes<32> for equality.
   * 
   * @remarks
   * This function performs a direct equality comparison between two 32-byte arrays.
   * Uses the built-in equality operator for byte comparison.
   *
   * @param {Bytes<32>} a - First bytes value to compare.
   * @param {Bytes<32>} b - Second bytes value to compare.
   *
   * @returns {Boolean} - True if the bytes are equal, false otherwise.
   */
  export circuit eq(a: Bytes<32>, b: Bytes<32>): Boolean {
    return a == b;
  }

  /**
   * @title lt circuit
   * @description Compares two Bytes<32> for less than using field conversion and uint comparison.
   * 
   * @remarks
   * This function converts both byte arrays to field elements, then to unsigned integers,
   * and compares them to determine lexicographic ordering.
   * The comparison is consistent and deterministic for any 32-byte arrays.
   * Includes validation to ensure inputs don't exceed field size.
   *
   * @param {Bytes<32>} a - First bytes value to compare.
   * @param {Bytes<32>} b - Second bytes value to compare.
   *
   * @returns {Boolean} - True if a < b (based on uint comparison), false otherwise.
   * 
   * @throws {Error} "Bytes32: lt() - comparison invalid; one or both of the inputs exceed the field size" - When the field representations of both inputs are equal but their byte representations are not, indicating one or both inputs exceed the field size.
   */
  export circuit lt(a: Bytes<32>, b: Bytes<32>): Boolean {
    const isBytesEqual = eq(a, b);
    if (isBytesEqual) {
      return false;
    }

    const aField = fromBytes(a);
    const bField = fromBytes(b);
    const isFieldEqual = aField == bField;
    if (isFieldEqual) {
      assert(isBytesEqual && isFieldEqual, "Bytes32: lt() - comparison invalid; one or both of the inputs exceed the field size");
    }
    return Field254_lt(aField, bField);
  }

  /**
   * @title lte circuit
   * @description Compares two Bytes<32> for less than or equal using field conversion and uint comparison.
   * 
   * @remarks
   * This function combines the less than and equality comparisons.
   * Returns true if a <= b based on the combined comparison logic.
   *
   * @param {Bytes<32>} a - First bytes value to compare.
   * @param {Bytes<32>} b - Second bytes value to compare.
   *
   * @returns {Boolean} - True if a <= b, false otherwise.
   */
  export circuit lte(a: Bytes<32>, b: Bytes<32>): Boolean {
    return lt(a, b) || eq(a, b);
  }

  /**
   * @title gt circuit
   * @description Compares two Bytes<32> for greater than using field conversion and uint comparison.
   * 
   * @remarks
   * This function uses the less than comparison with swapped operands.
   * Returns true if a > b based on the comparison logic.
   *
   * @param {Bytes<32>} a - First bytes value to compare.
   * @param {Bytes<32>} b - Second bytes value to compare.
   *
   * @returns {Boolean} - True if a > b, false otherwise.
   */
  export circuit gt(a: Bytes<32>, b: Bytes<32>): Boolean {
    return lt(b, a);
  }

  /**
   * @title gte circuit
   * @description Compares two Bytes<32> for greater than or equal using field conversion and uint comparison.
   * 
   * @remarks
   * This function combines the greater than and equality comparisons.
   * Returns true if a >= b based on the combined comparison logic.
   *
   * @param {Bytes<32>} a - First bytes value to compare.
   * @param {Bytes<32>} b - Second bytes value to compare.
   *
   * @returns {Boolean} - True if a >= b, false otherwise.
   */
  export circuit gte(a: Bytes<32>, b: Bytes<32>): Boolean {
    return lt(b, a) || eq(a, b);
  }

  /**
   * @title isZero circuit
   * @description Checks if a Bytes<32> is zero.
   * 
   * @remarks
   * This function performs a direct comparison of the bytes with zero.
   * 
   * @param {Bytes<32>} a - The bytes value to check.
   *
   * @returns {Boolean} - True if the bytes are zero, false otherwise.
   */
  export circuit isZero(a: Bytes<32>): Boolean {
    return a == upgradeFromTransient(0 as Field);
  }
}

</Bytes32.compact>

<Field254.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/Field254.compact)

pragma language_version >= 0.18.0;

/**
 * @title Field254
 * @dev A utility module providing mathematical operations for 254-bit unsigned integers
 * using the U254 struct, which represents numbers as high * 2^128 + low, where high and low are
 * 128-bit unsigned integers (Uint<128>) in [0, 2^128 - 1]. The module supports a range of
 * operations including comparisons, arithmetic, division, square root, and utility functions.
 * All operations work directly with U254 struct inputs.
 *
 * Supported Mathematical Operations:
 * - Conversions:
 *   - fromField(): Converts a Field to a U256 struct (interpreting the field as a 254-bit unsigned integer).
 *   - toField(): Converts a U256 struct to a Field (with range checks for 254 bits).
 * - Comparisons:
 *   - eq(): Checks if two Field values are equal.
 *   - lt(): Checks if one Field value is less than another.
 *   - lte(): Checks if one Field value is less than or equal to another.
 *   - gt(): Checks if one Field value is greater than another.
 *   - gte(): Checks if one Field value is greater than or equal to another.
 * - Arithmetic:
 *   - add(): Adds two Field values, checking for overflow.
 *   - sub(): Subtracts one Field value from another, checking for underflow.
 *   - mul(): Multiplies two Field values, checking for overflow.
 * - Division:
 *   - div(): Computes the quotient of dividing one Field value by another.
 *   - rem(): Computes the remainder of dividing one Field value by another.
 * - Square Root:
 *   - sqrt(): Computes the floor of the square root of a Field value.
 * - Utility:
 *   - min(): Returns the smaller of two Field values.
 *   - max(): Returns the larger of two Field values.
 *   - isZero(): Checks if a Field value is zero.
 */
module Field254 {
  import CompactStandardLibrary;

  import "./interfaces/IUint256";
  import "./interfaces/IUint128";

  import Uint256 prefix Uint256_;
  import Uint128 prefix Uint128_;

  /**
   * @title From Field circuit
   * @description Converts a Field value to a U256 struct representation.
   * 
   * @circuitInfo k=10, rows=512
   *
   * Theoretical Description:
   * This circuit converts a field element to a U256 struct representation.
   * The field element is treated as a 254-bit unsigned integer and converted
   * to the U256 struct format where value = high * 2^128 + low.
   *
   * Mathematical Steps:
   * 1. Cast the field element to Uint<254>.
   * 2. Split into 128-bit halves via `divUint254Locally`:
   *    - `low`      = value mod 2^128 (least significant 128 bits).
   *    - `high`     = floor(value / 2^128) (remaining bits, guaranteed <2^128).
   * 3. Extract the U128 limbs from each half:
   *    - `lowU128`  = low.low (U128 struct from MathU128).
   *    - `highU128` = high.low.
   * 4. Build two intermediate U256s:
   *    - `lowU256`  has `lowU128` in the low half, zero in the high half.
   *    - `highU256` has `highU128` in the high half, zero in the low half.
   * 5. Recombine by simple placement and addition (no 256-bit multiplication):
   *    - `reconstructed = add(highU256, lowU256)`
   * 6. Assert `reconstructed == origU256` to guarantee lossless conversion.
   *
   * @param {Field} a - The field value to convert.
   *
   * @throws {Error} "MathU256: reconstruction mismatch" if the conversion loses bits.
   *
   * @returns {U256} The U256 struct representation of the field value.
   */
  export circuit fromField(a: Field): U256 {
    // divide into 128-bit halves
    const result = divUint254Locally(a as Uint<254>, Uint256_MODULUS());
    const low = result.remainder;
    const high = result.quotient;

    // extract U128 limbs
    const lowU128 = result.remainder.low;
    const highU128 = result.quotient.low;

    // original U256 value
    const origU256 = U256 { low: lowU128, high: highU128 };

    // build low-half and high-half as full U256s
    const lowU256 = U256 { low: lowU128, high: U128 { low: 0, high: 0 } };
    const highU256 = U256 { low: U128 { low: 0, high: 0 }, high: highU128 };

    // recombine by simple placement + add (no multiply)
    const reconstructed = Uint256_add(highU256, lowU256);

    // verify lossless conversion
    assert(Uint256_eq(reconstructed, origU256), "MathU256: reconstruction mismatch");

    return origU256;
  }

  /**
   * @title To Field circuit
   * @description Converts a U256 struct to a Field value.
   * 
   * @circuitInfo k=10, rows=512
   *
   * @param {U256} a - The U256 struct to convert.
   *
   * @throws {Error} "MathU256: reconstruction mismatch" if the conversion is not lossless.
   *
   * @returns {Field} The Field representation of the U256 value.
   */
  export circuit toField(a: U256): Field {
    return Uint256_fromU256(a) as Field;
  }

  /**
   * @title Equality circuit
   * @description Compares two Field values for equality using U256 conversion.
   *
   * This circuit compares two field elements by converting them to U256 structs
   * and then using the MathU256 equality comparison. The comparison is performed
   * by first converting both field values to U256 format, then comparing them
   * using the existing Uint256_eq function.
   * 
   * @remarks
   * Requirements:
   * - Both `a` and `b` must be valid `Field` values.
   * - Comparison is performed by converting to U256 and using Uint256_eq.
   *
   * @circuitInfo k=10, rows=128
   *
   * @param {Field} a - The first field value to compare.
   * @param {Field} b - The second field value to compare.
   *
   * @returns {Boolean} True if a == b, false otherwise.
   */
  export circuit eq(a: Field, b: Field): Boolean {
    const aU256 = fromField(a);
    const bU256 = fromField(b);
    return Uint256_eq(aU256, bU256);
  }

  /**
   * @title Less Than circuit
   * @description Compares two Field values to check if a < b using U256 conversion.
   *
   * This circuit compares two field elements by converting them to U256 structs
   * and then using the MathU256 less than comparison. The comparison is performed
   * by first converting both field values to U256 format, then comparing them
   * using the existing Uint256_lt function.
   * 
   * @remarks
   * Requirements:
   * - Both `a` and `b` must be valid `Field` values.
   * - Comparison is performed by converting to U256 and using Uint256_lt.
   *
   * @circuitInfo k=10, rows=128
   *
   * @param {Field} a - The first field value to compare.
   * @param {Field} b - The second field value to compare.
   *
   * @returns {Boolean} True if a < b, false otherwise.
   */
  export circuit lt(a: Field, b: Field): Boolean {
    const aU256 = fromField(a);
    const bU256 = fromField(b);
    return Uint256_lt(aU256, bU256);
  }

  /**
   * @title Less Than or Equal circuit
   * @description Compares two Field values to check if a <= b using U256 conversion.
   *
   * This circuit compares two field elements by converting them to U256 structs
   * and then using the MathU256 less than or equal comparison. The comparison is performed
   * by first converting both field values to U256 format, then comparing them
   * using the existing Uint256_lte function.
   * 
   * @remarks
   * Requirements:
   * - Both `a` and `b` must be valid `Field` values.
   * - Comparison is performed by converting to U256 and using Uint256_lte.
   *
   * @circuitInfo k=10, rows=128
   *
   * @param {Field} a - The first field value to compare.
   * @param {Field} b - The second field value to compare.
   *
   * @returns {Boolean} True if a <= b, false otherwise.
   */
  export circuit lte(a: Field, b: Field): Boolean {
    const aU256 = fromField(a);
    const bU256 = fromField(b);
    return Uint256_lte(aU256, bU256);
  }

  /**
   * @title Greater Than circuit
   * @description Compares two Field values to check if a > b using U256 conversion.
   *
   * This circuit compares two field elements by converting them to U256 structs
   * and then using the MathU256 greater than comparison. The comparison is performed
   * by first converting both field values to U256 format, then comparing them
   * using the existing Uint256_gt function.
   * 
   * @remarks
   * Requirements:
   * - Both `a` and `b` must be valid `Field` values.
   * - Comparison is performed by converting to U256 and using Uint256_gt.
   *
   * @circuitInfo k=10, rows=128
   *
   * @param {Field} a - The first field value to compare.
   * @param {Field} b - The second field value to compare.
   *
   * @returns {Boolean} True if a > b, false otherwise.
   */
  export circuit gt(a: Field, b: Field): Boolean {
    const aU256 = fromField(a);
    const bU256 = fromField(b);
    return Uint256_gt(aU256, bU256);
  }

  /**
   * @title Greater Than or Equal circuit
   * @description Compares two Field values to check if a >= b using U256 conversion.
   *
   * This circuit compares two field elements by converting them to U256 structs
   * and then using the MathU256 greater than or equal comparison. The comparison is performed
   * by first converting both field values to U256 format, then comparing them
   * using the existing Uint256_gte function.
   * 
   * @remarks
   * Requirements:
   * - Both `a` and `b` must be valid `Field` values.
   * - Comparison is performed by converting to U256 and using Uint256_gte.
   *
   * @circuitInfo k=10, rows=128
   *
   * @param {Field} a - The first field value to compare.
   * @param {Field} b - The second field value to compare.
   *
   * @returns {Boolean} True if a >= b, false otherwise.
   */
  export circuit gte(a: Field, b: Field): Boolean {
    const aU256 = fromField(a);
    const bU256 = fromField(b);
    return Uint256_gte(aU256, bU256);
  }

  /**
   * @title Add circuit
   * @description Adds two Field values using U256 conversion.
   *
   * This circuit adds two field elements by converting them to U256 structs,
   * performing the addition using Uint256_add, and converting the result back to Field.
   * The addition is performed modulo the field size (2^254 - 1).
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Field` values.
   * - Result is computed modulo the field size.
   *
   * @circuitInfo k=12, rows=3008
   *
   * @param {Field} a - The first field value to add.
   * @param {Field} b - The second field value to add.
   *
   * @returns {Field} The sum of a and b modulo the field size.
   */
  export circuit add(a: Field, b: Field): Field {
    const aU256 = fromField(a);
    const bU256 = fromField(b);
    const sumU256 = Uint256_add(aU256, bU256);
    return toField(sumU256);
  }

  /**
   * @title Subtract circuit
   * @description Subtracts one Field value from another using U256 conversion.
   *
   * This circuit subtracts two field elements by converting them to U256 structs,
   * performing the subtraction using Uint256_sub, and converting the result back to Field.
   * The subtraction is performed modulo the field size (2^254 - 1).
   * 
   * @remarks
   * Requirements:
   * - `a` must be greater than or equal to `b` to prevent underflow.
   * - Both inputs must be valid `Field` values.
   *
   * @circuitInfo k=12, rows=3008
   *
   * @param {Field} a - The field value to subtract from (minuend).
   * @param {Field} b - The field value to subtract (subtrahend).
   *
   * @throws {Error} "MathU256: subtraction underflow" if a < b.
   *
   * @returns {Field} The difference of a and b modulo the field size.
   */
  export circuit sub(a: Field, b: Field): Field {
    const aU256 = fromField(a);
    const bU256 = fromField(b);
    const diffU256 = Uint256_sub(aU256, bU256);
    return toField(diffU256);
  }

  /**
   * @title Multiply circuit
   * @description Multiplies two Field values using U256 conversion.
   *
   * This circuit multiplies two field elements by converting them to U256 structs,
   * performing the multiplication using Uint256_mul, and converting the result back to Field.
   * The multiplication is performed modulo the field size (2^254 - 1).
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Field` values.
   * - Result must not exceed 2^256 - 1.
   *
   * @circuitInfo k=14, rows=10956
   *
   * @param {Field} a - The first field value to multiply.
   * @param {Field} b - The second field value to multiply.
   *
   * @throws {Error} "MathU256: multiplication overflow" if the product exceeds 2^256 - 1.
   *
   * @returns {Field} The product of a and b modulo the field size.
   */
  export circuit mul(a: Field, b: Field): Field {
    const aU256 = fromField(a);
    const bU256 = fromField(b);
    const productU256 = Uint256_mul(aU256, bU256);
    return toField(productU256);
  }

  /**
   * @title Internal Division circuit
   * @description Computes the quotient and remainder of dividing two Field values.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero, otherwise the circuit aborts with "MathU256: division by zero".
   * - Both `a` and `b` must be valid Field values.
   *
   * @circuitInfo k=14, rows=12623
   *
   * @param {Field} a - The field value to divide (dividend).
   * @param {Field} b - The field value to divide by (divisor).
   *
   * @throws {Error} "MathU256: division by zero" if `b` is zero.
   *
   * @returns {DivResultU256} The quotient and remainder of the division as U256 structs.
   */
  circuit _div(a: Field, b: Field): DivResultU256 {
    const aU256 = fromField(a);
    const bU256 = fromField(b);
    return Uint256_divRem(aU256, bU256);
  }

  /**
   * @title Division circuit
   * @description Divides a Field a by a Field b, returning quotient.
   *
   * This circuit divides two field elements by converting them to U256 structs,
   * performing the division using Uint256_div, and converting the result back to Field.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses U256 conversion for computation.
   *
   * @circuitInfo k=14, rows=12623
   *
   * @param {Field} a - The field value to divide (dividend).
   * @param {Field} b - The field value to divide by (divisor).
   *
   * @throws {Error} "MathU256: division by zero" if b = 0.
   *
   * @returns {Field} The quotient of the division.
   */
  export circuit div(a: Field, b: Field): Field {
    return toField(_div(a, b).quotient);
  }

  /**
   * @title Remainder circuit
   * @description Computes the remainder of dividing a Field a by a Field b.
   *
   * This circuit computes the remainder of dividing two field elements
   * by converting them to U256 structs, performing the remainder operation using Uint256_rem,
   * and converting the result back to Field.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses U256 conversion for computation.
   *
   * @circuitInfo k=14, rows=12623
   *
   * @param {Field} a - The field value to divide (dividend).
   * @param {Field} b - The field value to divide by (divisor).
   *
   * @throws {Error} "MathU256: division by zero" if b = 0.
   *
   * @returns {Field} The remainder of the division.
   */
  export circuit rem(a: Field, b: Field): Field {
    return toField(_div(a, b).remainder);
  }

  /**
   * @title Division with Remainder circuit
   * @description Computes the quotient and remainder of dividing a Field a by a Field b.
   *
   * This circuit computes both the quotient and remainder of dividing two field elements
   * by converting them to U256 structs, performing the division using Uint256_divRem,
   * and converting the results back to Field.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses U256 conversion for computation.
   *
   * @circuitInfo k=14, rows=12101
   *
   * @param {Field} a - The field value to divide (dividend).
   * @param {Field} b - The field value to divide by (divisor).
   *
   * @throws {Error} "MathU256: division by zero" if b = 0.
   *
   * @returns {DivResultU256} The quotient and remainder of the division as U256 structs.
   */
  export circuit divRem(a: Field, b: Field): DivResultU256 {
    return _div(a, b);
  }

  /**
   * @title Square Root circuit
   * @description Computes the square root of a Field value using U256 conversion.
   *
   * This circuit computes the square root of a field element by converting it to a U256 struct,
   * performing the square root operation using Uint256_sqrt, and converting the result back to Field.
   * The result is the floor of the square root.
   * 
   * @remarks
   * Requirements:
   * - `radicand` must be a valid `Field` value.
   * - Uses U256 conversion for computation.
   *
   * @circuitInfo k=14, rows=11693
   *
   * @param {Field} radicand - The field value to compute the square root of.
   *
   * @throws {Error} "MathU256: sqrt overestimate" if R^2 > radicand.
   * @throws {Error} "MathU256: sqrt underestimate" if (R + 1)^2 <= radicand.
   *
   * @returns {Field} The floor of the square root of radicand.
   */
  export circuit sqrt(radicand: Field): Field {
    const radicandU256 = fromField(radicand);
    const rootUint128 = Uint256_sqrt(radicandU256);
    const rootU256 = U256 { low: Uint128_toU128(rootUint128), high: U128 { low: 0, high: 0 } };
    return toField(rootU256);
  }

  /**
   * @title Minimum circuit
   * @description Returns the minimum of two Field values using U256 conversion.
   *
   * This circuit computes the minimum of two field elements by converting them to U256 structs,
   * performing the minimum operation using Uint256_min, and converting the result back to Field.
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Field` values.
   * - Uses U256 conversion for computation.
   *
   * @circuitInfo k=12, rows=2208
   *
   * @param {Field} a - The first field value.
   * @param {Field} b - The second field value.
   *
   * @returns {Field} The smaller of a and b.
   */
  export circuit min(a: Field, b: Field): Field {
    const aU256 = fromField(a);
    const bU256 = fromField(b);
    const minU256 = Uint256_min(aU256, bU256);
    return toField(minU256);
  }

  /**
   * @title Maximum circuit
   * @description Returns the maximum of two Field values using U256 conversion.
   *
   * This circuit computes the maximum of two field elements by converting them to U256 structs,
   * performing the maximum operation using Uint256_max, and converting the result back to Field.
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Field` values.
   * - Uses U256 conversion for computation.
   *
   * @circuitInfo k=12, rows=2208
   *
   * @param {Field} a - The first field value.
   * @param {Field} b - The second field value.
   *
   * @returns {Field} The larger of a and b.
   */
  export circuit max(a: Field, b: Field): Field {
    const aU256 = fromField(a);
    const bU256 = fromField(b);
    const maxU256 = Uint256_max(aU256, bU256);
    return toField(maxU256);
  }

  /**
   * @title Is Zero circuit
   * @description Checks if a Field value equals zero using U256 conversion.
   *
   * This circuit checks if a field element equals zero by converting it to a U256 struct
   * and then using the MathU256 isZero function. This provides a consistent way to check
   * for zero values across the Field254 module.
   *
   * @circuitInfo k=10, rows=128
   *
   * @param {Field} a - The field value to check.
   *
   * @returns {Boolean} True if a equals zero, false otherwise.
   */
  export circuit isZero(a: Field): Boolean {
    const aU256 = fromField(a);
    return Uint256_isZero(aU256);
  }
}

</Field254.compact>

<Index.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/Index.compact)

pragma language_version >= 0.18.0;

/**
 * @title Index
 * @description Re-exports ledger-related types and state from Math.compact for use in contracts and TypeScript.
 * 
 * This module serves as a centralized export point for all mathematical types, constants, and result structures
 * used throughout the openzeppelin-midnight-apps math contracts. It provides a clean interface for importing the necessary
 * components without having to import from multiple individual files.
 * 
 * The module re-exports:
 * - Core data structures (U128, U256) for representing large integers
 * - Maximum value constants for various integer types
 * - Division result structures for different integer sizes
 * 
 * This approach ensures consistency across the codebase and simplifies imports for contract developers.
 * 
 * @example
 * ```compact
 * import Index;
 * 
 * // Use the exported types and constants
 * const maxU64 = Index.MAX_UINT64();
 * const result = Index.DivResultU128 { quotient: ..., remainder: ... };
 * ```
 */
import "./interfaces/IUint64";

import "./interfaces/IUint128";

import "./interfaces/IUint256";

import Max;

/**
 * @description Core data structures for representing large integers.
 * 
 * These structs provide efficient representations of integers larger than the native field size:
 * - U128: Represents 128-bit integers as { low: Uint<64>, high: Uint<64> }
 * - U256: Represents 256-bit integers as { low: U128, high: U128 }
 */
export { U128, U256 }

/**
 * @description Maximum value constants for various unsigned integer types.
 * 
 * These pure circuits return the maximum possible value for each integer size:
 * - MAX_UINT8: Maximum 8-bit unsigned integer (255)
 * - MAX_UINT16: Maximum 16-bit unsigned integer (65,535)
 * - MAX_UINT32: Maximum 32-bit unsigned integer (4,294,967,295)
 * - MAX_UINT64: Maximum 64-bit unsigned integer (18,446,744,073,709,551,615)
 * - MAX_UINT128: Maximum 128-bit unsigned integer
 * - MAX_UINT254: Maximum 254-bit unsigned integer
 * - MAX_FIELD: Maximum field element (2^254 - 1)
 * - MAX_U128: Maximum U128 struct value
 * - MAX_U256: Maximum U256 struct value
 */
export { MAX_UINT8,
         MAX_UINT16,
         MAX_UINT32,
         MAX_UINT64,
         MAX_UINT128,
         MAX_UINT254,
         MAX_FIELD,
         MAX_U128,
         MAX_U256 }

/**
 * @description Division result structures for different integer sizes.
 * 
 * These structs contain both quotient and remainder from division operations:
 * - DivResultU64: Division result for 64-bit integers
 * - DivResultU128: Division result for 128-bit integers
 * - DivResultU256: Division result for 256-bit integers
 */
export { DivResultU64, DivResultU128, DivResultU256 };

</Index.compact>

<Max.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/Max.compact)

pragma language_version >= 0.18.0;

/**
 * @description A module providing maximum values for various unsigned integer types.
 *
 * Supported Operations:
 * - MAX_UINT8():   Returns the maximum value for an 8-bit unsigned integer (2^8 - 1).
 * - MAX_UINT16():  Returns the maximum value for a 16-bit unsigned integer (2^16 - 1).
 * - MAX_UINT32():  Returns the maximum value for a 32-bit unsigned integer (2^32 - 1).
 * - MAX_UINT64():  Returns the maximum value for a 64-bit unsigned integer (2^64 - 1).
 * - MAX_UINT128(): Returns the maximum value for a 128-bit unsigned integer (2^128 - 1).
 * - MAX_UINT254(): Returns the maximum value for a 254-bit unsigned integer (2^254 - 1) as a U256 struct.
 * - MAX_FIELD():   Returns the maximum value for a field element (2^254 - 1).
 * - MAX_U128():    Returns the maximum value for a U128 struct, where both low and high
 *                  fields are set to the maximum 64-bit value (2^64 - 1).
 * - MAX_U256():    Returns the maximum value for a U256 struct, where both low and high
 *                  fields are set to U128 structs with both low and high fields set to the maximum 64-bit value (2^64 - 1).
 *
 * This module contains pure circuits that return the maximum possible value for each
 * supported unsigned integer size (8-bit through 256-bit).
 */
module Max {
  import "./interfaces/IUint128";
  import "./interfaces/IUint256";

  /**
   * @title MAX_UINT8 circuit
   * @description Returns the maximum value for an 8-bit unsigned integer (2^8 - 1).
   * 
   * @circuitInfo k=10, rows=128
   *
   * @returns {Uint<8>} The value 255 (0xFF).
   */
  export pure circuit MAX_UINT8(): Uint<8> {
    return 255;
  }

  /**
   * @title MAX_UINT16 circuit
   * @description Returns the maximum value for a 16-bit unsigned integer (2^16 - 1).
   * 
   * @circuitInfo k=10, rows=128
   *
   * @returns {Uint<16>} The value 65,535 (0xFFFF).
   */
  export pure circuit MAX_UINT16(): Uint<16> {
    return 65535;
  }

  /**
   * @title MAX_UINT32 circuit
   * @description Returns the maximum value for a 32-bit unsigned integer (2^32 - 1).
   * 
   * @circuitInfo k=10, rows=128
   *
   * @returns {Uint<32>} The value 4,294,967,295 (0xFFFFFFFF).
   */
  export pure circuit MAX_UINT32(): Uint<32> {
    return 4294967295;
  }

  /**
   * @title MAX_UINT64 circuit
   * @description Returns the maximum value for a 64-bit unsigned integer (2^64 - 1).
   * 
   * @circuitInfo k=10, rows=128
   *
   * @returns {Uint<64>} The value 18,446,744,073,709,551,615 (0xFFFFFFFFFFFFFFFF).
   */
  export pure circuit MAX_UINT64(): Uint<64> {
    return 18446744073709551615;
  }

  /**
   * @title MAX_UINT128 circuit
   * @description Returns the maximum value for a 128-bit unsigned integer (2^128 - 1).
   * 
   * @circuitInfo k=10, rows=128
   *
   * @returns {Uint<128>} The value 340,282,366,920,938,463,463,374,607,431,768,211,455 
   * (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF).
   */
  export pure circuit MAX_UINT128(): Uint<128> {
    return 340282366920938463463374607431768211455;
  }

  /**
   * @title MAX_UINT254 circuit
   * @description A pure circuit that returns the maximum Uint<254> value as a U256 struct.
   *
   * MAX_Uint254 = 2^254 - 1 = 28948022309329048855892746252171976963317496166410141009864396001978282409983
   * 
   * @circuitInfo k=10, rows=128
   *
   * @returns {U256} The maximum Uint<254> value (2^254 - 1) as a U256 struct.
   */
  export pure circuit MAX_UINT254(): U256 {
    return U256 { low: U128 { low: 18446744073709551615, high: 18446744073709551615 },
                  high: U128 { low: 18446744073709551615, high: 4611686018427387903 } }; // 2^254 - 1
  }

  /**
   * @title MAX_FIELD circuit
   * @description Returns the maximum value for a field element (2^254 - 1).
   * 
   * @circuitInfo k=10, rows=128
   *
   * @returns {Uint<254>} The value 28948022309329048855892746252171976963317496166410141009864396001978282409983
   * (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF).
   */
  export pure circuit MAX_FIELD(): Uint<254> {
    return 28948022309329048855892746252171976963317496166410141009864396001978282409983;
  }

  /**
   * @title MAX_U128 circuit
   * @description Returns the maximum value for a U128 struct, where both low and high
   * fields are set to the maximum 64-bit value (2^64 - 1).
   * 
   * @circuitInfo k=10, rows=128
   *
   * @returns {U128} A U128 struct representing 2^128 - 1.
   */
  export pure circuit MAX_U128(): U128 {
    return U128 { low: MAX_UINT64(), high: MAX_UINT64() };
  }

  /**
   * @title MAX_U256 circuit
   * @description Returns the maximum value for a U256 struct, where both low and high
   * fields are set to the maximum 128-bit value (2^128 - 1).
   * 
   * @circuitInfo k=10, rows=128
   *
   * @returns {U256} A U256 struct representing 2^256 - 1.
   */
  export pure circuit MAX_U256(): U256 {
    return U256 { low: MAX_U128(), high: MAX_U128() };
  }
}

</Max.compact>

<Uint128.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/Uint128.compact)

pragma language_version >= 0.18.0;

/**
 * @title Uint128
 * @dev A utility module providing mathematical operations for 128-bit unsigned integers
 * using the U128 struct, which represents numbers as high * 2^64 + low, where high and low are
 * 64-bit unsigned integers (Uint<64>) in [0, 2^64 - 1]. The module supports conversions,
 * comparisons, arithmetic, division, square root, and utility functions. Operations are provided
 * in dual forms: one for Uint<128> inputs with conversions to/from U128, and another for direct
 * U128 inputs.
 *
 * Supported Mathematical Operations:
 * - Conversions:
 *   - toU128(): Converts a Uint<128> to a U128 struct by splitting into high and low 64-bit parts.
 *   - fromU128(): Converts a U128 struct to a Uint<128> by combining high and low parts.
 * - Comparisons:
 *   - eq(), eqU128(): Checks if two 128-bit numbers are equal.
 *   - lt(), ltU128(): Checks if one 128-bit number is less than another.
 *   - lte(), lteU128(): Checks if one 128-bit number is less than or equal to another.
 *   - gt(), gtU128(): Checks if one 128-bit number is greater than another.
 *   - gte(), gteU128(): Checks if one 128-bit number is greater than or equal to another.
 * - Arithmetic:
 *   - add(), addU128(): Adds two 128-bit numbers, returning a U256 sum.
 *   - addChecked(), addCheckedU128(): Adds two 128-bit numbers, checking for overflow for Uint<128>.
 *   - sub(), subU128(): Subtracts one 128-bit number from another, checking for underflow.
 *   - mul(), mulU128(): Multiplies two 128-bit numbers, returning a U256 product.
 *   - mulChecked(), mulCheckedU128(): Multiplies two 128-bit numbers, checking for overflow for Uint<128>.
 * - Division:
 *   - div(), divU128(): Computes the quotient of dividing one 128-bit number by another.
 *   - rem(), remU128(): Computes the remainder of dividing one 128-bit number by another.
 * - Square Root:
 *   - sqrt(), sqrtU128(): Computes the floor of the square root of a 128-bit number.
 * - Utility:
 *   - min(), minU128(): Returns the smaller of two 128-bit numbers.
 *   - max(), maxU128(): Returns the larger of two 128-bit numbers.
 *   - isMultiple(), isMultipleU128(): Checks if one 128-bit number is a multiple of another.
 */
module Uint128 {
  import CompactStandardLibrary;

  import "./interfaces/IUint128";
  import "./interfaces/IUint256";

  import Max;

  /**
   * @title Modulus U128 circuit
   * @description A pure circuit that returns the modulus value of U128 (2^64).
   *
   * @circuitInfo k=10, rows=451
   *
   * @returns {Uint<65>} The value 2^64 (18446744073709551616).
   */
  export pure circuit MODULUS(): Uint<65> {
    // pow() is not supported yet, so we hardcode this value.
    return 18446744073709551616; // 2^64
  }

  /**
   * @title Zero U128 circuit
   * @description A pure circuit that returns a zero U128 struct.
   *
   * @circuitInfo k=10, rows=451
   *
   * @returns {U128} A U128 struct with low and high fields set to 0.
   */
  export pure circuit ZERO_U128(): U128 {
    return U128 { low: 0, high: 0 };
  }

  /**
   * @title To U128 circuit
   * @description Converts a Uint<128> to a U128 struct.
   *
   * This circuit converts a 128-bit unsigned integer (`value`) to a U128 struct
   * (`{ low: Uint<64>, high: Uint<64> }`), where `low` holds the lower 64 bits and `high` holds the
   * upper 64 bits of `value`. The conversion is verified to ensure correctness.
   *
   * Theoretical Description:
   * The circuit splits a 128-bit unsigned integer value into two 64-bit unsigned integers,
   * value = high * 2^64 + low, where high, low are in [0, 2^64 - 1]. The result is a U128 struct
   * with low = value mod 2^64 and high = floor(value / 2^64).
   *
   * Mathematical Steps:
   * 1. Propose Low and High Parts:
   *    - Compute low = value mod 2^64, the least significant 64 bits of value.
   *    - Compute high = floor(value / 2^64), the most significant 64 bits of value.
   * 2. Verification:
   *    - Reconstruct reconstructed = high * 2^64 + low, a 128-bit unsigned integer.
   *    - Verify that reconstructed = value to ensure the conversion is correct.
   * 3. Result Construction:
   *    - Return (low, high), a U128 struct satisfying value = high * 2^64 + low.
   *
   * The circuit ensures correctness by verifying the reconstructed value matches the input, using
   * arithmetic operations within the 128-bit domain.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} value - The Uint<128> value to convert.
   *
   * @returns {U128} A U128 struct with low and high fields representing the lower and upper 64 bits.
   *
   * @throws {Error} "MathU128: conversion invalid" If the reconstructed value does not match the input.
   */
  export circuit toU128(value: Uint<128>): U128 {
    const result = divUint128Locally(value, MODULUS());
    const high = result.quotient.low;
    const low = result.remainder.low;

    // Verify that value = high * 2^64 + low
    const highShifted = (high as Uint<128>) * MODULUS(); // high * 2^64
    const reconstructed = highShifted + (low as Uint<128>); // high * 2^64 + low

    // Verify reconstruction matches value
    assert(reconstructed == value, "MathU128: conversion invalid");

    return U128 { low: low, high: high };
  }

  /**
   * @title From U128 circuit
   * @description Converts a U128 struct to a Uint<128>.
   *
   * This circuit converts a U128 struct ({ low: Uint<64>, high: Uint<64> }) to a 128-bit unsigned
   * integer by reconstructing value = high * 2^64 + low, where high and low are the upper and lower
   * 64 bits respectively.
   *
   * Theoretical Description:
   * The circuit combines two 64-bit unsigned integers (high, low) into a single 128-bit unsigned
   * integer value, where value = high * 2^64 + low. The conversion reconstructs the original value
   * by shifting high left by 64 bits and adding low.
   *
   * Mathematical Steps:
   * 1. Shift High Part:
   *    - Compute highShifted = high * 2^64, shifting high left by 64 bits.
   * 2. Combine Parts:
   *    - Compute result = highShifted + low, combining the shifted high part with low.
   * 3. Result:
   *    - Return result as a Uint<128>, satisfying result = high * 2^64 + low.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} value - The U128 struct to convert.
   *
   * @returns {Uint<128>} The 128-bit value represented by high * 2^64 + low.
   */
  export pure circuit fromU128(value: U128): Uint<128> {
    const highShifted = (value.high as Uint<128>) * MODULUS();
    const result = highShifted + (value.low as Uint<128>);
    return result as Uint<128>;
  }

  /**
   * @title Is Zero circuit
   * @description Checks if a Uint<128> value equals zero.
   * 
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The Uint<128> value to check.
   *
   * @returns {Boolean} True if a equals zero, false otherwise.
   */
  export pure circuit isZero(a: Uint<128>): Boolean {
    return a == 0;
  }

  /**
   * @title Is Zero U128 circuit
   * @description Checks if a U128 value equals zero.
   * 
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The U128 value to check.
   *
   * @returns {Boolean} True if a equals zero (a.low = a.high = 0), false otherwise.
   */
  export pure circuit isZeroU128(a: U128): Boolean {
    return a.low == 0 && a.high == 0;
  }

  /**
   * @title Equality circuit
   * @description Compares two Uint<128> values for equality.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean} True if a is equal than b, false otherwise.
   */
  export pure circuit eq(a: Uint<128>, b: Uint<128>): Boolean {
    return a == b;
  }

  /**
   * @title Equality U128 circuit
   * @description Compares two U128 values for equality.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {Boolean} True if a is equal b, false otherwise.
   */
  export pure circuit eqU128(a: U128, b: U128): Boolean {
    return a.low == b.low && a.high == b.high;
  }

  /**
   * @title Less Than circuit
   * @description Checks if one Uint<128> value is less than another.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean} True if a is less than b, false otherwise.
   */
  export pure circuit lt(a: Uint<128>, b: Uint<128>): Boolean {
    return a < b;
  }

  /**
   * @title Less Than or Equal circuit
   * @description Checks if one Uint<128> value is less than or equal to another.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean}
   */
  export pure circuit lte(a: Uint<128>, b: Uint<128>): Boolean {
    return a <= b;
  }

  /**
   * @title Less Than U128 circuit
   * @description Checks if one U128 value is less than another.
   *
   * @param a The first U128 value.
   * @param b The second U128 value.
   * @returns Boolean True if a is less than b, false otherwise.
   */
  export pure circuit ltU128(a: U128, b: U128): Boolean {
    return a.high < b.high || (a.high == b.high && a.low < b.low);
  }

  /**
   * @title Less Than or Equal U128 circuit
   * @description Checks if one U128 value is less than or equal to another.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {Boolean} True if a is less than or equal to b, false otherwise.
   */
  export pure circuit lteU128(a: U128, b: U128): Boolean {
    return ltU128(a, b) || eqU128(a, b);
  }

  /**
   * @title Greater Than circuit
   * @description Checks if one Uint<128> value is greater than another.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean} True if a is greater than b, false otherwise.
   */
  export pure circuit gt(a: Uint<128>, b: Uint<128>): Boolean {
    return a > b;
  }

  /**
   * @title Greater Than or Equal circuit
   * @description Checks if one Uint<128> value is greater than or equal to another.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean} True if a is greater than or equal to b, false otherwise.
   */
  export pure circuit gte(a: Uint<128>, b: Uint<128>): Boolean {
    return a >= b;
  }

  /**
   * @title Greater Than U128 circuit
   * @description Checks if one U128 value is greater than another.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {Boolean} True if a is greater than b, false otherwise.
   */
  export pure circuit gtU128(a: U128, b: U128): Boolean {
    return a.high > b.high || (a.high == b.high && a.low > b.low);
  }

  /**
   * @title Greater Than or Equal U128 circuit
   * @description Checks if one U128 value is greater than or equal to another.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {Boolean} True if a is greater than or equal to b, false otherwise.
   */
  export pure circuit gteU128(a: U128, b: U128): Boolean {
    return gtU128(a, b) || eqU128(a, b);
  }

  /**
   * @title Add circuit
   * @description Adds two U128 values, returning a U256.
   *
   * Theoretical Description:
   * This circuit computes the sum of two 128-bit unsigned integers, a and b, both represented as
   * U128 structs ({ low: Uint<64>, high: Uint<64> }). The result is a U256 struct
   * ({ low: U128, high: U128 }) containing the sum, where result.low holds the lower 128 bits and
   * result.high holds any carry into the upper 128 bits. The addition handles carries from the low
   * and high 64-bit parts to ensure accurate 256-bit representation of the sum.
   *
   * Mathematical Steps:
   * 1. Handle Special Cases:
   *    - If A = 0 (using MathU128_isZero), return B as a U256 with high part {0, 0}.
   *    - Else if B = 0 (using MathU128_isZero), return A as a U256 with high part {0, 0}.
   *    - Else if A = 2^128 - 1 (a.low = a.high = MAX_U64) and B = 1 (b.low = 1, b.high = 0),
   *      return { low: {0, 0}, high: {1, 0} } (2^128).
   * 2. Low Part Addition:
   *    - Compute lowSumFull = a.low + b.low, where lowSumFull is in [0, 2^65 - 2].
   * 3. Low Part Decomposition:
   *    - Convert lowSumFull to U128: lowSumFullU128 = toU128(lowSumFull).
   *    - Extract carry = lowSumFullU128.high (0 or 1, bit 64).
   * 4. High Part Addition with Carry:
   *    - Compute highSumIntermediate = a.high + b.high, where highSumIntermediate is in [0, 2^65 - 2].
   *    - Compute highSumFull = highSumIntermediate + carry, where highSumFull is in [0, 2^65 - 1].
   *    - Convert highSumFull to U128: highSumFullU128 = toU128(highSumFull).
   *    - Extract carryHigh = highSumFullU128.high (0 or 1, bit 128).
   * 5. Result Construction:
   *    - Define result.low = { low: lowSumFullU128.low, high: highSumFullU128.low } (bits 0-127).
   *    - Define result.high = { low: carryHigh, high: 0 } (bit 128 and above).
   *    - Return U256 { low: result.low, high: result.high }.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The first U128 value to add.
   * @param {U128} b - The second U128 value to add.
   *
   * @returns {U256} The sum of a and b as a U256 struct, with low (bits 0-127) and high (bits 128-255) parts.
   */
  circuit _add(a: U128, b: U128): U256 {
    if (isZeroU128(a)) {
       // Special case: a = 0, return b
       return U256 { low: b, high: ZERO_U128() };
    }
    else
       if (isZeroU128(b)) {
          // Special case: b = 0, return a
          return U256 { low: a, high: ZERO_U128() };
       }
       else {
          // General case
          const lowSumFull = a.low + b.low;
          const lowSumFullU128 = toU128(lowSumFull);
          const carry = lowSumFullU128.high;
          const highSumIntermediate = a.high + b.high;
          const highSumFull = highSumIntermediate + carry;
          const highSumFullU128 = toU128(highSumFull);
          const carryHigh = highSumFullU128.high;

          return U256 { low: U128 { low: lowSumFullU128.low, high: highSumFullU128.low },
                        high: U128 { low: carryHigh, high: 0 } };
       }
  }

  /**
   * @title Add circuit
   * @description Adds two Uint<128> values.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {U256} The sum of a and b.
   */
  export circuit add(a: Uint<128>, b: Uint<128>): U256 {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return _add(aU128, bU128);
  }

  /**
   * @title Add U128 circuit
   * @description Adds two U128 values.
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `U128` structs.
   * - Result is returned as `U256` to handle potential overflow.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {U256} The sum of a and b.
   */
  export circuit addU128(a: U128, b: U128): U256 {
    return _add(a, b);
  }

  /**
   * @title Add Checked circuit
   * @description Adds two Uint<128> values with overflow checking.
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Uint<128>` values.
   * - Result must not overflow 128 bits.
   *
   * @circuitInfo k=10, rows=575
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @throws {Error} "MathU128: addition overflow" if the result would overflow 128 bits.
   *
   * @returns {Uint<128>} The sum of a and b.
   */
  export circuit addChecked(a: Uint<128>, b: Uint<128>): Uint<128> {
    return (a + b) as Uint<128>;
  }

  /**
   * @title Add Checked U128 circuit
   * @description Adds two U128 values with overflow checking.
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `U128` structs.
   * - Result must not overflow 128 bits.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @throws {Error} "MathU128: addition overflow" if the result would overflow 128 bits.
   *
   * @returns {Uint<128>} The sum of a and b.
   */
  export circuit addCheckedU128(a: U128, b: U128): Uint<128> {
    return (fromU128(a) + fromU128(b)) as Uint<128>;
  }

  /**
   * @title Subtract circuit
   * @description Subtracts one Uint<128> value from another.
   *
   * @remarks
   * Requirements:
   * - `a` must be greater than or equal to `b` to prevent underflow.
   * - Both inputs must be valid `Uint<128>` values.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The Uint<128> value to subtract from (minuend).
   * @param {Uint<128>} b - The Uint<128> value to subtract (subtrahend).
   *
   * @returns {Uint<128>} The difference between a and b.
   *
   * @throws {Error} "MathU128: subtraction underflow" If a < b.
   */
  export pure circuit sub(a: Uint<128>, b: Uint<128>): Uint<128> {
    assert(a >= b, "MathU128: subtraction underflow");
    return a - b;
  }

  /**
   * @title Subtract U128 circuit
   * @description Subtracts one U128 value from another.
   *
   * Theoretical Description:
   * This circuit computes the difference between two 128-bit unsigned integers, a and b, both
   * represented as U128 structs ({ low: Uint<64>, high: Uint<64> }). The result is a U128 struct
   * representing a - b. It checks for underflow to ensure a >= b, throwing an error if the result
   * would be negative.
   *
   * Mathematical Steps:
   * 1. Handle Special Cases:
   *    - If B = 0 (using MathU128_isZero), return A (A - 0 = A).
   *    - Else if A = B (using MathU128_eqU128), return { low: 0, high: 0 } (A - A = 0).
   *    - Else if A = 2^128 - 1 (a.low = a.high = MAX_U64) and B = 1 (b.low = 1, b.high = 0),
   *      return { low: MAX_U64 - 1, high: MAX_U64 } (2^128 - 2).
   * 2. Underflow Verification:
   *    - Assert A >= B using _gt or _eq (i.e., not A < B).
   *    - If A < B, throw "MathU128: subtraction underflow".
   * 3. Borrow Determination:
   *    - Compute borrow = 1 if a.low < b.low, else 0.
   * 4. High Part Subtraction:
   *    - Compute highWithBorrow = b.high + borrow, where highWithBorrow is in [0, 2^64].
   *    - Compute highDiff = a.high - highWithBorrow, where highDiff is in [0, 2^64 - 1].
   * 5. Low Part Subtraction:
   *    - If borrow = 0 (a.low >= b.low), compute lowDiff = a.low - b.low.
   *    - If borrow = 1 (a.low < b.low), compute lowDiff = a.low + 2^64 - b.low.
   * 6. Result Construction:
   *    - Return U128 { low: lowDiff, high: highDiff }.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The U128 value to subtract from (minuend).
   * @param {U128} b - The U128 value to subtract (subtrahend).
   *
   * @throws {Error} "MathU128: subtraction underflow" If a < b.
   *
   * @returns {U128} The difference a - b as a U128 struct.
   */
  export pure circuit subU128(a: U128, b: U128): U128 {
    if (isZeroU128(b)) {
       // Special case: b = 0, return a
       return a;
    } else
       if (eqU128(a, b)) {
          // Special case: a = b, return 0
          return ZERO_U128();
       } else {
          // General case
          assert(gtU128(a, b) || eqU128(a, b), "MathU128: subtraction underflow");

          const borrow = a.low < b.low ? 1 as Uint<64> : 0 as Uint<64>;
          const highWithBorrow = b.high + borrow;
          const highDiff = a.high - highWithBorrow;

          if (borrow == 0) {
             const lowDiff = a.low - b.low;
             return U128 { low: lowDiff, high: highDiff };
          } else {
             const lowDiff = a.low + MODULUS() - b.low;
             return U128 { low: lowDiff as Uint<64>, high: highDiff };
          }
       }
  }

  /**
   * @title Multiply circuit
   * @description Multiplies two U128 values, returning the full 256-bit result.
   *
   * Theoretical Description:
   * This circuit computes the product of two 128-bit unsigned integers, a and b, both represented as
   * U128 structs ({ low: Uint<64>, high: Uint<64> }). The result is a U256 struct
   * ({ low: U128, high: U128 }) containing the full 256-bit product, where result.low holds bits 0-127
   * and result.high holds bits 128-255. The multiplication uses a schoolbook method with partial products
   * and carry propagation, optimized with special cases for common inputs.
   *
   * Mathematical Steps:
   * 1. Handle Special Cases:
   *    - If A = 0 or B = 0 (using MathU128_isZero), return ZERO_U256 (A * 0 = 0).
   *    - Else if A = 1 (a.low = 1, a.high = 0), return B as a U256 with high part {0, 0} (1 * B = B).
   *    - Else if B = 1 (b.low = 1, b.high = 0), return A as a U256 with high part {0, 0} (A * 1 = A).
   *    - Else if A = 2^128 - 1 (a.low = a.high = MAX_U64) and B = 2 (b.low = 2, b.high = 0),
   *      return { low: {MAX_U64 - 1, MAX_U64}, high: {1, 0} } (2^129 - 2).
   * 2. Partial Product Computation:
   *    - Compute four partial products as 128-bit integers:
   *      ll = a.low * b.low (bits 0-127)
   *      hl = a.high * b.low (bits 64-191)
   *      lh = a.low * b.high (bits 64-191)
   *      hh = a.high * b.high (bits 128-255)
   * 3. Partial Product Conversion:
   *    - Convert each to U128: llU128, hlU128, lhU128, hhU128.
   * 4. Middle Term Summation:
   *    - Compute crossSum = hlU128 + lhU128 using _add, resulting in a U256 covering bits 64-319.
   * 5. Low Part Alignment and Addition:
   *    - Define crossShifted = { low: 0, high: crossSum.low.low } (bits 64-127).
   *    - Compute lowAndCross = llU128 + crossShifted using _add, covering bits 0-255.
   * 6. Carry Propagation:
   *    - Define crossCarry = { low: crossSum.low.high, high: crossSum.high.low } (bits 128-255).
   *    - Compute highPartU256 = hhU128 + crossCarry using _add, covering bits 128-383.
   * 7. High Part Combination:
   *    - Compute finalHigh = lowAndCross.high + highPartU256.low using _add, covering bits 128-255.
   * 8. Result Construction:
   *    - Return U256 { low: lowAndCross.low, high: finalHigh.low }.
   *
   * @circuitInfo k=11, rows=1750
   *
   * @param {U128} a - The first U128 value to multiply.
   * @param {U128} b - The second U128 value to multiply.
   *
   * @returns {U256} The product a * b as a U256 struct.
   */
  circuit _mul(a: U128, b: U128): U256 {
    if (isZeroU128(a) || isZeroU128(b)) {
       // Special case: a = 0 or b = 0, return 0
       return U256 { low: U128 { low: 0, high: 0 }, high: U128 { low: 0, high: 0 } };
    }
    else
       if (eqU128(a, U128 { low: 1, high: 0 })) {
          // Special case: a = 1, return b
          return U256 { low: b, high: U128 { low: 0, high: 0 } };
       }
       else
          if (eqU128(b, U128 { low: 1, high: 0 })) {
             // Special case: b = 1, return a
             return U256 { low: a, high: U128 { low: 0, high: 0 } };
          }
          else {
             // Compute partial products (each is Uint<128>)
             const ll = a.low * b.low; // Bits 0-127
             const hl = a.high * b.low; // Bits 64-191
             const lh = a.low * b.high; // Bits 64-191
             const hh = a.high * b.high; // Bits 128-255

             // Convert partial products to U128 structs
             const llU128 = toU128(ll);
             const hlU128 = toU128(hl);
             const lhU128 = toU128(lh);
             const hhU128 = toU128(hh);

             // Combine hl and lh (bits 64-191) using _add, which returns a U256
             const crossSum = _add(hlU128, lhU128); // U256 { low: bits 64-191, high: bits 192-319 }

             // Extract bits 64-127 (crossSum.low.low) for crossShifted
             const crossShifted = U128 { low: 0 as Uint<64>, high: crossSum.low.low }; // Bits 64-127

             // Add crossShifted to ll to get bits 0-127 of the final result
             const lowAndCross = _add(llU128, crossShifted); // U256 { low: bits 0-127, high: bits 128-255 }

             // Extract the carry from crossSum (bits 128-191 are in crossSum.low.high, bits 192-255 in crossSum.high.low)
             const crossCarry = U128 { low: crossSum.low.high, high: crossSum.high.low }; // Bits 128-191, 192-255

             // Add crossCarry to hh to form the high part (bits 128-255)
             const highPartU256 = _add(hhU128, crossCarry); // U256 { low: bits 128-255, high: bits 256-383 }

             // Construct the final U256 result
             // lowAndCross.low contains bits 0-127
             // lowAndCross.high contains bits 128-255 (first part of the high bits)
             // highPartU256.low contains bits 128-255 (second part, needs to be combined)
             // highPartU256.high contains bits 256-383 (should be 0, as the product fits in 256 bits)
             const finalLow = lowAndCross.low; // Bits 0-127
             const finalHigh = _add(lowAndCross.high, highPartU256.low); // Combine bits 128-255

             return U256 { low: finalLow, // Bits 0-127
                           high: finalHigh.low // Bits 128-255
                           };
          }
  }

  /**
   * @title Multiply Checked U128 circuit
   * @description Internal implementation of checked multiplication for U128 values.
   *
   * @circuitInfo k=11, rows=1752
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @throws {Error} "MathU128: multiplication overflow" If the result would overflow 128 bits.
   *
   * @returns {U128} The product of a and b.
   */
  circuit _mulChecked(a: U128, b: U128): U128 {
    const result = _mul(a, b);
    assert(eqU128(result.high, ZERO_U128()), "MathU128: multiplication overflow");
    return result.low;
  }

  /**
   * @title Multiply circuit
   * @description Multiplies two Uint<128> values.
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Uint<128>` values.
   * - Result is returned as `U256` to handle full product.
   *
   * @circuitInfo k=11, rows=1874
   *
   * @param {Uint<128>} a - The first Uint<128> value to multiply.
   * @param {Uint<128>} b - The second Uint<128> value to multiply.
   *
   * @returns {U256} The full product of a and b.
   */
  export circuit mul(a: Uint<128>, b: Uint<128>): U256 {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return _mul(aU128, bU128);
  }

  /**
   * @title Multiply U128 circuit
   * @description Multiplies two U128 values.
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `U128` structs.
   * - Result is returned as `U256` to handle full product.
   *
   * @circuitInfo k=11, rows=1750
   *
   * @param {U128} a - The first U128 value to multiply.
   * @param {U128} b - The second U128 value to multiply.
   *
   * @returns {U256} The full product of a and b.
   */
  export circuit mulU128(a: U128, b: U128): U256 {
    return _mul(a, b);
  }

  /**
   * @title Multiply Checked circuit
   * @description Multiplies two Uint<128> values with overflow checking.
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Uint<128>` values.
   * - Result must not overflow 128 bits.
   *
   * @circuitInfo k=11, rows=1876
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @throws {Error} "MathU128: multiplication overflow" if the result would overflow 128 bits.
   *
   * @returns {Uint<128>} The product of a and b.
   */
  export circuit mulChecked(a: Uint<128>, b: Uint<128>): Uint<128> {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return (fromU128(_mulChecked(aU128, bU128)) as Uint<128>);
  }

  /**
   * @title Multiply Checked U128 circuit
   * @description Multiplies two U128 values with overflow checking.
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `U128` structs.
   * - Result must not overflow 128 bits.
   *
   * @circuitInfo k=11, rows=1752
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @throws {Error} "MathU128: multiplication overflow" if the result would overflow 128 bits.
   *
   * @returns {Uint<128>} The product of a and b.
   */
  export circuit mulCheckedU128(a: U128, b: U128): Uint<128> {
    return (fromU128(_mulChecked(a, b)) as Uint<128>);
  }

  /**
  * @description Divides a U128 value by another, returning quotient and remainder.
  *
  * Theoretical Description:
  * This circuit computes the quotient and remainder of dividing a 128-bit unsigned integer a by
  * another b, both represented as U128 structs ({ low: Uint<64>, high: Uint<64> }). It returns a
  * DivResultU128 struct containing the quotient and remainder, satisfying a = quotient * b + remainder,
  * where 0 <= remainder < b.
  *
  * Mathematical Steps:
  * 1. Handle Special Cases:
  *    - If B = 0 (using MathU128_isZero), throw "MathU128: division by zero".
  *    - Else if A = 0 (using MathU128_isZero), return { quotient: ZERO_U128, remainder: ZERO_U128 }.
  *    - Else if B = 1 (b.low = 1, b.high = 0), return { quotient: A, remainder: ZERO_U128 }.
  *    - Else if A = B (using MathU128_eqU128), return { quotient: {low: 1, high: 0}, remainder: ZERO_U128 }.
  *    - Else if A < B (using MathU128__le), return { quotient: ZERO_U128, remainder: A }.
  * 2. Division Computation:
  *    - Compute a_uint128 = a.high * 2^64 + a.low and b_uint128 = b.high * 2^64 + b.low using fromU128.
  *    - Compute result = (quotient, remainder) using divU128Locally, where quotient = floor(a_uint128 / b_uint128)
  *      and remainder = a_uint128 mod b_uint128.
  * 3. Remainder Verification:
  *    - Assert remainder <= b using _le, ensuring remainder < b.
  * 4. Correctness Verification:
  *    - Compute productU256 = quotient * b using _mul.
  *    - Compute lowSumU256 = productU256.low + remainderU256 using _add.
  *    - Compute highSumU256 = productU256.high + lowSumU256.high using _add.
  *    - Assert highSumU256.low = highSumU256.high = 0 and lowSumU256.low = a.
  * 5. Result:
  *    - Return DivResultU128 { quotient, remainder }.
  *
  * @circuitInfo k=12, rows=2778
  *
  * @param {U128} a - The U128 value to divide (dividend).
  * @param {U128} b - The U128 value to divide by (divisor).
  *
  * @throws {Error} "MathU128: division by zero" If b is zero.
  * @throws {Error} "MathU128: remainder error" If remainder is not less than or equal to b.
  * @throws {Error} "MathU128: division invalid" If quotient * b + remainder does not equal a.
  *
  * @returns {DivResultU128} A struct containing the quotient and remainder as U128 values.
  */
  circuit _div(a: U128, b: U128): DivResultU128 {
    assert(!isZeroU128(b), "MathU128: division by zero");

    if (isZeroU128(a)) {
       // Special case: dividend is zero
       return DivResultU128 { quotient: ZERO_U128(), remainder: ZERO_U128() };
    }
    else
       if (eqU128(b, U128 { low: 1, high: 0 })) {
          // Special case: divisor is one
          return DivResultU128 { quotient: a, remainder: ZERO_U128() };
       }
       else
          if (eqU128(a, b)) {
             // Special case: dividend equals divisor
             return DivResultU128 { quotient: U128 { low: 1, high: 0 }, remainder: ZERO_U128() };
          }
          else
             if (lteU128(a, b)) {
                // Special case: dividend less than divisor
                return DivResultU128 { quotient: ZERO_U128(), remainder: a };
             }
             else {
                assert(gteU128(b, ZERO_U128()), "MathU128: division by zero");
                const result = divU128Locally(a, b);
                assert(lteU128(result.remainder, b), "MathU128: remainder error");

                // quotient * b + remainder == a
                // Compute sumU256 = productU256 + remainderU256
                const productU256 = _mul(result.quotient, b);
                const remainderU256 = U256 { low: result.remainder, high: ZERO_U128() };
                const lowSumU256 = _add(productU256.low, result.remainder);
                const highSumU256 = _add(productU256.high, lowSumU256.high); // Add carry to high part

                // Verify that sumU256.low == a and sumU256.high == 0
                assert((eqU128(highSumU256.low, ZERO_U128()) &&
                        eqU128(highSumU256.high, ZERO_U128()) &&
                        eqU128(lowSumU256.low, a)), "MathU128: division invalid");

                return result;
             }
  }

  /**
   * @title Division circuit
   * @description Divides a Uint<128> a by a Uint<128> b, returning the quotient.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=2778
   *
   * @param {Uint<128>} a - The Uint<128> value to divide.
   * @param {Uint<128>} b - The Uint<128> value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {Uint<128>} The quotient of the division.
   */
  export circuit div(a: Uint<128>, b: Uint<128>): Uint<128> {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return fromU128(_div(aU128, bU128).quotient);
  }

  /**
   * @title Division U128 circuit
   * @description Divides a U128 a by a U128 b, returning the quotient.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=2641
   *
   * @param {U128} a - The U128 value to divide.
   * @param {U128} b - The U128 value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {U128} The quotient of the division.
   */
  export circuit divU128(a: U128, b: U128): U128 {
    return _div(a, b).quotient;
  }

  /**
   * @title Remainder circuit
   * @description Computes the remainder of dividing a Uint<128> a by a Uint<128> b.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=2778
   *
   * @param {Uint<128>} a - The Uint<128> value to divide.
   * @param {Uint<128>} b - The Uint<128> value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {Uint<128>} The remainder of the division.
   */
  export circuit rem(a: Uint<128>, b: Uint<128>): Uint<128> {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return fromU128(_div(aU128, bU128).remainder);
  }

  /**
   * @title Remainder U128 circuit
   * @description Computes the remainder of dividing a U128 a by a U128 b.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=2778
   *
   * @param {U128} a - The U128 value to divide.
   * @param {U128} b - The U128 value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {U128} The remainder of the division.
   */
  export circuit remU128(a: U128, b: U128): U128 {
    return _div(a, b).remainder;
  }

  /**
   * @title Division with Remainder circuit
   * @description Divides a Uint<128> a by a Uint<128> b, returning quotient and remainder.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=2819
   *
   * @param {Uint<128>} a - The Uint<128> value to divide.
   * @param {Uint<128>} b - The Uint<128> value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {DivResultU128} A struct containing the quotient and remainder.
   */
  export circuit divRem(a: Uint<128>, b: Uint<128>): DivResultU128 {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return _div(aU128, bU128);
  }

  /**
   * @title Division with Remainder U128 circuit
   * @description Divides a U128 a by a U128 b, returning quotient and remainder.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=2695
   *
   * @param {U128} a - The U128 value to divide.
   * @param {U128} b - The U128 value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {DivResultU128} A struct containing the quotient and remainder.
   */
  export circuit divRemU128(a: U128, b: U128): DivResultU128 {
    return _div(a, b);
  }

  /**
   * @title Floor Square Root U128 circuit
   * @description Computes the floor of the square root of a U128 value.
   *
   * Theoretical Description:
   * This circuit calculates the floor of the square root R = floor(sqrt(N)) of a 128-bit unsigned integer
   * N, represented as a U128 struct ({ low: Uint<64>, high: Uint<64> }). The result is a Uint<64> value
   * R in [0, 2^64 - 1], such that R^2 <= N < (R + 1)^2. It uses a witness-based approach for the general
   * case and includes special cases for common inputs to optimize performance.
   *
   * Mathematical Steps:
   * 1. Handle Special Cases:
   *    - If N = 0 (using MathU128_isZero), return 0.
   *    - Else if N = 1 (radicand.low = 1, radicand.high = 0), return 1.
   *    - Else if N = 2 (radicand.low = 2, radicand.high = 0), return 1.
   *    - Else if N = 3 (radicand.low = 3, radicand.high = 0), return 1.
   *    - Else if N = 4 (radicand.low = 4, radicand.high = 0), return 2.
   *    - Else if N = 9 (radicand.low = 9, radicand.high = 0), return 3.
   *    - Else if N = 2^8 - 1 = 255 (radicand.low = Max_U8, radicand.high = 0), return 15.
   *    - Else if N = 2^16 - 1 = 65535 (radicand.low = Max_U16, radicand.high = 0), return 255.
   *    - Else if N = 2^32 - 1 = 4294967295 (radicand.low = Max_U32, radicand.high = 0), return 65535.
   *    - Else if N = 2^64 - 1 (radicand.low = Max_U64, radicand.high = 0), return 4294967295.
   *    - Else if N = 1000000 (radicand.low = 1000000, radicand.high = 0), return 1000.
   *    - Else if N = 2^128 - 1 (radicand.low = radicand.high = Max_U64), return Max_U64.
   * 2. General Case Computation:
   *    - Compute N_uint128 = radicand.high * 2^64 + radicand.low using fromU128.
   *    - Compute R = floor(sqrt(N_uint128)) using sqrtU128Locally, where R is in [0, 2^64 - 1].
   * 3. Root Verification:
   *    - Define rootU128 = { low: R, high: 0 }.
   *    - Compute rootSquareU256 = rootU128 * rootU128 using _mul.
   *    - Assert rootSquareU256.high = {0, 0} (no overflow beyond 128 bits).
   *    - Assert rootSquareU256.low <= radicand using !_gt.
   * 4. Next Value Verification:
   *    - Compute next = R + 1, where next is in [1, 2^64].
   *    - Define nextU128 = { low: next, high: 0 }.
   *    - Compute nextSquareU256 = nextU128 * nextU128 using _mul.
   *    - Assert nextSquareU256.high = {0, 0} (no overflow beyond 128 bits).
   *    - Assert nextSquareU256.low > radicand using _gt.
   * 5. Result:
   *    - Return R as Uint<64>.
   *
   * @remarks
   * Requirements:
   * - `radicand` must be a valid U128 value.
   * - The result R must satisfy R^2 <= radicand < (R + 1)^2.
   *
   * @circuitInfo k=12, rows=2778
   *
   * @param {U128} radicand - The U128 value to compute the square root of.
   *
   * @throws {Error} "MathU128: sqrt root^2 overflow" If R^2 overflows 128 bits.
   * @throws {Error} "MathU128: sqrt overestimate" If R^2 > radicand.
   * @throws {Error} "MathU128: sqrt next overflow" If (R + 1)^2 overflows 128 bits.
   * @throws {Error} "MathU128: sqrt underestimate" If (R + 1)^2 <= radicand.
   *
   * @returns {Uint<64>} The floor of the square root of radicand.
   */
  circuit _sqrt(radicand: U128): Uint<64> {
    if (isZeroU128(radicand)) {
       return 0 as Uint<64>;
    } else
       if (eqU128(radicand, U128 { low: 1, high: 0 })) {
          return 1 as Uint<64>;
       } else
          if (eqU128(radicand, U128 { low: 2, high: 0 })) {
             return 1 as Uint<64>;
          }
          else
             if (eqU128(radicand, U128 { low: 3, high: 0 })) {
                return 1 as Uint<64>;
             }
             else
                if (eqU128(radicand, U128 { low: 4, high: 0 })) {
                   return 2 as Uint<64>;
                }
                else
                   if (eqU128(radicand, U128 { low: 9, high: 0 })) {
                      return 3 as Uint<64>;
                   }
                   else
                      if (eqU128(radicand, U128 { low: MAX_UINT8(), high: 0 })) {
                         return 15 as Uint<64>;
                      }
                      else
                         if (eqU128(radicand, U128 { low: MAX_UINT16(), high: 0 })) {
                            return 255 as Uint<64>;
                         }
                         else
                            if (eqU128(radicand, U128 { low: MAX_UINT32(), high: 0 })) {
                               return 65535 as Uint<64>;
                            }
                            else
                               if (eqU128(radicand, U128 { low: MAX_UINT64(), high: 0 })) {
                                  return 4294967295 as Uint<64>;
                               }
                               else
                                  if (eqU128(radicand, MAX_U128())) {
                                     return MAX_UINT64();
                                  }
                                  else {
                                     const root = sqrtU128Locally(radicand);
                                     const rootU128 = U128 { low: root, high: 0 };
                                     const rootSquareU256 = _mul(rootU128, rootU128); // U256 { low: U128, high: U128 }
                                     assert(eqU128(rootSquareU256.high, ZERO_U128()), "MathU128: sqrt root^2 overflow");

                                     const rootSquareU128 = rootSquareU256.low; // U128
                                     assert(!gtU128(rootSquareU128, radicand), "MathU128: sqrt overestimate");

                                     const next = root + 1 as Uint<64>;
                                     const nextU128 = U128 { low: next, high: 0 };
                                     const nextSquareU256 = _mul(nextU128, nextU128); // U256 { low: U128, high: U128 }
                                     assert(eqU128(nextSquareU256.high, ZERO_U128()), "MathU128: next sqrt overflow");

                                     const nextSquareU128 = nextSquareU256.low; // U128
                                     assert(gtU128(nextSquareU128, radicand), "MathU128: sqrt underestimate");
                                     return root;
                                  }
  }

  /**
   * @title Square Root circuit
   * @description Computes the square root of a Uint<128> value.
   * 
   * @remarks
   * Requirements:
   * - `radicand` must be a valid `Uint<128>` value.
   * - Uses internal `_sqrt` circuit for computation.
   *
   * @circuitInfo k=12, rows=2778
   *
   * @param {Uint<128>} radicand - The Uint<128> value to compute the square root of.
   *
   * @throws {Error} "MathU128: sqrt root^2 overflow" if root^2 overflows.
   * @throws {Error} "MathU128: sqrt overestimate" if root^2 > radicand.
   * @throws {Error} "MathU128: sqrt next overflow" if (root + 1)^2 overflows.
   * @throws {Error} "MathU128: sqrt underestimate" if (root + 1)^2 <= radicand.
   *
   * @returns {Uint<64>} The floor of the square root of radicand.
   */
  export circuit sqrt(radicand: Uint<128>): Uint<64> {
    const radicandU128 = toU128(radicand);
    return _sqrt(radicandU128);
  }

  /**
   * @title Square Root U128 circuit
   * @description Computes the square root of a U128 value.
   * 
   * @remarks
   * Requirements:
   * - `radicand` must be a valid `U128` struct.
   * - Uses internal `_sqrt` circuit for computation.
   *
   * @circuitInfo k=12, rows=2778
   *
   * @param {U128} radicand - The U128 value to compute the square root of.
   *
   * @throws {Error} "MathU128: sqrt root^2 overflow" if root^2 overflows.
   * @throws {Error} "MathU128: sqrt overestimate" if root^2 > radicand.
   * @throws {Error} "MathU128: sqrt next overflow" if (root + 1)^2 overflows.
   * @throws {Error} "MathU128: sqrt underestimate" if (root + 1)^2 <= radicand.
   *
   * @returns {Uint<64>} The floor of the square root of radicand.
   */
  export circuit sqrtU128(radicand: U128): Uint<64> {
    return _sqrt(radicand);
  }

  /**
   * @title Min circuit
   * @description Returns the minimum of two Uint<128> values.
   *
   * @circuitInfo k=12, rows=2759
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Uint<128>} The smaller of a and b.
   */
  export pure circuit min(a: Uint<128>, b: Uint<128>): Uint<128> {
    return lte(a, b) ? a : b;
  }

  /**
   * @title Min U128 circuit
   * @description Returns the minimum of two U128 values.
   *
   * @circuitInfo k=12, rows=2759
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {U128} The smaller of a and b.
   */
  export pure circuit minU128(a: U128, b: U128): U128 {
    return lteU128(a, b) ? a : b;
  }

  /**
   * @title Max circuit
   * @description Returns the maximum of two Uint<128> values.
   *
   * @circuitInfo k=12, rows=2759
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Uint<128>} The larger of a and b.
   */
  export pure circuit max(a: Uint<128>, b: Uint<128>): Uint<128> {
    return gte(a, b) ? a : b;
  }

  /**
   * @title Max U128 circuit
   * @description Returns the maximum of two U128 values.
   *
   * @circuitInfo k=12, rows=2759
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {U128} The larger of a and b.
   */
  export pure circuit maxU128(a: U128, b: U128): U128 {
    return gteU128(a, b) ? a : b;
  }

  /**
   * @title Is Multiple circuit
   * @description Checks if a U128 value is a multiple of another.
   *
   * This circuit determines whether a 128-bit unsigned integer (`a`) is a multiple of another
   * 128-bit unsigned integer (`b`), both represented as U128 structs
   * (`{ low: Uint<64>, high: Uint<64> }`). It returns a Boolean indicating whether `a` is divisible
   * by `b` with no remainder (i.e., `a mod b = 0`).
   *
   * Theoretical Description:
   * The circuit checks if a 128-bit unsigned integer a, represented as
   * a = a.high * 2^64 + a.low, is a multiple of another 128-bit unsigned integer b,
   * represented as b = b.high * 2^64 + b.low, where a.high, a.low, b.high, and b.low are in
   * [0, 2^64 - 1]. The result is true if there exists an integer k such that a = k * b,
   * equivalent to a mod b = 0, and false otherwise.
   *
   * Mathematical Steps:
   * 1. Division by Zero Check:
   *    - Verify that b != 0, i.e., b.high > 0 or b.low > 0.
   *    - If b = 0, terminate with an error indicating division by zero.
   * 2. Division Computation:
   *    - Compute the quotient and remainder of a divided by b:
   *      - Let result = (quotient, remainder) such that a = quotient * b + remainder,
   *        where quotient and remainder are 128-bit unsigned integers, and
   *        0 <= remainder < b.
   *      - Here, quotient = floor(a / b) and remainder = a mod b.
   * 3. Remainder Check:
   *    - Represent remainder as remainder = remainder.high * 2^64 + remainder.low, where
   *      remainder.high, remainder.low are in [0, 2^64 - 1].
   *    - Verify that remainder = 0, i.e., remainder.high = 0 and remainder.low = 0.
   * 4. Result:
   *    - Return true if remainder = 0, indicating a is a multiple of b (a mod b = 0).
   *    - Return false otherwise, indicating a is not a multiple of b.
   *
   * The circuit ensures correctness by computing the remainder of a divided by b and checking
   * if it is zero, using division and comparison operations, while preventing division by zero.

   * @circuitInfo k=12, rows=2759
   *
   * @param {U128} a - The U128 value to check.
   * @param {U128} b - The U128 value to test against.
   *
   * @returns {Boolean} True if a is a multiple of b, false otherwise.
   */
  circuit _isMultiple(a: U128, b: U128): Boolean {
    assert(b.high > 0 || b.low > 0, "MathU128: division by zero");
    const result = _div(a, b);
    return eqU128(result.remainder, ZERO_U128());
  }

  /**
   * @title Is Multiple circuit
   * @description Checks if a Uint<128> value is a multiple of another.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_isMultiple` circuit for computation.
   *
   * @circuitInfo k=12, rows=2759
   *
   * @param {Uint<128>} a - The Uint<128> value to check.
   * @param {Uint<128>} b - The Uint<128> b to test against.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   *
   * @returns {Boolean} True if value is a multiple of b, false otherwise.
   */
  export circuit isMultiple(a: Uint<128>, b: Uint<128>): Boolean {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return _isMultiple(aU128, bU128);
  }

  /**
   * @title Is Multiple U128 circuit
   * @description Checks if a U128 value is a multiple of another.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_isMultiple` circuit for computation.
   *
   * @circuitInfo k=12, rows=2635
   *
   * @param {U128} a - The U128 value to check.
   * @param {U128} b - The U128 b to test against.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   *
   * @returns {Boolean} True if value is a multiple of b, false otherwise.
   */
  export circuit isMultipleU128(a: U128, b: U128): Boolean {
    return _isMultiple(a, b);
  }
}

</Uint128.compact>

<Uint256.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/Uint256.compact)

pragma language_version >= 0.18.0;

/**
 * @title Uint256
 * @dev A utility module providing mathematical operations for 256-bit unsigned integers
 * using the U256 struct, which represents numbers as high * 2^128 + low, where high and low are
 * 128-bit unsigned integers (Uint<128>) in [0, 2^128 - 1]. The module supports a range of
 * operations including comparisons, arithmetic, division, square root, and utility functions.
 * All operations work directly with U256 struct inputs.
 *
 * Supported Mathematical Operations:
 * - Comparisons:
 *   - eq(): Checks if two 256-bit numbers are equal.
 *   - lt(): Checks if one 256-bit number is less than another.
 *   - lte(): Checks if one 256-bit number is less than or equal to another.
 *   - gt(): Checks if one 256-bit number is greater than another.
 *   - gte(): Checks if one 256-bit number is greater than or equal to another.
 * - Arithmetic:
 *   - add(): Adds two 256-bit numbers, checking for overflow.
 *   - sub(): Subtracts one 256-bit number from another, checking for underflow.
 *   - mul(): Multiplies two 256-bit numbers, checking for overflow.
 * - Division:
 *   - div(): Computes the quotient of dividing one 256-bit number by another.
 *   - rem(): Computes the remainder of dividing one 256-bit number by another.
 *   - divRem(): Computes both quotient and remainder of dividing one 256-bit number by another.
 * - Square Root:
 *   - sqrt(): Computes the floor of the square root of a 256-bit number, with special cases
 *     for efficiency.
 * - Utility:
 *   - MODULUS(): Returns the modulus value for U256 high part (2^128).
 *   - MODULUS_U256(): Returns a U256 struct representing the modulus value for U256 high part (2^128).
 *   - ZERO_U256(): Returns a U256 struct representing zero.
 *   - min(): Returns the smaller of two 256-bit numbers.
 *   - max(): Returns the larger of two 256-bit numbers.
 *   - isMultiple(): Checks if one 256-bit number is a multiple of another.
 *   - isZero(): Checks if a U256 value equals zero.
 *   - isLowestLimbOnly(): Checks if a U256 value has a specific value in its lowest limb and zeros elsewhere.
 *   - isSecondLowestLimbOnly(): Checks if a U256 value has a specific value in its second lowest limb and zeros elsewhere.
 *   - isThirdLowestLimbOnly(): Checks if a U256 value has a specific value in its third lowest limb and zeros elsewhere.
 *   - isHighestLimbOnly(): Checks if a U256 value has a specific value in its highest limb and zeros elsewhere.
 *   - isExceedingFieldSize(): Checks if a U256 value exceeds the field size (2^254 - 1).
 *
 * TODO: Future Operations:
 * - pow(), powU256(): Compute the power of a 256-bit number raised to a given exponent.
 * - fromU256(), toU256(): Conversion to and from Uint<256> is not currently implemented, 
 *   as it requires native support for the Uint<256> type. 
 */
module Uint256 {
  import CompactStandardLibrary;

  import "./interfaces/IUint128";
  import "./interfaces/IUint256";

  import Max;

  import Uint128 prefix Uint128_;

  /**
   * @title MODULUS circuit
   * @description A pure circuit that returns the modulus value for U256 high part (2^128).
   *
   * @circuitInfo k=10, rows=128
   *
   * @returns {Uint<129>} The value 2^128 (340282366920938463463374607431768211456).
   */
  export pure circuit MODULUS(): Uint<129> {
    return 340282366920938463463374607431768211456; // 2^128
  }

  /**
   * @title MODULUS_U256 circuit
   * @description A pure circuit that returns the modulus value for U256 high part (2^128) as a U256 struct.
   *
   * @circuitInfo k=10, rows=128
   *
   * @returns {U256} The value 2^128 as a U256 struct { low: {0, 0}, high: {1, 0} }.
   */
  export pure circuit MODULUS_U256(): U256 {
    return U256 { low: U128 { low: 0, high: 0 }, high: U128 { low: 1, high: 0 } }; // 2^128
  }

  /**
   * @title ZERO_U256 circuit
   * @description Returns a U256 struct representing zero.
   *
   * @remarks
   * This circuit returns a U256 struct with all fields set to zero:
   * {low: {0, 0}, high: {0, 0}}, representing the 256-bit value 0.
   * No computations are performed, only struct construction.
   *
   * @circuitInfo k=10, rows=128
   *
   * @returns {U256} A U256 struct representing 0.
   */
  export circuit ZERO_U256(): U256 {
    return U256 { low: U128 { low: 0, high: 0 }, high: U128 { low: 0, high: 0 } };
  }

  /**
   * @title fromU256 circuit
   * @description Converts a U256 struct to a Uint<254>, checking if the value fits within 254 bits.
   *
   * @remark
   * Theoretical Description:
   * This circuit converts a U256 struct to a 254-bit unsigned integer, ensuring the value
   * doesn't exceed 254 bits. The U256 value is reconstructed as value = high * 2^128 + low
   * and validated against the 254-bit limit.
   *
   * Mathematical Steps:
   * 1. Reconstruct U256 Value:
   *    - Convert high U128 to Uint<128> using Uint128_fromU128.
   *    - Convert low U128 to Uint<128> using Uint128_fromU128.
   *    - Compute value = high * 2^128 + low.
   * 2. 254-bit Validation:
   *    - Check if value < 2^254 (254-bit limit).
   *    - If value >= 2^254, throw "MathU256: value exceeds 254 bits".
   * 3. Convert to Uint<254>:
   *    - Cast the validated value to Uint<254>.
   * 4. Return Result:
   *    - Return the 254-bit unsigned integer.
   *
   * @circuitInfo k=10, rows=816
   *
   * @param {U256} a - The U256 struct to convert.
   *
   * @throws {Error} "MathU256: fromU256() - value exceeds 254 bits" If the U256 value is >= 2^254.
   *
   * @returns {Uint<254>} The 254-bit representation of the U256 value.
   */
  export circuit fromU256(a: U256): Uint<254> {
    assert(!isExceedingFieldSize(a), "MathU256: fromU256() - value exceeds 254 bits");

    // Compute highShifted = valueU256.high * 2^128 as a U256 struct
    const highShiftedU256 = U256 { low: U128 { low: 0, high: 0 }, high: a.high }; // Equivalent to value.high * 2^128
    // Represent valueU256.low as a U256 struct
    const lowU256 = U256 { low: a.low, high: U128 { low: 0, high: 0 } };
    // Add using addU256 to get the combined result
    const resultU256 = add(highShiftedU256, lowU256);

    // Extract the actual values from U128 structs
    const highValue = Uint128_fromU128(resultU256.high);
    const lowValue = Uint128_fromU128(resultU256.low);

    // Combine high and low parts: high * 2^128 + low, with explicit casts
    const highField = highValue as Field;
    const modulusField = MODULUS() as Field;
    const lowField = lowValue as Field;
    const result = highField * modulusField + lowField;

    return result as Uint<254>;
  }

  /**
   * @title toU256 circuit
   * @description Converts a Uint<254> to a U256 struct.
   *
   * @remarks
   * Splits the 254-bit integer into two 128-bit halves and packs them into
   * the U256 struct, then verifies lossless conversion.
   * 
   * @circuitInfo k=10, rows=739
   *
   * @param {Uint<254>} a - The 254-bit unsigned integer to convert.
   *
   * @returns {U256} The U256 struct representation.
   */
  export circuit toU256(a: Uint<254>): U256 {
    // split into high and low 128-bit parts
    const {quotient, remainder} = divUint254Locally(a, MODULUS());

    // extract the U128 limbs
    const lowU128 = remainder.low;
    const highU128 = quotient.low;

    // build the result struct
    const result = U256 { low: lowU128, high: highU128 };

    // reconstruct via placement + add, no 256-bit multiply
    const lowU256 = U256 { low: lowU128, high: U128 { low: 0, high: 0 } };
    const highU256 = U256 { low: U128 { low: 0, high: 0 }, high: highU128 };
    const reconstructed = add(highU256, lowU256);

    // verify we recovered the original `a` exactly
    assert(eq(reconstructed, result), "MathU256: conversion invalid");

    return result;
  }

  /**
   * @title eq circuit
   * @description Compares two U256 values to check if a == b.
   *
   * @remarks
   * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
   * B = b.high * 2^128 + b.low, where a.high, a.low, b.high, b.low are in [0, 2^128 - 1],
   * to determine if A == B. It performs a field-wise comparison of the high and low parts,
   * returning true if A == B, false otherwise. No arithmetic operations are performed,
   * only comparisons and logical operations (AND).
   *
   * The circuit checks if A == B by evaluating:
   * - A.high == B.high (using Uint128_eqU128).
   * - A.low == B.low (using Uint128_eqU128).
   * The result is true only if both conditions hold.
   *
   * @circuitInfo k=11, rows=1410
   *
   * @param {U256} a - The first U256 value.
   * @param {U256} b - The second U256 value.
   *
   * @returns {Boolean} True if a == b, false otherwise.
   */
  export circuit eq(a: U256, b: U256): Boolean {
    return Uint128_eqU128(a.high, b.high) && Uint128_eqU128(a.low, b.low);
  }

  /**
   * @title lt circuit
   * @description Compares two U256 values to check if a < b.
   *
   * @remarks
   * Theoretical Description:
   * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
   * B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
   * b.low are in [0, 2^128 - 1], to determine if A < B. It performs a lexicographical
   * comparison by checking the high parts first, then the low parts if the high parts are
   * equal, returning true if A < B, false otherwise. No arithmetic operations are performed,
   * only comparisons and logical operations (OR, AND).
   *
   * @circuitInfo k=11, rows=1495
   *
   * @param {U256} a - The first U256 value.
   * @param {U256} b - The second U256 value.
   *
   * @returns {Boolean} True if a < b, false otherwise.
   */
  export circuit lt(a: U256, b: U256): Boolean {
    return Uint128_ltU128(a.high, b.high) ||
           (Uint128_eqU128(a.high, b.high) && Uint128_ltU128(a.low, b.low));
  }

  /**
   * @title lte circuit
   * @description Compares two U256 values to check if a <= b.
   *
   * @remarks
   * Theoretical Description:
   * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
   * B = b.high * 2^128 + b.low, where a.high, a.low, b.high, b.low are in [0, 2^128 - 1],
   * to determine if A <= B. It performs a lexicographical comparison by checking the high
   * parts first, then the low parts if the high parts are equal, returning true if A <= B,
   * false otherwise.
   *
   * @circuitInfo k=11, rows=1518
   *
   * @param {U256} a - The first U256 value.
   * @param {U256} b - The second U256 value.
   *
   * @returns {Boolean} True if a <= b, false otherwise.
   */
  export circuit lte(a: U256, b: U256): Boolean {
    return lt(a, b) || eq(a, b);
  }

  /**
   * @title gt circuit
   * @description Compares two U256 values to check if a > b.
   *
   * @remarks
   * Theoretical Description:
   * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
   * B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
   * b.low are in [0, 2^128 - 1], to determine if A > B. It performs a lexicographical
   * comparison by checking the high parts first, then the low parts if the high parts are
   * equal, returning true if A > B, false otherwise. No arithmetic operations are performed,
   * only comparisons and logical operations (OR, AND).
   *
   * @circuitInfo k=11, rows=1495
   *
   * @param {U256} a - The first U256 value.
   * @param {U256} b - The second U256 value.
   *
   * @returns {Boolean} True if a > b, false otherwise.
   */
  export circuit gt(a: U256, b: U256): Boolean {
    return Uint128_gtU128(a.high, b.high) ||
           (Uint128_eqU128(a.high, b.high) && Uint128_gtU128(a.low, b.low));
  }

  /**
   * @title gte circuit
   * @description Compares two U256 values to check if a >= b.
   *
   * @remarks
   * Theoretical Description:
   * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
   * B = b.high * 2^128 + b.low, where a.high, a.low, b.high, b.low are in [0, 2^128 - 1],
   * to determine if A >= B. It performs a lexicographical comparison by checking the high
   * parts first, then the low parts if the high parts are equal, returning true if A >= B,
   * false otherwise.
   *
   * @circuitInfo k=11, rows=1518
   *
   * @param {U256} a - The first U256 value.
   * @param {U256} b - The second U256 value.
   *
   * @returns {Boolean} True if a >= b, false otherwise.
   */
  export circuit gte(a: U256, b: U256): Boolean {
    return gt(a, b) || eq(a, b);
  }

  /**
   * @title add circuit
   * @description Adds two U256 values, checking for overflow.
   *
   * @remarks
   * Theoretical Description:
   * This circuit computes the sum S = A + B of two 256-bit numbers represented as U256 structs,
   * where A = a.high * 2^128 + a.low, B = b.high * 2^128 + b.low, and
   * a.high, a.low, b.high, b.low are in [0, 2^128 - 1]. The result is a U256
   * struct {low: S mod 2^128, high: floor(S / 2^128)}.
   *
   * Mathematical Steps:
   * 1. Handle Special Cases:
   *    - If A = 0 (using isZero), return B (0 + B = B).
   *    - Else if B = 0 (using isZero), return A (A + 0 = A).
   *    - Else if A = 2^256 - 1 (using MAX_U256) and B = 1 (b.low = {1, 0}, b.high = {0, 0}),
   *      throw "MathU256: addition overflow" (2^256 - 1 + 1 = 2^256).
   * 2. Low Part Addition:
   *    - Compute lowSum = a.low + b.low using Uint128_addU128, where lowSum is in [0, 2^129 - 2].
   *    - Extract carry = floor(lowSum / 2^128) (0 or 1) and lowResult = lowSum mod 2^128.
   * 3. High Part Addition with Carry:
   *    - Compute highSum = a.high + b.high + carry using Uint128_addU128, where highSum is in [0, 2^129 - 1].
   * 4. Overflow Check:
   *    - Assert highSum <= 2^128 - 1 by checking highSum.high = {0, 0}.
   *    - If false, throw "MathU256: addition overflow".
   * 5. Construct Result:
   *    - Return U256 {low: lowResult, high: highSum.low}, representing
   *      S = highSum.low * 2^128 + lowResult.
   *
   * @circuitInfo k=12, rows=2208
   *
   * @param {U256} a - The first U256 value to add.
   * @param {U256} b - The second U256 value to add.
   *
   * @throws {Error} "MathU256: addition overflow" If the sum exceeds 2^256 - 1.
   *
   * @returns {U256} The sum of a and b.
   */
  export circuit add(a: U256, b: U256): U256 {
    assert(!(eq(a, MAX_U256()) && !isZero(b)), "MathU256: addition overflow");

    // Special case: a = 0, return b
    if (isZero(a)) {
       return b;
    } else
       if (isZero(b)) {
          return a;
       } else {
          // General case
          const lowSum = Uint128_addU128(a.low, b.low);
          const carry = lowSum.high.low; // 0 or 1
          const bHighCarrySum = Uint128_addU128(b.high, Uint128_toU128(carry));
          const highSum = Uint128_addU128(a.high, bHighCarrySum.low);
          assert(Uint128_isZeroU128(highSum.high), "MathU256: addition overflow");
          return U256 { low: lowSum.low, high: highSum.low };
       }
  }

  /**
   * @title sub circuit
   * @description Subtracts one U256 value from another, checking for underflow.
   *
   * @remarks
   * Theoretical Description:
   * This circuit computes the difference D = A - B of two 256-bit numbers represented as U256
   * structs, where A = a.high * 2^128 + a.low, B = b.high * 2^128 + b.low,
   * and a.high, a.low, b.high, b.low are in [0, 2^128 - 1]. The result is a
   * U256 struct {low: D mod 2^128, high: floor(D / 2^128)}.
   *
   * Mathematical Steps:
   * 1. Handle Special Cases:
   *    - If B = 0 (using isZero), return A (A - 0 = A).
   *    - Else if A = B (using eq), return 0 (ZERO_U256).
   * 2. Check for Underflow:
   *    - Assert A >= B using gt and eq (i.e., A > B or A == B).
   *    - If false, D < 0, throw "MathU256: subtraction underflow".
   * 3. Low Part Subtraction:
   *    - Compute borrow = 1 if a.low < b.low (using Uint128_leU128), else 0.
   *    - If borrow = 0 (a.low >= b.low), compute lowDiff = a.low - b.low using Uint128_subU128.
   *    - If borrow = 1 (a.low < b.low), set lowDiff = 2^128 - 1 (Uint128_MAX_U128) to reflect
   *      borrowing from the high part, ensuring lowDiff is in [0, 2^128 - 1].
   * 4. High Part Subtraction with Borrow:
   *    - Compute highWithBorrow = b.high + borrow using Uint128_addU128.
   *    - Compute highDiff = a.high - highWithBorrow using Uint128_subU128.
   * 5. Construct Result:
   *    - Return U256 {low: lowDiff, high: highDiff}, representing
   *      D = highDiff * 2^128 + lowDiff.
   * The underflow check ensures D >= 0, and the result is in [0, 2^256 - 1].
   *
   * @circuitInfo k=11, rows=1271
   *
   * @param {U256} a - The U256 value to subtract from (minuend).
   * @param {U256} b - The U256 value to subtract (subtrahend).
   *
   * @throws {Error} "MathU256: subtraction underflow" If a < b.
   *
   * @returns {U256} The difference between a and b.
   */
  export circuit sub(a: U256, b: U256): U256 {
    if (isZero(b)) {
       // Special case: b = 0, return a
       return a;
    } else
       if (eq(a, b)) {
          // Special case: a = b return 0
          return ZERO_U256();
       } else {
          // Check for underflow: a must be >= b
          assert(gt(a, b) || eq(a, b), "MathU256: subtraction underflow");

          // Handle low part subtraction with borrow
          const borrow = Uint128_lteU128(a.low, b.low) ? 1 : 0;
          const highWithBorrow = Uint128_addU128(b.high, Uint128_toU128(borrow)).low;
          const highDiff = Uint128_subU128(a.high, highWithBorrow);

          // TODO: check tenary operator
          if (borrow == 0) {
             const lowDiff = Uint128_subU128(a.low, b.low);
             return U256 { low: lowDiff, high: highDiff };
          } else {
             return U256 { low: MAX_U128(), high: highDiff };
          }
       }
  }

  /**
   * @title mul circuit
   * @description Multiplies two U256 values, checking for overflow.
   *
   * @remarks
   * Theoretical Description:
   * This circuit computes the product P = A * B of two 256-bit numbers represented as U256
   * structs, where A = a.high * 2^128 + a.low, B = b.high * 2^128 + b.low,
   * and a.high, a.low, b.high, b.low are in [0, 2^128 - 1]. The result is a
   * U256 struct {low: P mod 2^128, high: floor(P / 2^128)}, ensuring P <= 2^256 - 1.
   *
   * Mathematical Steps:
   * 1. Handle Special Cases:
   *    - If A = 0 or B = 0 (using isZero), return 0 (ZERO_U256).
   *    - Else if A = 1 (a.low = {1, 0}, a.high = {0, 0}), return B (1 * B = B).
   *    - Else if B = 1 (b.low = {1, 0}, b.high = {0, 0}), return A (A * 1 = A).
   * 2. Compute Partial Products:
   *    - Compute four partial products using Uint128_mulU128:
   *      ll = a.low * b.low (bits 0-255)
   *      hl = a.high * b.low (bits 128-383)
   *      lh = a.low * b.high (bits 128-383)
   *      hh = a.high * b.high (bits 256-511)
   * 3. Combine Partial Products:
   *    - Add partial products with proper bit alignment using add:
   *      - crossSum = add(hl, lh) (sum of middle terms, bits 128-383)
   *      - crossShifted = {low: 0, high: crossSum.low} (align to bits 128-255)
   *      - lowAndCross = add(ll, crossShifted) (add low and middle terms)
   *      - crossCarry = {low: crossSum.high, high: 0} (carry to bits 256-383)
   *      - hhShifted = add({low: hh.low, high: hh.high}, crossCarry)
   *      - result = add(lowAndCross, hhShifted) (final sum)
   * 4. Overflow Check:
   *    - Assert hhShifted.low = {0, 0} and hhShifted.high = {0, 0} (bits 256-511 are zero).
   *    - Assert result.high <= 2^128 - 1 or (result.high = 2^128 - 1 and result.low <= 2^128 - 1).
   *    - If either fails, throw "MathU256: multiplication overflow".
   * 5. Return Result:
   *    - Return result as a U256 struct.
   *
   * @circuitInfo k=14, rows=9249
   *
   * @param {U256} a - The first U256 value to multiply.
   * @param {U256} b - The second U256 value to multiply.
   *
   * @throws {Error} "MathU256: multiplication overflow" If the product exceeds 2^256 - 1.
   *
   * @returns {U256} The product of a and b.
   */
  export circuit mul(a: U256, b: U256): U256 {
    assert(!(eq(a, MAX_U256()) && Uint128_gtU128(b.low, U128 { low: 1, high: 0 })), "MathU256: multiplication overflow");

    if (isZero(a) || isZero(b)) {
       // Special case: a = 0 or b = 0, return 0
       return ZERO_U256();
    }
    else
       if (Uint128_isZeroU128(a.high) && a.low.high == 0 && a.low.low == 1) {
          // a = 1, return b
          return b;
       }
       else
          if (Uint128_isZeroU128(b.high) && b.low.high == 0 && b.low.low == 1) {
             // b = 1, return a
             return a;
          }
          else {
             // Compute partial products using MathU128.mulU128
             const ll = Uint128_mulU128(a.low, b.low); // Bits 0-255
             const hl = Uint128_mulU128(a.high, b.low); // Bits 128-383
             const lh = Uint128_mulU128(a.low, b.high); // Bits 128-383
             const hh = Uint128_mulU128(a.high, b.high); // Bits 256-511

             // Combine contributions
             const crossSum = add(hl, lh); // Sum of middle terms
             const crossShifted = U256 { low: Uint128_ZERO_U128(), high: crossSum.low }; // Align to bits 128-255
             const lowAndCross = add(ll, crossShifted); // Add low and middle terms
             const crossCarry = U256 { low: crossSum.high, high: Uint128_ZERO_U128() }; // Carry to bits 256-383
             const high = U256 { low: hh.low, high: hh.high };
             const hhShifted = add(high, crossCarry); // Align hh and add carry

             // Check that upper 256 bits from partial products are zero
             assert(isZero(hhShifted), "MathU256: multiplication overflow");

             return lowAndCross;
          }
  }

  /**
   * @title div circuit
   * @description Internal implementation to divide a U256 a by a U256 b, returning quotient and remainder.
   *
   * @remarks
   * Theoretical Description:
   * This circuit computes the quotient `quot` and remainder `rem` of dividing a 256-bit number
   * a = a.high * 2^128 + a.low by another 256-bit number
   * b = b.high * 2^128 + b.low, 
   * where a.high, a.low, b.high, b.low are in [0, 2^128 - 1]. The result is a DivResultU256 struct
   * containing quot and rem as U256 structs, satisfying a = quot * b + rem with 0 <= rem < b.
   *
   * Mathematical Steps:
   * 1. Handle Special Cases:
   *    - If B = 0 (using isZero), throw "MathU256: division by zero".
   *    - Else if A = 0 (using isZero), return { quotient: ZERO_U256, remainder: ZERO_U256 }.
   *    - Else if B = 1 (b.low = {1, 0}, b.high = {0, 0}), return { quotient: A, remainder: ZERO_U256 }.
   *    - Else if A = B (using eq), return { quotient: {low: {1, 0}, high: {0, 0}}, remainder: ZERO_U256 }.
   *    - Else if A < B (using le), return { quotient: ZERO_U256, remainder: A }.
   * 2. Division Computation:
   *    - Use a division witness (divU256Locally) to compute quot_U256 = floor(a / b)
   *      and rem_U256 = a mod b as U256 structs: quotientU256, remainderU256.
   * 3. Verify Remainder:
   *    - Assert remainderU256 <= b using le, ensuring rem < b.
   *    - Assert remainderU256 >= ZERO_U256(), ensuring rem >= 0.
   * 4. Verify Correctness:
   *    - Compute P = quot * b using mul.
   *    - Compute S = P + rem using add.
   *    - Assert S = A, ensuring S = a.
   *    - Assert P <= a, ensuring no overflow in intermediate calculations.
   * 5. Return Result:
   *    - Return DivResultU256 {quotient: quotientU256, remainder: remainderU256}.
   *
   * @circuitInfo k=14, rows=10912
   *
   * @param {U256} a - The U256 value to divide (dividend).
   * @param {U256} b - The U256 value to divide by (divisor).
   *
   * @throws {Error} "MathU256: division by zero" If b = 0.
   * @throws {Error} "MathU256: remainder error" If remainder is not less than or equal to b.
   * @throws {Error} "MathU256: division invalid" If quotient * b + remainder does not equal a.
   *
   * @returns {DivResultU256} The quotient and remainder of the division as U256 structs.
   */
  circuit _div(a: U256, b: U256): DivResultU256 {
    assert(!isZero(b), "MathU256: division by zero");

    if (isZero(a)) {
       // Dividend is zero: quotient = 0, remainder = 0
       return DivResultU256 { quotient: ZERO_U256(), remainder: ZERO_U256() };
    }
    else
       if (Uint128_isZeroU128(b.high) && b.low.high == 0 && b.low.low == 1) {
          // Divisor is one: quotient = a, remainder = 0
          return DivResultU256 { quotient: a, remainder: ZERO_U256() };
       }
       else
          if (eq(a, b)) {
             // Dividend equals divisor: quotient = 1, remainder = 0
             return DivResultU256 { quotient: U256 { low: U128 { low: 1, high: 0 },
                                                     high: U128 { low: 0, high: 0 } },
                                    remainder: ZERO_U256() };
          }
          else
             if (lte(a, b)) {
                // Dividend less than divisor: quotient = 0, remainder = a
                return DivResultU256 { quotient: ZERO_U256(), remainder: a };
             } else {
                const result = divU256Locally(a, b);

                // Verify remainder < b
                const remainderU256 = result.remainder;
                assert(lte(remainderU256, b), "MathU256: remainder error");

                // Verify: quotient * b + remainder == a
                const quotientU256 = result.quotient;
                const product = mul(quotientU256, b);
                const sum = add(product, remainderU256);

                assert(eq(sum, a), "MathU256: division invalid");

                return result;
             }
  }

  /**
   * @title div circuit
   * @description Divides a U256 a by a U256 b, returning quotient.
   *
   * @circuitInfo k=14, rows=10912
   *
   * @param {U256} a - The U256 value to divide.
   * @param {U256} b - The U256 value to divide by.
   *
   * @returns {U256} The quotient of the division.
   */
  export circuit div(a: U256, b: U256): U256 {
    return _div(a, b).quotient;
  }

  /**
   * @title rem circuit
   * @description Computes the remainder of dividing a U256 a by a U256 b.
   *
   * @circuitInfo k=14, rows=10912
   *
   * @param {U256} a - The U256 value to divide.
   * @param {U256} b - The U256 value to divide by.
   *
   * @returns {U256} The remainder of the division.
   */
  export circuit rem(a: U256, b: U256): U256 {
    return _div(a, b).remainder;
  }

  /**
   * @title divRem circuit
   * @description Computes the quotient and remainder of dividing a U256 a by a U256 b.
   *
   * @circuitInfo k=14, rows=11020
   *
   * @param {U256} a - The U256 value to divide.
   * @param {U256} b - The U256 value to divide by.
   *
   * @returns {DivResultU256} The quotient and remainder of the division as U256 structs.
   */
  export circuit divRem(a: U256, b: U256): DivResultU256 {
    return _div(a, b);
  }

  /**
   * @title sqrt circuit
   * @description Computes the square root of a U256 value, verified on-chain.
   *
   * @remarks
   * Theoretical Description:
   * This circuit computes the floor of the square root R = floor(sqrt(N)) of a 256-bit number
   * N = radicand.high * 2^128 + radicand.low, where radicand.high, radicand.low are in
   * [0, 2^128 - 1]. The result is a Uint<128> value R in [0, 2^128 - 1]. It uses the
   * Newton-Raphson method via a witness for the general case and includes special cases for efficiency.
   *
   * Mathematical Steps:
   * 1. Handle Special Cases:
   *    - If N = 0 (using isZero), return 0.
   *    - Else if N = 1 (radicand.low = {1, 0}, radicand.high = {0, 0}), return 1.
   *    - Else if N = 2 (radicand.low = {2, 0}, radicand.high = {0, 0}), return 1.
   *    - Else if N = 3 (radicand.low = {3, 0}, radicand.high = {0, 0}), return 1.
   *    - Else if N = 4 (radicand.low = {4, 0}, radicand.high = {0, 0}), return 2.
   *    - Else if N = 9 (radicand.low = {9, 0}, radicand.high = {0, 0}), return 3.
   *    - Else if N = 2^8 - 1 (radicand.low = Max_U8, radicand.high = {0, 0}), return 15.
   *    - Else if N = 2^16 - 1 (radicand.low = Max_U16, radicand.high = {0, 0}), return 255.
   *    - Else if N = 2^32 - 1 (radicand.low = Max_U32, radicand.high = {0, 0}), return 65535.
   *    - Else if N = 2^64 - 1 (radicand.low = Max_U64, radicand.high = {0, 0}), return 4294967295.
   *    - Else if N = 2^128 - 1 (radicand.low = Max_U128, radicand.high = {0, 0}), return 2^64 - 1.
   *    - Else if N = 2^256 - 1 (using MAX_U256), return 2^128 - 1.
   * 2. General Case:
   *    - Compute R = floor(sqrt(N)) using a Newton-Raphson witness (sqrtU256Locally).
   * 3. Verify Correctness:
   *    - Compute R^2 using Uint128_mul with R as a U256 struct {low: R, high: 0}.
   *    - Compute (R + 1)^2 with R + 1 as a U256 struct {low: R + 1, high: 0}.
   *    - Assert R^2 <= N using !gt, ensuring R^2 <= N.
   *    - Assert (R + 1)^2 > N using gt, ensuring (R + 1)^2 > N.
   * 4. Return Result:
   *    - Return R as Uint<128>.
   *
   * @circuitInfo k=14, rows=11693
   *
   * @param {U256} radicand - The U256 value to compute the square root of.
   *
   * @throws {Error} "MathU256: sqrt overestimate" If R^2 > N.
   * @throws {Error} "MathU256: sqrt underestimate" If (R + 1)^2 <= N.
   *
   * @returns {Uint<128>} The floor of the square root of radicand.
   */
  export circuit sqrt(radicand: U256): Uint<128> {
    if (isZero(radicand)) {
       return 0;
    } else
       if (isLowestLimbOnly(radicand, 1)) {
          return 1;
       } else
          if (isLowestLimbOnly(radicand, 2)) {
             return 1;
          }
          else
             if (isLowestLimbOnly(radicand, 3)) {
                return 1;
             }
             else
                if (isLowestLimbOnly(radicand, 4)) {
                   return 2;
                }
                else
                   if (isLowestLimbOnly(radicand, 9)) {
                      return 3;
                   }
                   else
                      if (isLowestLimbOnly(radicand, MAX_UINT8())) {
                         return 15;
                      }
                      else
                         if (isLowestLimbOnly(radicand, MAX_UINT16())) {
                            return MAX_UINT8();
                         }
                         else
                            if (isLowestLimbOnly(radicand, MAX_UINT32())) {
                               return MAX_UINT16();
                            }
                            else
                               if (isLowestLimbOnly(radicand, MAX_UINT64())) {
                                  return MAX_UINT32();
                               }
                               else
                                  if (Uint128_eqU128(radicand.low, MAX_U128()) &&
                                      Uint128_isZeroU128(radicand.high)) {
                                     return MAX_UINT64();
                                  }
                                  else
                                     if (eq(radicand, MAX_U256())) {
                                        return MAX_UINT128();
                                     }
                                     else {
                                        const root = sqrtU256Locally(radicand);
                                        const rootSquareU256 = Uint128_mul(root, root);
                                        assert(!gt(rootSquareU256, radicand), "MathU256: sqrt overestimate");

                                        const next = Uint128_add(root, 1);
                                        const nextSquareU256 = mul(next, next);
                                        assert(gt(nextSquareU256, radicand), "MathU256: sqrt underestimate");

                                        return root;
                                     }
  }

  /**
   * @title min circuit
   * @description Returns the minimum of two U256 values.
   *
   * @remarks
   * Theoretical Description:
   * This circuit computes the minimum of two 256-bit numbers A = a.high * 2^128 + a.low
   * and B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
   * b.low are in [0, 2^128 - 1]. It returns the smaller value as a U256 struct.
   *
   * Mathematical Steps:
   * 1. Compare Inputs:
   *    - Use le to check if A < B.
   * 2. Select Minimum:
   *    - If A < B, return a.
   *    - Otherwise, return b.
   * The operation involves comparison and conditional selection, with no arithmetic operations
   * beyond the comparison logic. The result is a U256 struct representing min(A, B).
   *
   * @circuitInfo k=12, rows=2208
   *
   * @param {U256} a - The first U256 value.
   * @param {U256} b - The second U256 value.
   *
   * @returns {U256} The smaller of a and b.
   */
  export circuit min(a: U256, b: U256): U256 {
    return lte(a, b) ? a : b;
  }

  /**
   * @title max circuit
   * @description Returns the maximum of two U256 values.
   *
   * @remarks
   * Theoretical Description:
   * This circuit computes the maximum of two 256-bit numbers A = a.high * 2^128 + a.low
   * and B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
   * b.low are in [0, 2^128 - 1]. It returns the larger value as a U256 struct.
   *
   * Mathematical Steps:
   * 1. Compare Inputs:
   *    - Use le to check if A < B.
   * 2. Select Maximum:
   *    - If A < B, return b.
   *    - Otherwise, return a.
   * The operation involves comparison and conditional selection, with no arithmetic operations
   * beyond the comparison logic. The result is a U256 struct representing max(A, B).
   *
   * @circuitInfo k=12, rows=2208
   *
   * @param {U256} a - The first U256 value.
   * @param {U256} b - The second U256 value.
   *
   * @returns {U256} The larger of a and b.
   */
  export circuit max(a: U256, b: U256): U256 {
    return lte(a, b) ? b : a;
  }

  /**
   * @title isZero circuit
   * @description Checks if a U256 value equals zero.
   *
   * @remarks
   * Theoretical Description:
   * This circuit checks if a 256-bit number A = a.high * 2^128 + a.low is zero by verifying
   * that all fields (a.high.low, a.high.high, a.low.low, a.low.high) are zero.
   * Returns true if A = 0, false otherwise. No arithmetic operations are performed,
   * only field comparisons and logical operations (AND).
   *
   * @circuitInfo k=10, rows=128
   *
   * @param {U256} a - The U256 value to check.
   *
   * @returns {Boolean} True if a equals zero, false otherwise.
   */
  export circuit isZero(a: U256): Boolean {
    return eq(a, ZERO_U256());
  }

  /**
   * @title isExceedingFieldSize circuit
   * @description Checks if a U256 value exceeds the field size (2^254 - 1).
   *
   * @remarks
   * Theoretical Description:
   * This circuit efficiently checks if a 256-bit number exceeds the maximum field value
   * (2^254 - 1) by comparing the limbs directly, avoiding expensive reconstruction and
   * multiplication operations. The field size limit is 2^254 - 1, which means the highest
   * 2 bits of the 256-bit number must be zero.
   *
   * Mathematical Steps:
   * 1. Check Highest Limb:
   *    - The highest limb (a.high.high) must be <= 4611686018427387903 (2^62 - 1).
   *    - If a.high.high > 4611686018427387903, the value exceeds field size.
   * 2. Check Other Limbs:
   *    - If a.high.high == 4611686018427387903, then a.high.low must be <= MAX_UINT64.
   *    - If a.high.high == 4611686018427387903 and a.high.low == MAX_UINT64, then
   *      a.low.high and a.low.low must be <= MAX_UINT64.
   * 3. Return Result:
   *    - Return true if the value exceeds field size, false otherwise.
   *
   * This approach is much more efficient than reconstructing the full value and comparing.
   *
   * @circuitInfo k=10, rows=128
   *
   * @param {U256} a - The U256 value to check.
   *
   * @returns {Boolean} True if a exceeds field size (2^254 - 1), false otherwise.
   */
  export circuit isExceedingFieldSize(a: U256): Boolean {
    const maxUint64 = 18446744073709551615; // 2^64 - 1
    const maxHighHigh = 4611686018427387903; // 2^62 - 1 (highest 2 bits must be 0)

    // Check if highest limb exceeds the limit
    if (a.high.high > maxHighHigh) {
      return true;
    }

    // If highest limb is at the limit, check other limbs
    if (a.high.high == maxHighHigh) {
      if (a.high.low > maxUint64) {
        return true;
      }
      if (a.high.low == maxUint64) {
        if (a.low.high > maxUint64 || a.low.low > maxUint64) {
          return true;
        }
      }
    }

    return false;
  }

  /**
   * @title isLowestLimbOnly circuit
   * @description Checks if a U256 value has a specific value in its lowest limb and zeros elsewhere.
   *
   * @circuitInfo k=10, rows=128
   *
   * @param {U256} val - The U256 value to check.
   * @param {Uint<64>} limbValue - The value to check in the lowest limb.
   *
   * @returns {Boolean} True if val has the specified value in its lowest limb and zeros elsewhere.
   */
  export circuit isLowestLimbOnly(val: U256, limbValue: Uint<64>): Boolean {
    return val.low.low == limbValue && val.low.high == 0 && val.high.low == 0 && val.high.high == 0;
  }

  /**
   * @title isSecondLimbOnly circuit
   * @description Checks if a U256 value has a specific value in its second lowest limb and zeros elsewhere.
   *
   * @circuitInfo k=10, rows=128
   *
   * @param {U256} val - The U256 value to check.
   * @param {Uint<64>} limbValue - The value to check in the second lowest limb.
   *
   * @returns {Boolean} True if val has the specified value in its second lowest limb and zeros elsewhere.
   */
  export circuit isSecondLimbOnly(val: U256, limbValue: Uint<64>): Boolean {
    return val.low.low == 0 && val.low.high == limbValue && val.high.low == 0 && val.high.high == 0;
  }

  /**
   * @title isThirdLimbOnly circuit
   * @description Checks if a U256 value has a specific value in its second highest limb and zeros elsewhere.
   *
   * @circuitInfo k=10, rows=128
   *
   * @param {U256} val - The U256 value to check.
   * @param {Uint<64>} limbValue - The value to check in the second highest limb.
   *
   * @returns {Boolean} True if val has the specified value in its second highest limb and zeros elsewhere.
   */
  export circuit isThirdLimbOnly(val: U256, limbValue: Uint<64>): Boolean {
    return val.low.low == 0 && val.low.high == 0 && val.high.low == limbValue && val.high.high == 0;
  }

  /**
   * @title isHighestLimbOnly circuit
   * @description Checks if a U256 value has a specific value in its highest limb and zeros elsewhere.
   *
   * @circuitInfo k=10, rows=128
   *
   * @param {U256} val - The U256 value to check.
   * @param {Uint<64>} limbValue - The value to check in the highest limb.
   *
   * @returns {Boolean} True if val has the specified value in its highest limb and zeros elsewhere.
   */
  export circuit isHighestLimbOnly(val: U256, limbValue: Uint<64>): Boolean {
    return val.low.low == 0 && val.low.high == 0 && val.high.low == 0 && val.high.high == limbValue;
  }

  /**
   * @title isMultiple circuit
   * @description Checks if a U256 value is a multiple of another.
   *
   * @remarks
   * Theoretical Description:
   * This circuit determines if a 256-bit number N = value.high * 2^128 + value.low is a multiple
   * of another 256-bit number M = b.high * 2^128 + b.low, where value.high,
   * value.low, b.high, b.low are in [0, 2^128 - 1]. It returns true if N is a
   * multiple of M (i.e., N mod M = 0), false otherwise.
   *
   * Mathematical Steps:
   * 1. Check for Division by Zero:
   *    - Assert M != 0 (i.e., b.high > 0 or b.low > 0).
   * 2. Compute Remainder:
   *    - Compute rem = N mod M using _div, where rem is a U256 struct.
   * 3. Check Multiplicity:
   *    - Compare rem to zero (rem.high = 0 and rem.low = 0).
   *    - Return true if rem = 0, false otherwise.
   * The operations include division, comparison, and logical checks. The result is a boolean
   * indicating whether N is a multiple of M.
   *
   * @circuitInfo k=14, rows=10897
   *
   * @param {U256} value - The U256 value to check.
   * @param {U256} b - The U256 b to test against.
   *
   * @returns {Boolean} True if value is a multiple of b, false otherwise.
   */
  export circuit isMultiple(value: U256, b: U256): Boolean {
    assert(!isZero(b), "MathU256: division by zero");
    const result = _div(value, b);
    return eq(result.remainder, ZERO_U256());
  }
}

</Uint256.compact>

<Uint64.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/Uint64.compact)

pragma language_version >= 0.18.0;

/**
 * @title Uint64
 * @dev A utility module providing mathematical operations for unsigned integers. Most functions operate on
 * `Uint<64>` values in the range [0, 2^64 - 1], while the `sqrt` function accepts a `Uint<128>` input in the range
 * [0, 2^128 - 1]. The module supports arithmetic, division, square root, and utility functions with overflow and
 * underflow checks where applicable.
 *
 * Supported Mathematical Operations:
 * - Arithmetic:
 *   - add(): Adds two `Uint<64>` numbers, returning a `Uint<128>` result to handle potential overflow.
 *   - sub(): Subtracts one `Uint<64>` number from another, checking for underflow.
 *   - mul(): Multiplies two `Uint<64>` numbers, returning a `Uint<128>` result.
 * - Division:
 *   - div(): Computes the quotient of dividing one `Uint<64>` number by another.
 *   - rem(): Computes the remainder of dividing one `Uint<64>` number by another.
 * - Square Root:
 *   - sqrt(): Computes the floor of the square root of a `Uint<128>` number using the Newton-Raphson method.
 * - Utility:
 *   - isMultiple(): Checks if one `Uint<64>` number is a multiple of another.
 *   - min(): Returns the smaller of two `Uint<64>` numbers.
 *   - max(): Returns the larger of two `Uint<64>` numbers.
 */
module Uint64 {
  import CompactStandardLibrary;

  import "./interfaces/IUint64";

  import Max prefix Max_;

  /**
   * @title Add circuit
   * @description Adds two `Uint<64>` numbers, returning a `Uint<128>` result to accommodate potential overflow.
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Uint<64>` values in range [0, 2^64 - 1].
   *
   * @circuitInfo k=10, rows=575
   *
   * @param {Uint<64>} a - The first unsigned 64-bit integer.
   * @param {Uint<64>} b - The second unsigned 64-bit integer.
   *
   * @returns {Uint<128>} The sum of `a` and `b` as a `Uint<128>` value.
   */
  export circuit add(a: Uint<64>, b: Uint<64>): Uint<128> {
    return a + b;
  }

  /**
   * @title Subtract circuit
   * @description Subtracts `b` from `a`, checking for underflow to ensure the result is non-negative.
   * 
   * @remarks
   * Requirements:
   * - `a` must be greater than or equal to `b` to prevent underflow.
   * - Both inputs must be valid `Uint<64>` values.
   *
   * @circuitInfo k=10, rows=575
   *
   * @param {Uint<64>} a - The unsigned 64-bit integer to subtract from (minuend).
   * @param {Uint<64>} b - The unsigned 64-bit integer to subtract (subtrahend).
   *
   * @throws {Error} "Math: subtraction underflow" if `b > a`.
   *
   * @returns {Uint<64>} The difference `a - b` as a `Uint<64>` value.
   */
  export circuit sub(a: Uint<64>, b: Uint<64>): Uint<64> {
    assert(a >= b, "Math: subtraction underflow");
    return a - b;
  }

  /**
   * @title Multiply circuit
   * @description Multiplies two `Uint<64>` values, returning a `Uint<128>` result to handle large products.
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Uint<64>` values.
   * - Result is returned as `Uint<128>` to handle potential overflow.
   *
   * @circuitInfo k=11, rows=1874
   *
   * @param {Uint<64>} a - The first unsigned 64-bit integer (multiplicand).
   * @param {Uint<64>} b - The second unsigned 64-bit integer (multiplier).
   *
   * @returns {Uint<128>} The product of `a` and `b` as a `Uint<128>` value.
   */
  export circuit mul(a: Uint<64>, b: Uint<64>): Uint<128> {
    return a * b;
  }

  /**
   * @title Internal Division circuit
   * @description Internal circuit to divide a Uint<64> number by another, returning quotient and remainder.
   *
   * Theoretical Description:
   * This circuit computes the quotient and remainder of dividing a 64-bit unsigned integer a by another b,
   * both represented as Uint<64> values in [0, 2^64 - 1]. It returns a DivResultU64 struct containing the
   * quotient and remainder, satisfying a = quotient * b + remainder, where 0 <= remainder < b.
   *
   * Mathematical Steps:
   * 1. Handle Special Cases:
   *    - If b = 0, throw "Math: division by zero".
   *    - Else if a = 0, return { quotient: 0, remainder: 0 }.
   *    - Else if b = 1, return { quotient: a, remainder: 0 }.
   *    - Else if a = b, return { quotient: 1, remainder: 0 }.
   *    - Else if a < b, return { quotient: 0, remainder: a }.
   * 2. Division Computation:
   *    - Compute result = (quotient, remainder) using divU64Locally, where quotient = floor(a / b)
   *      and remainder = a mod b.
   * 3. Verification:
   *    - Assert remainder < b, ensuring 0 <= remainder < b.
   *    - Assert quotient * b + remainder = a, ensuring correctness.
   * 4. Result:
   *    - Return DivResultU64 { quotient, remainder }.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - `remainder` must be less than `b`.
   * - `quotient * b + remainder` must equal `a`.
   *
   * @circuitInfo k=10, rows=277
   *
   * @param {Uint<64>} a - The Uint<64> value to divide (dividend).
   * @param {Uint<64>} b - The Uint<64> value to divide by (divisor).
   *
   * @throws {Error} "Math: division by zero" if b is zero.
   * @throws {Error} "Math: remainder error" if remainder is not less than b.
   * @throws {Error} "Math: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {DivResultU64} A struct containing the quotient and remainder as Uint<64> values.
   */
  circuit _div(a: Uint<64>, b: Uint<64>): DivResultU64 {
    assert(b != 0, "Math: division by zero");

    if (a == 0) {
       return DivResultU64 { quotient: 0 as Uint<64>, remainder: 0 as Uint<64> };
    } else
       if (b == 1) {
          return DivResultU64 { quotient: a, remainder: 0 as Uint<64> };
       }
       else
          if (a == b) {
             return DivResultU64 { quotient: 1 as Uint<64>, remainder: 0 as Uint<64> };
          }
          else
             if (a < b) {
                return DivResultU64 { quotient: 0 as Uint<64>, remainder: a };
             }
             else {
                const result = divU64Locally(a, b);
                assert(result.remainder < b, "Math: remainder error");
                assert((result.quotient * b + result.remainder) as Uint<64> == a, "Math: division invalid");
                return result;
             }
  }

  /**
   * @title Division circuit
   * @description Divides a `Uint<64>` number `a` by `b`, returning the quotient.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=10, rows=240
   *
   * @param {Uint<64>} a - The unsigned 64-bit integer to divide (dividend).
   * @param {Uint<64>} b - The unsigned 64-bit integer to divide by (divisor).
   *
   * @throws {Error} "Math: division by zero" if `b` is zero.
   * @throws {Error} "Math: remainder error" if the division result is invalid.
   * @throws {Error} "Math: division invalid" if the division result is invalid.
   *
   * @returns {Uint<64>} The quotient of `a` divided by `b` as a `Uint<64>` value.
   */
  export circuit div(a: Uint<64>, b: Uint<64>): Uint<64> {
    return _div(a, b).quotient;
  }

  /**
   * @title Remainder circuit
   * @description Computes the remainder of dividing a `Uint<64>` number `a` by `b`.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=10, rows=240
   *
   * @param {Uint<64>} a - The unsigned 64-bit integer to divide (dividend).
   * @param {Uint<64>} b - The unsigned 64-bit integer to divide by (divisor).
   *
   * @throws {Error} "Math: division by zero" if `b` is zero.
   * @throws {Error} "Math: remainder error" if the division result is invalid.
   * @throws {Error} "Math: division invalid" if the division result is invalid.
   *
   * @returns {Uint<64>} The remainder of `a` divided by `b` as a `Uint<64>` value.
   */
  export circuit rem(a: Uint<64>, b: Uint<64>): Uint<64> {
    return _div(a, b).remainder;
  }

  /**
   * @title Division with Remainder circuit
   * @description Divides a Uint<64> number by another, returning both quotient and remainder.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - `remainder` must be less than `b`.
   * - `quotient * b + remainder` must equal `a`.
   *
   * @circuitInfo k=10, rows=277
   *
   * @param {Uint<64>} a - The Uint<64> value to divide (dividend).
   * @param {Uint<64>} b - The Uint<64> value to divide by (divisor).
   *
   * @throws {Error} "Math: division by zero" if b is zero.
   * @throws {Error} "Math: remainder error" if remainder is not less than b.
   * @throws {Error} "Math: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {DivResultU64} A struct containing the quotient and remainder as Uint<64> values.
   */
  export circuit divRem(a: Uint<64>, b: Uint<64>): DivResultU64 {
    return _div(a, b);
  }

  /**
   * @title Square Root circuit
   * @description Computes the floor of the square root of a Uint<64> value.
   *
   * Theoretical Description:
   * This circuit calculates the floor of the square root R = floor(sqrt(N)) of a 64-bit unsigned integer
   * N, provided as a Uint<64> value in [0, 2^64 - 1]. The result is a Uint<32> value R in [0, 2^32 - 1],
   * such that R^2 <= N < (R + 1)^2. It uses a witness-based approach for the general case and includes
   * special cases for common inputs to optimize performance.
   *
   * Mathematical Steps:
   * 1. General Case Computation:
   *    - Compute R = floor(sqrt(N)) using sqrtLocally, where R is in [0, 2^32 - 1].
   * 2. Root Verification:
   *    - Compute rootSquare = R * R using mul.
   *    - Assert rootSquare <= N, ensuring R^2 <= N.
   * 3. Next Value Verification:
   *    - Compute next = R + 1, where next is in [1, 2^32].
   *    - Compute nextSquare = next * next using mul.
   *    - Assert nextSquare > N, ensuring (R + 1)^2 > N.
   * 4. Result:
   *    - Return R as Uint<32>.
   *
   * @remarks
   * Requirements:
   * - `radicand` must be a valid `Uint<64>` value.
   * - `rootSquare` must be less than or equal to `radicand`.
   * - `nextSquare` must be greater than `radicand`.
   *
   * @circuitInfo k=10, rows=122
   *
   * @param {Uint<64>} radicand - The Uint<64> value to compute the square root of.
   *
   * @throws {Error} "Math: sqrt overestimate" If R^2 > radicand.
   * @throws {Error} "Math: sqrt underestimate" If (R + 1)^2 <= radicand.
   *
   * @returns {Uint<32>} The floor of the square root of radicand.
   */
  export circuit sqrt(radicand: Uint<64>): Uint<32> {
    const root = sqrtU64Locally(radicand);
    const rootSquare = mul(root, root);
    assert(rootSquare <= radicand, "Math: sqrt overestimate");

    const next = root + 1;
    const nextSquare = mul(next, next);
    assert(nextSquare > radicand, "Math: sqrt underestimate");

    return root;
  }

  /**
   * @title Is Multiple circuit
   * @description Checks if a `Uint<64>` number is a multiple of another.
   * 
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses `rem` circuit to check if remainder is zero.
   *
   * @circuitInfo k=10, rows=243
   *
   * @param {Uint<64>} a - The unsigned 64-bit integer to check.
   * @param {Uint<64>} b - The unsigned 64-bit integer divisor.
   *
   * @throws {Error} "Math: division by zero" if `b` is zero.
   *
   * @returns {Boolean} `true` if `a` is a multiple of `b`, `false` otherwise.
   */
  export circuit isMultiple(a: Uint<64>, b: Uint<64>): Boolean {
    return rem(a, b) == 0;
  }

  /**
   * @title Min circuit
   * @description Returns the minimum of two Uint<64> values.
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Uint<64>` values.
   *
   * @circuitInfo k=10, rows=128
   *
   * @param {Uint<64>} a - The first unsigned 64-bit integer.
   * @param {Uint<64>} b - The second unsigned 64-bit integer.
   *
   * @returns {Uint<64>} The smaller of `a` and `b` as a `Uint<64>` value.
   */
  export circuit min(a: Uint<64>, b: Uint<64>): Uint<64> {
    return a < b ? a : b;
  }

  /**
   * @title Max circuit
   * @description Returns the maximum of two Uint<64> values.
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Uint<64>` values.
   *
   * @circuitInfo k=10, rows=128
   *
   * @param {Uint<64>} a - The first unsigned 64-bit integer.
   * @param {Uint<64>} b - The second unsigned 64-bit integer.
   *
   * @returns {Uint<64>} The larger of `a` and `b` as a `Uint<64>` value.
   */
  export circuit max(a: Uint<64>, b: Uint<64>): Uint<64> {
    return a > b ? a : b;
  }
}

</Uint64.compact>

<IUint128.compact>
// SPDX-License-Identifier: MIT
pragma language_version >= 0.18.0;

/**
 * @title IUint128
 * @dev Interface for 128-bit unsigned integer operations using the U128 struct.
 *
 * The U128 struct represents a 128-bit unsigned integer as two 64-bit unsigned integers:
 * - `low`: The least significant 64 bits (bits 0-63).
 * - `high`: The most significant 64 bits (bits 64-127).
 *
 * This interface enables arithmetic, division, square root, and utility operations on 128-bit numbers,
 * facilitating environments that natively support only 64-bit integers.
 */
module IUint128 {
  export struct U128 {
    /**
     * @description The least significant 64 bits (bits 0-63) of the 128-bit number
     */
    low: Uint<64>,
    /**
     * @description The most significant 64 bits (bits 64-127) of the 128-bit number
     */
    high: Uint<64>
  }

  /**
   * @description A struct representing the result of a division operation on U128 values.
   */
  export struct DivResultU128 {
    /**
     * @description The quotient result of the division operation
     */
    quotient: U128,
    /**
     * @description The remainder result of the division operation
     */
    remainder: U128
  }

  /**
   * @description Computes division of two U128 values locally (off-chain).
   *
   * @param a The number to divide.
   * @param b The number to divide by.
   * @returns DivResultU128 The quotient and remainder of the division as U128 values.
   */
  export witness divU128Locally(a: U128, b: U128): DivResultU128;

  /**
   * @description Computes division of two Uint<128> values locally (off-chain).
   *
   * @param a The number to divide.
   * @param b The number to divide by.
   * @returns DivResultU128 The quotient and remainder of the division as U128 values.
   */
  export witness divUint128Locally(a: Uint<128>, b: Uint<128>): DivResultU128;

  /**
   * @description Computes the square root of a U128 value locally (off-chain).
   *
   * @param radicand The U128 value to compute the square root of.
   * @returns Uint<64> The square root of radicand.
   */
  export witness sqrtU128Locally(radicand: U128): Uint<64>;
}

</IUint128.compact>

<IUint256.compact>
// SPDX-License-Identifier: MIT
pragma language_version >= 0.18.0;

/**
 * @title IUint256
 * @dev Interface for 256-bit unsigned integer operations using the U256 struct.
 *
 * The U256 struct represents a 256-bit unsigned integer as two U128 structs:
 * - `low`: The least significant 128 bits (bits 0-127).
 * - `high`: The most significant 128 bits (bits 128-255).
 *
 * This interface enables arithmetic, division, square root, and utility operations on 256-bit numbers,
 * facilitating environments that natively support only 128-bit or 64-bit integers.
 */
module IUint256 {
  import IUint128;

  export struct U256 {
    /**
     * @description The least significant 128 bits (bits 0-127) of the 256-bit number
     */
    low: U128,
    /**
     * @description The most significant 128 bits (bits 128-255) of the 256-bit number
     */
    high: U128
  }

  /**
   * @description A struct representing the result of a division operation on U256 values.
   */
  export struct DivResultU256 {
    /**
     * @description The quotient result of the division operation
     */
    quotient: U256,
    /**
     * @description The remainder result of the division operation
     */
    remainder: U256
  }

  /**
   * @description Computes division of two U256 values locally (off-chain).
   *
   * @param a The number to divide.
   * @param b The number to divide by.
   * @returns DivResultU256 The quotient and remainder of the division as U256 structs.
   */
  export witness divU256Locally(a: U256, b: U256): DivResultU256;

  /**
   * @description Computes the square root of a U256 value locally (off-chain).
   *
   * @param radicand The number to compute the square root of.
   * @returns Uint<128> The square root of radicand.
   */
  export witness sqrtU256Locally(radicand: U256): Uint<128>;

  /**
   * @description Computes division of two Uint<254> values locally (off-chain).
   *
   * @param a The Uint<254> value to divide.
   * @param b The Uint<254> value to divide by.
   * @returns DivResultU256 The quotient and remainder of the division as U256 structs.
   */
  export witness divUint254Locally(a: Uint<254>, b: Uint<254>): DivResultU256;
}

</IUint256.compact>

<IUint64.compact>
// SPDX-License-Identifier: MIT
pragma language_version >= 0.18.0;

/**
 * @title IUint64
 * @dev This module provides interfaces for performing mathematical operations on Uint<64> values.
 * It includes witness functions for division and square root calculations that are computed locally (off-chain).
 * The module works with Uint<64> values which represent 64-bit unsigned integers.
 */
module IUint64 {
  /**
   * @dev Struct containing the quotient and remainder from a division operation
   */
  export struct DivResultU64 {
    /**
     * @dev The quotient result from the division operation
     */
    quotient: Uint<64>,
    /**
     * @dev The remainder result from the division operation
     */
    remainder: Uint<64>
  }

  /**
   * @description Computes division of two Uint<64> values locally (off-chain).
   *
   * @param a The number to divide.
   * @param b The number to divide by.
   * @returns DivResultU64 The quotient and remainder of the division.
   */
  export witness divU64Locally(a: Uint<64>, b: Uint<64>): DivResultU64;

  /**
   * @description Computes the square root of a Uint<64> value locally (off-chain).
   *
   * @param radicand The number to compute the square root of.
   * @returns Uint<32> The square root of radicand.
   */
  export witness sqrtU64Locally(radicand: Uint<64>): Uint<32>;
}

</IUint64.compact>

<Bytes32.mock.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/test/Bytes32.mock.compact)

pragma language_version >= 0.18.0;

import CompactStandardLibrary;

import "../Bytes32" prefix Bytes32_;

export circuit fromBytes(bytes: Bytes<32>): Field {
  return Bytes32_fromBytes(bytes);
}

export circuit toBytes(field: Field): Bytes<32> {
  return Bytes32_toBytes(field);
}

export circuit eq(a: Bytes<32>, b: Bytes<32>): Boolean {
  return Bytes32_eq(a, b);
}

export circuit lt(a: Bytes<32>, b: Bytes<32>): Boolean {
  return disclose(Bytes32_lt(a, b));
}

export circuit lte(a: Bytes<32>, b: Bytes<32>): Boolean {
  return disclose(Bytes32_lte(a, b));
}

export circuit gt(a: Bytes<32>, b: Bytes<32>): Boolean {
  return disclose(Bytes32_gt(a, b));
}

export circuit gte(a: Bytes<32>, b: Bytes<32>): Boolean {
  return disclose(Bytes32_gte(a, b));
}

export circuit isZero(a: Bytes<32>): Boolean {
  return Bytes32_isZero(a);
}

</Bytes32.mock.compact>

<Field254.mock.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/test/Field254.mock.compact)

pragma language_version >= 0.18.0;

import CompactStandardLibrary;

import "../interfaces/IUint256";

import "../Field254" prefix Field254_;

export { U256, DivResultU256 };

export circuit fromField(a: Field): U256 {
  return disclose(Field254_fromField(a));
}

export circuit toField(a: U256): Field {
  return disclose(Field254_toField(a));
}

export circuit eq(a: Field, b: Field): Boolean {
  return disclose(Field254_eq(a, b));
}

export circuit lt(a: Field, b: Field): Boolean {
  return disclose(Field254_lt(a, b));
}

export circuit lte(a: Field, b: Field): Boolean {
  return disclose(Field254_lte(a, b));
}

export circuit gt(a: Field, b: Field): Boolean {
  return disclose(Field254_gt(a, b));
}

export circuit gte(a: Field, b: Field): Boolean {
  return disclose(Field254_gte(a, b));
}

export circuit add(a: Field, b: Field): Field {
  return disclose(Field254_add(a, b));
}

export circuit sub(a: Field, b: Field): Field {
  return disclose(Field254_sub(a, b));
}

export circuit mul(a: Field, b: Field): Field {
  return disclose(Field254_mul(a, b));
}

export circuit div(a: Field, b: Field): Field {
  return disclose(Field254_div(a, b));
}

export circuit rem(a: Field, b: Field): Field {
  return disclose(Field254_rem(a, b));
}

export circuit divRem(a: Field, b: Field): DivResultU256 {
  return disclose(Field254_divRem(a, b));
}

export circuit sqrt(a: Field): Field {
  return disclose(Field254_sqrt(a));
}

export circuit min(a: Field, b: Field): Field {
  return disclose(Field254_min(a, b));
}

export circuit max(a: Field, b: Field): Field {
  return disclose(Field254_max(a, b));
}

export circuit isZero(a: Field): Boolean {
  return disclose(Field254_isZero(a));
}

</Field254.mock.compact>

<Max.mock.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/test/Max.mock.compact)

pragma language_version >= 0.18.0;

/**
 * @description A mock module for testing Max functionality.
 */
import "../interfaces/IUint128";

import "../interfaces/IUint256";

import "../Max" prefix Max_;

export pure circuit MAX_UINT8(): Uint<8> {
  return Max_MAX_UINT8();
}

export pure circuit MAX_UINT16(): Uint<16> {
  return Max_MAX_UINT16();
}

export pure circuit MAX_UINT32(): Uint<32> {
  return Max_MAX_UINT32();
}

export pure circuit MAX_UINT64(): Uint<64> {
  return Max_MAX_UINT64();
}

export pure circuit MAX_UINT128(): Uint<128> {
  return Max_MAX_UINT128();
}

export pure circuit MAX_FIELD(): Uint<254> {
  return Max_MAX_FIELD();
}

export pure circuit MAX_UINT254(): U256 {
  return Max_MAX_UINT254();
}

export pure circuit MAX_U128(): U128 {
  return Max_MAX_U128();
}

export pure circuit MAX_U256(): U256 {
  return Max_MAX_U256();
}

</Max.mock.compact>

<Uint128.mock.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/test/Uint128.mock.compact)

pragma language_version >= 0.18.0;

import CompactStandardLibrary;

import "../interfaces/IUint128";

import "../interfaces/IUint256";

import "../Uint128" prefix Uint128_;

export { U128, U256, DivResultU128 };

/**
 * @description A mock contract for testing the MathU128 module's circuits.
 */

export pure circuit MODULUS(): Uint<128> {
  return Uint128_MODULUS();
}

export pure circuit ZERO_U128(): U128 {
  return Uint128_ZERO_U128();
}

export circuit toU128(value: Uint<128>): U128 {
  return disclose(Uint128_toU128(value));
}

export circuit fromU128(value: U128): Uint<128> {
  return disclose(Uint128_fromU128(value));
}

export circuit isZero(value: Uint<128>): Boolean {
  return Uint128_isZero(value);
}

export circuit isZeroU128(value: U128): Boolean {
  return Uint128_isZeroU128(value);
}

export circuit eq(a: Uint<128>, b: Uint<128>): Boolean {
  return Uint128_eq(a, b);
}

export circuit eqU128(a: U128, b: U128): Boolean {
  return Uint128_eqU128(a, b);
}

export circuit lt(a: Uint<128>, b: Uint<128>): Boolean {
  return disclose(Uint128_lt(a, b));
}

export circuit lte(a: Uint<128>, b: Uint<128>): Boolean {
  return disclose(Uint128_lte(a, b));
}

export circuit ltU128(a: U128, b: U128): Boolean {
  return disclose(Uint128_ltU128(a, b));
}

export circuit lteU128(a: U128, b: U128): Boolean {
  return disclose(Uint128_lteU128(a, b));
}

export circuit gt(a: Uint<128>, b: Uint<128>): Boolean {
  return disclose(Uint128_gt(a, b));
}

export circuit gte(a: Uint<128>, b: Uint<128>): Boolean {
  return disclose(Uint128_gte(a, b));
}

export circuit gtU128(a: U128, b: U128): Boolean {
  return disclose(Uint128_gtU128(a, b));
}

export circuit gteU128(a: U128, b: U128): Boolean {
  return disclose(Uint128_gteU128(a, b));
}

export circuit add(a: Uint<128>, b: Uint<128>): U256 {
  return disclose(Uint128_add(a, b));
}

export circuit addU128(a: U128, b: U128): U256 {
  return disclose(Uint128_addU128(a, b));
}

export circuit addChecked(a: Uint<128>, b: Uint<128>): Uint<128> {
  return disclose(Uint128_addChecked(a, b));
}

export circuit addCheckedU128(a: U128, b: U128): Uint<128> {
  return disclose(Uint128_addCheckedU128(a, b));
}

export circuit sub(a: Uint<128>, b: Uint<128>): Uint<128> {
  return disclose(Uint128_sub(a, b));
}

export circuit subU128(a: U128, b: U128): U128 {
  return Uint128_subU128(a, b);
}

export circuit mul(a: Uint<128>, b: Uint<128>): U256 {
  return disclose(Uint128_mul(a, b));
}

export circuit mulU128(a: U128, b: U128): U256 {
  return disclose(Uint128_mulU128(a, b));
}

export circuit mulChecked(a: Uint<128>, b: Uint<128>): Uint<128> {
  return disclose(Uint128_mulChecked(a, b));
}

export circuit mulCheckedU128(a: U128, b: U128): Uint<128> {
  return disclose(Uint128_mulCheckedU128(a, b));
}

export circuit div(a: Uint<128>, b: Uint<128>): Uint<128> {
  return disclose(Uint128_div(a, b));
}

export circuit divU128(a: U128, b: U128): U128 {
  return disclose(Uint128_divU128(a, b));
}

export circuit rem(a: Uint<128>, b: Uint<128>): Uint<128> {
  return disclose(Uint128_rem(a, b));
}

export circuit remU128(a: U128, b: U128): U128 {
  return disclose(Uint128_remU128(a, b));
}

export circuit divRem(a: Uint<128>, b: Uint<128>): DivResultU128 {
  return disclose(Uint128_divRem(a, b));
}

export circuit divRemU128(a: U128, b: U128): DivResultU128 {
  return disclose(Uint128_divRemU128(a, b));
}

export circuit sqrt(radicand: Uint<128>): Uint<64> {
  return disclose(Uint128_sqrt(radicand));
}

export circuit sqrtU128(radicand: U128): Uint<64> {
  return disclose(Uint128_sqrtU128(radicand));
}

export circuit min(a: Uint<128>, b: Uint<128>): Uint<128> {
  return disclose(Uint128_min(a, b));
}

export circuit minU128(a: U128, b: U128): U128 {
  return Uint128_minU128(a, b);
}

export circuit max(a: Uint<128>, b: Uint<128>): Uint<128> {
  return disclose(Uint128_max(a, b));
}

export circuit maxU128(a: U128, b: U128): U128 {
  return disclose(Uint128_maxU128(a, b));
}

export circuit isMultiple(value: Uint<128>, b: Uint<128>): Boolean {
  return disclose(Uint128_isMultiple(value, b));
}

export circuit isMultipleU128(value: U128, b: U128): Boolean {
  return disclose(Uint128_isMultipleU128(value, b));
}

</Uint128.mock.compact>

<Uint256.mock.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/test/Uint256.mock.compact)

pragma language_version >= 0.18.0;

import CompactStandardLibrary;

import "../interfaces/IUint128";

import "../interfaces/IUint256";

import "../Uint256" prefix Uint256_;

export { U256, DivResultU256 };

export circuit MODULUS(): Uint<129> {
  return Uint256_MODULUS();
}

export circuit MODULUS_U256(): U256 {
  return Uint256_MODULUS_U256();
}

export circuit ZERO_U256(): U256 {
  return Uint256_ZERO_U256();
}

export circuit fromU256(a: U256): Uint<254> {
  return disclose(Uint256_fromU256(a));
}

export circuit toU256(a: Uint<254>): U256 {
  return disclose(Uint256_toU256(a));
}

export circuit eq(a: U256, b: U256): Boolean {
  return Uint256_eq(a, b);
}

export circuit lt(a: U256, b: U256): Boolean {
  return Uint256_lt(a, b);
}

export circuit lte(a: U256, b: U256): Boolean {
  return Uint256_lte(a, b);
}

export circuit gt(a: U256, b: U256): Boolean {
  return Uint256_gt(a, b);
}

export circuit gte(a: U256, b: U256): Boolean {
  return Uint256_gte(a, b);
}

export circuit add(a: U256, b: U256): U256 {
  return disclose(Uint256_add(a, b));
}

export circuit sub(a: U256, b: U256): U256 {
  return disclose(Uint256_sub(a, b));
}

export circuit mul(a: U256, b: U256): U256 {
  return disclose(Uint256_mul(a, b));
}

export circuit div(a: U256, b: U256): U256 {
  return disclose(Uint256_div(a, b));
}

export circuit rem(a: U256, b: U256): U256 {
  return disclose(Uint256_rem(a, b));
}

export circuit divRem(a: U256, b: U256): DivResultU256 {
  return disclose(Uint256_divRem(a, b));
}

export circuit sqrt(radicand: U256): Uint<128> {
  return disclose(Uint256_sqrt(radicand));
}

export circuit min(a: U256, b: U256): U256 {
  return disclose(Uint256_min(a, b));
}

export circuit max(a: U256, b: U256): U256 {
  return disclose(Uint256_max(a, b));
}

export circuit isZero(a: U256): Boolean {
  return Uint256_isZero(a);
}

export circuit isExceedingFieldSize(a: U256): Boolean {
  return Uint256_isExceedingFieldSize(a);
}

export circuit isLowestLimbOnly(val: U256, limbValue: Uint<64>): Boolean {
  return Uint256_isLowestLimbOnly(val, limbValue);
}

export circuit isSecondLimbOnly(val: U256, limbValue: Uint<64>): Boolean {
  return Uint256_isSecondLimbOnly(val, limbValue);
}

export circuit isThirdLimbOnly(val: U256, limbValue: Uint<64>): Boolean {
  return Uint256_isThirdLimbOnly(val, limbValue);
}

export circuit isHighestLimbOnly(val: U256, limbValue: Uint<64>): Boolean {
  return Uint256_isHighestLimbOnly(val, limbValue);
}

export circuit isMultiple(value: U256, b: U256): Boolean {
  return disclose(Uint256_isMultiple(value, b));
}

</Uint256.mock.compact>

<Uint64.mock.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/test/Uint64.mock.compact)

pragma language_version >= 0.18.0;

import CompactStandardLibrary;

import "../interfaces/IUint64";

import "../Uint64" prefix Uint64_;

export circuit add(a: Uint<64>, b: Uint<64>): Uint<128> {
  return Uint64_add(a, b);
}

export circuit sub(a: Uint<64>, b: Uint<64>): Uint<64> {
  return Uint64_sub(a, b);
}

export circuit mul(a: Uint<64>, b: Uint<64>): Uint<128> {
  return Uint64_mul(a, b);
}

export circuit div(a: Uint<64>, b: Uint<64>): Uint<64> {
  return disclose(Uint64_div(a, b));
}

export circuit rem(a: Uint<64>, b: Uint<64>): Uint<64> {
  return disclose(Uint64_rem(a, b));
}

export circuit divRem(a: Uint<64>, b: Uint<64>): DivResultU64 {
  return disclose(Uint64_divRem(a, b));
}

export circuit sqrt(radical: Uint<64>): Uint<32> {
  return disclose(Uint64_sqrt(radical));
}

export circuit isMultiple(value: Uint<64>, b: Uint<64>): Boolean {
  return disclose(Uint64_isMultiple(value, b));
}

export circuit min(a: Uint<64>, b: Uint<64>): Uint<64> {
  return Uint64_min(a, b);
}

export circuit max(a: Uint<64>, b: Uint<64>): Uint<64> {
  return Uint64_max(a, b);
}

</Uint64.mock.compact>

<ShieldedFungibleToken.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (shielded-token/ShieldedFungibleToken.compact)

pragma language_version >= 0.18.0;

import CompactStandardLibrary;

import "./openzeppelin/ShieldedERC20" prefix ShieldedFungibleToken_;

export { ShieldedFungibleToken__nonce, ShieldedFungibleToken__domain, };

constructor(nonce_: Bytes<32>,
            name_: Opaque<"string">,
            symbol_: Opaque<"string">,
            domain_: Bytes<32>) {
  const decimals = 18;
  ShieldedFungibleToken_initialize(nonce_, name_, symbol_, decimals, domain_);
}

export circuit name(): Opaque<"string"> {
  return ShieldedFungibleToken_name();
}

export circuit symbol(): Opaque<"string"> {
  return ShieldedFungibleToken_symbol();
}

export circuit decimals(): Uint<8> {
  return ShieldedFungibleToken_decimals();
}

export circuit totalSupply(): Uint<128> {
  return ShieldedFungibleToken_totalSupply();
}

export circuit type(): Bytes<32> {
  return ShieldedFungibleToken_type();
}

export circuit mint(recipient: Either<ZswapCoinPublicKey, ContractAddress>, amount: Uint<64>): CoinInfo {
  return ShieldedFungibleToken_mint(recipient, amount);
}

export circuit burn(coin: CoinInfo, amount: Uint<128>): SendResult {
  return ShieldedFungibleToken_burn(coin, amount);
}

</ShieldedFungibleToken.compact>

<ShieldedERC20.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (shielded-token/openzeppelin/ShieldedERC20.compact)

pragma language_version >= 0.18.0;

/**
 * @module ShieldedToken (archived until further notice, DO NOT USE IN PRODUCTION)
 * @description A shielded token module.
 *
 * @notice This module utilizes the existing coin infrastructure of Midnight.
 * Due to the current limitations of the network, this module should NOT be used.
 *
 * Some of the limitations include:
 *
 * - No custom spend logic. Once users receive tokens, there's no mechanism to
 * enforce any token behaviors. This is a big issue with stable coins, for instance.
 * Most stable coins want the ability to pause functionality and/or freeze assets from
 * specific addresses. This is currently not possible.
 *
 * - Cannot guarantee proper total supply accounting. The total supply of a given token
 * is stored in the contract state. There's nothing to prevent users from burning
 * tokens manually by directly sending them to the burn address. This breaks the
 * total supply accounting (and potentially many other mechanisms).
 *
 * @notice This module will be revisited when the Midnight network can offer solutions to these
 * issues. Until then, the recommendation is to use unshielded tokens.
 *
 * @dev Future ideas to consider:
 *
 * - Provide a self-minting mechanism.
 * - Enable the Shielded contract itself to transfer.
 * - Should this be a part of the Shielded module itself or as an extension?
 */
module ShieldedERC20 { // DO NOT USE IN PRODUCTION!
  import CompactStandardLibrary;
  import Utils prefix Utils_;
  import "../../math/Bytes32" prefix Bytes32_;

  // Public state
  export ledger _counter: Counter;
  export ledger _nonce: Bytes<32>;
  export ledger _totalSupply: Uint<128>;
  export sealed ledger _domain: Bytes<32>;
  export sealed ledger _name: Opaque<"string">;
  export sealed ledger _symbol: Opaque<"string">;
  export sealed ledger _decimals: Uint<8>;
  export ledger _type: Bytes<32>;

  /**
   * @description Initializes the contract by setting the initial nonce
   * and the metadata.
   *
   * @return {[]} - None.
   */
  export circuit initialize(
                   initNonce: Bytes<32>,
                   name_: Opaque<"string">,
                   symbol_: Opaque<"string">,
                   decimals_: Uint<8>,
                   domain_: Bytes<32>
                   ): [] {
    _nonce = disclose(initNonce);
    _domain = disclose(domain_);
    _name = disclose(name_);
    _symbol = disclose(symbol_);
    _decimals = disclose(decimals_);
  }

  /**
   * @description Returns the token name.
   *
   * @return {Maybe<Opaque<"string">>} - The token name.
   */
  export circuit name(): Opaque<"string"> {
    return _name;
  }

  /**
   * @description Returns the symbol of the token.
   *
   * @return {Maybe<Opaque<"string">>} - The token name.
   */
  export circuit symbol(): Opaque<"string"> {
    return _symbol;
  }

  /**
   * @description Returns the number of decimals used to get its user representation.
   *
   * @return {Uint<8>} - The account's token balance.
   */
  export circuit decimals(): Uint<8> {
    return _decimals;
  }

  /**
   * @description Returns the type of the token.
   *
   * @return {Bytes<32>} - The type of the token.
   */
  export circuit type(): Bytes<32> {
    return _type;
  }

  /**
   * @description Returns the value of tokens in existence.
   * @notice The total supply accounting mechanism cannot be guaranteed to be accurate.
   * There is nothing to prevent users from directly sending tokens to the burn
   * address without going through the contract; thus, tokens will be burned
   * but the accounted supply will not change.
   *
   * @return {Uint<64>} - The total supply of tokens.
   */
  export circuit totalSupply(): Uint<128> {
    return _totalSupply;
  }

  /**
   * @description Mints `amount` of tokens to `recipient`.
   * @dev This circuit does not include access control meaning anyone can call it.
   *
   * @param {recipient} - The ZswapCoinPublicKey or ContractAddress that receives the minted tokens.
   * @param {amount} - The value of tokens minted.
   * @return {CoinInfo} - The description of the newly created coin.
   */
  // TODO: if we use Uint<128> we get this compilation error: 
  // no compatible function named mintToken is in scope at this call
  //   one function is incompatible with the supplied argument types
  //     supplied argument types:
  //       (Bytes<32>, Uint<128>, Bytes<32>, struct Either<is_left: Boolean, left: struct
  //       ZswapCoinPublicKey<bytes: Bytes<32>>, right: struct ContractAddress<bytes:
  //       Bytes<32>>>)
  //     declared argument types for function at <standard library>:
  //       (Bytes<32>, Uint<64>, Bytes<32>, struct Either<is_left: Boolean, left: struct
  //       ZswapCoinPublicKey<bytes: Bytes<32>>, right: struct ContractAddress<bytes:
  //       Bytes<32>>>)
  export circuit mint(recipient: Either<ZswapCoinPublicKey, ContractAddress>, amount: Uint<64>): CoinInfo {
    assert(!Utils_isKeyOrAddressZero(recipient), "ShieldedToken: invalid recipient");

    // TODO: Is that correct here? Do we need to increment after minting? not before?
    _counter.increment(1);
    const newNonce = evolveNonce(_counter, _nonce);
    _nonce = newNonce;
    // TODO: had to add disclose here, what does that mean?
    const ret = mintToken(_domain, disclose(amount), _nonce, disclose(recipient));
    // TODO: find a better solution for detecting the type
    if (Bytes32_isZero(_type)) {
      _type = ret.color;
    }
    _totalSupply = _totalSupply + disclose(amount) as Uint<128>;
    return ret;
  }

  /**
   * @description Destroys `amount` of `coin` by sending it to the burn address.
   * @dev This circuit does not include access control meaning anyone can call it.
   * @throws Will throw if `coin` color is not this contract's token type.
   * @throws Will throw if `amount` is less than `coin` value.
   *
   * @param {coin} - The coin description that will be burned.
   * @param {amount} - The value of `coin` that will be burned.
   * @return {SendResult} - The output of sending tokens to the burn address. This may include change from
   * spending the output if available.
   */
  export circuit burn(coin: CoinInfo, amount: Uint<128>): SendResult {
    assert(coin.color == _type, "ShieldedToken: token not created from this contract");
    assert(coin.value >= amount, "ShieldedToken: insufficient token amount to burn");

    receive(disclose(coin));
    _totalSupply = _totalSupply - disclose(amount);

    const sendRes = sendImmediate(disclose(coin), burnAddress(), disclose(amount));
    if (sendRes.change.is_some) {
      // tmp for only zswap because we should be able to handle contracts burning tokens
      // and returning change.
      const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
      sendImmediate(sendRes.change.value, caller, sendRes.change.value.value);
    }

    return sendRes;
  }
}

</ShieldedERC20.compact>

<Utils.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (shielded-token/openzeppelin/Utils.compact)

pragma language_version >= 0.18.0;

module Utils {
  import CompactStandardLibrary;

  /**
   * @description Returns whether `keyOrAddress` is the zero address.
   *
   * @param {keyOrAddress} - The target value to check, either a ZswapCoinPublicKey or a ContractAddress.
   * @return {Boolean} - Returns true if `keyOrAddress` is zero.
   */
  export pure circuit isKeyOrAddressZero(keyOrAddress: Either<ZswapCoinPublicKey, ContractAddress>): Boolean {
    if (keyOrAddress.is_left) {
       return keyOrAddress == eitherZeroZPK();
    } else {
       return keyOrAddress == eitherZeroContractAddress();
    }
  }

  /**
   * @description Returns a zero-filled 32-byte array.
   *
   * @return {Bytes<32>} - A 32-byte array filled with zeros.
   */
  export pure circuit zeroBytes(): Bytes<32> {
    return pad(32, "");
  }

  /**
   * @description Returns a zero Zswap coin public key.
   *
   * @return {ZswapCoinPublicKey} - A ZswapCoinPublicKey with all bytes set to zero.
   */
  export pure circuit zeroZPK(): ZswapCoinPublicKey {
    return ZswapCoinPublicKey { bytes: zeroBytes() };
  }

  /**
   * @description Returns the caller's Zswap coin public key.
   *
   * @return {ZswapCoinPublicKey} - The public key of the caller.
   */
  export circuit callerZPK(): ZswapCoinPublicKey {
    return ownPublicKey();
  }

  /**
   * @description Returns the current contract's address.
   *
   * @return {ContractAddress} - The address of this contract.
   */
  export circuit thisAddress(): ContractAddress {
    return kernel.self();
  }

  /**
   * @description Returns the sender's public key as the left variant of an Either type, representing
   * a ZswapCoinPublicKey.
   *
   * @returns Either<ZswapCoinPublicKey, ContractAddress> The sender’s public key as the left variant.
   */
  export circuit eitherCaller(): Either<ZswapCoinPublicKey, ContractAddress> {
    return left<ZswapCoinPublicKey, ContractAddress>(callerZPK());
  }

  /**
   * @description Returns a zero Zswap coin public key as the left variant of an Either type.
   *
   * @return {Either<ZswapCoinPublicKey, ContractAddress>} - Zero ZswapCoinPublicKey as the left variant.
   */
  export pure circuit eitherZeroZPK(): Either<ZswapCoinPublicKey, ContractAddress> {
    return left<ZswapCoinPublicKey, ContractAddress>(zeroZPK());
  }

  /**
   * @description Returns a zero contract address as the right variant of an Either type.
   *
   * @return {Either<ZswapCoinPublicKey, ContractAddress>} - Zero ContractAddress as the right variant.
   */
  export pure circuit eitherZeroContractAddress(): Either<ZswapCoinPublicKey, ContractAddress> {
    return right<ZswapCoinPublicKey, ContractAddress>(ContractAddress { zeroBytes() });
  }

  /**
   * @description Wraps a Zswap coin public key as the left variant of an Either type.
   *
   * @param {pk} - The Zswap coin public key to wrap.
   * @return {Either<ZswapCoinPublicKey, ContractAddress>} - The public key as the left variant.
   */
  export circuit eitherZPK(pk: ZswapCoinPublicKey): Either<ZswapCoinPublicKey, ContractAddress> {
    return left<ZswapCoinPublicKey, ContractAddress>(pk);
  }

  /**
   * @description Returns the contract’s address as the right variant of an Either type, representing
   * a ContractAddress.
   *
   * @returns Either<ZswapCoinPublicKey, ContractAddress> The contract’s address as the right variant.
   */
  export circuit eitherThisAddress(): Either<ZswapCoinPublicKey, ContractAddress> {
    return right<ZswapCoinPublicKey, ContractAddress>(thisAddress());
  }
}

</Utils.compact>

<Queue.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (structs/Queue.compact)

pragma language_version >= 0.18.0;

/**
 * @module Queue
 * @description A simple queue implementation in Compact, using a 
 * Map to store elements with Uint<64> keys.
 *
 * # Compact Limitations and Design Choices
 * This queue implementation reflects several constraints and 
 * design decisions driven by Compact's language features:
 *
 * ## Why Map Instead of Vector?
 * - Vector Limitation: In Compact, `Vector<N, T>` only 
 *   supports constant indices (e.g., `vector[0]`), not variable 
 *   indices (e.g., `vector[i]`). This prevents dynamic access 
 *   or resizing, making it unsuitable for a queue where 
 *   elements are added and removed at runtime. Checkout 
 *   Queue Vector impl archive, src/archive/Queue.compact.archive.
 *
 * - Map Advantage: `Map<Uint<64>, T>` allows dynamic 
 *   key-value pairs with `insert`, `lookup`, and `remove` 
 *   operations, providing the flexibility needed for a queue. 
 *   It supports sparse storage, unlike `Vector`’s fixed-size, 
 *   contiguous requirement.
 *
 * ## Why No Shifting?
 * - Lack of Iteration: Compact (v0.14.0) doesn’t support 
 *   loops with variable bounds (e.g., `for (i of start..end)`), 
 *   only constant ranges (e.g., `0..1023`). Shifting requires 
 *   iterating over keys from `head + 1` to `tail - 1`, which 
 *   isn’t possible without manual unrolling for a fixed size.
 *
 * - No Bulk Updates: There’s no mechanism to shift 
 *   multiple `Map` entries in one operation, requiring 
 *   individual `lookup`, `insert`, and `remove` calls for each 
 *   key, which can’t be generalized without iteration.
 *
 * ## Consequences of No Shifting
 * - Sparse Keys: Without shifting, keys grow indefinitely 
 *   as `head` and `tail` increment (e.g., `{100: item}` after 
 *   100 dequeues), rather than staying contiguous (e.g., 
 *   `{0: item}`). This deviates from traditional queue 
 *   behavior but remains functional as a FIFO structure.
 *
 * - Memory Usage: The `Map` remains sparse, potentially 
 *   increasing key storage overhead.
 *
 * ## Algorithm Analysis
 * - Current Approach: Uses `head` and `tail` as `Counter` 
 *   ADTs to track the front and back. Enqueue adds at `tail` 
 *   and increments it; dequeue removes at `head` and 
 *   increments it, returning the value via `Maybe<T>`.
 *
 * - Time Complexity: 
 *   - Enqueue: O(1) for `Map.insert`.
 *   - Dequeue: O(1) for `Map.lookup` and `Map.remove` (no 
 *     shifting).
 *
 * - Space Complexity: O(n) where n is the number of 
 *   elements, but keys can grow up to `Uint<64>`’s limit 
 *   (2^64 - 1), far exceeding practical queue sizes.
 *
 * - Trade-offs: Sacrifices contiguous keys for simplicity 
 *   and feasibility within Compact’s constraints. Still 
 *   preserves FIFO order, making it a valid queue despite 
 *   unconventional key usage.
 *
 * This design prioritizes functionality over traditional 
 * queue aesthetics, leveraging `Map`’s strengths while 
 * working around Compact’s lack of dynamic iteration.
 *
 * @template T - The type of elements stored in the queue.
 */
module Queue<T> {
  import CompactStandardLibrary;

  /** @type {Map<Uint<64>, T>} The queue’s storage, mapping 
   * positions to elements. 
   */
  export ledger state: Map<Uint<64>, T>;

  /** @type {Counter} The position of the front element 
   * (head). 
   */
  export ledger head: Counter;

  /** @type {Counter} The position where the next element 
   * will be added (tail). 
   */
  export ledger tail: Counter;

  /**
   * @description Adds an element to the back of the queue.
   * @param item - The element to enqueue.
   * @remarks Inserts the item at the current `tail` position 
   * and increments `tail`. Time complexity: O(1).
   */
  export circuit enqueue(item: T): [] {
    // TODO: test tail overflow, currently that will be an infeasible test.
    // Because of the limit of increment(steps: Uint<16>)
    const MAX_UINT64 = 18446744073709551615;
    assert(tail != MAX_UINT64, "Queue: tail counter reached maximum capacity.");
    state.insert(tail, disclose(item));
    tail.increment(1);
  }

  /**
   * @description Removes and returns the element at the 
   * front of the queue.
   * @returns {Maybe<T>} The dequeued element wrapped in 
   * `Maybe`, or `none<T>` if the queue is empty.
   * @remarks Removes the element at `head`, increments 
   * `head`, and returns the value. Shifting is omitted due 
   * to Compact’s lack of iteration; keys remain sparse. 
   * Time complexity: O(1) without shifting.
   */
  export circuit dequeue(): Maybe<T> {
    if (isEmpty()) {
       return none<T>(); // Queue is empty
    } else {
       const MAX_UINT64 = 18446744073709551615;
       assert(head != MAX_UINT64, "Queue: head counter reached maximum capacity.");
       const value = state.lookup(head);
       state.remove(head);
       head.increment(1);
       // Shifting would require re-inserting all elements 
       // with new keys, but Compact lacks iteration or bulk 
       // updates, so we stop here
       // shift();
       return some<T>(value);
    }
  }

  /**
   * @description Checks if the queue is empty.
   * @returns {Boolean} True if the queue is empty (head == 
   * tail), false otherwise.
   * @remarks Relies on comparing `head` and `tail` counters. 
   * Time complexity: O(1).
   */
  export circuit isEmpty(): Boolean {
    return head == tail;
  }
}

</Queue.compact>

<Queue.mock.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (structs/test/Queue.mock.compact)

pragma language_version >= 0.18.0;

import CompactStandardLibrary;

import "../Queue"<Uint<16>> prefix Queue_;

// Export Public state
export { Queue_state, Queue_tail, Queue_head }

export circuit enqueue(item: Uint<16>): [] {
  return Queue_enqueue(item);
}

export circuit dequeue(): Maybe<Uint<16>> {
  return Queue_dequeue();
}

export circuit isEmpty(): Boolean {
  return Queue_isEmpty();
}

</Queue.mock.compact>

<StandardLiberary.compact>
// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (compact-std/Index.compact)

pragma language_version >= 0.18.0;

import CompactStandardLibrary;

/**
 * @description Standard structs from CompactStandardLibrary for use in contracts and TypeScript.
 */
export { Maybe, // Encapsulates an optionally present value
         Either, // Disjoint union of two types
         CurvePoint, // Point on the proof system's embedded curve
         MerkleTreeDigest, // Root hash of a Merkle tree
         MerkleTreePathEntry, // Entry in a Merkle tree path
         MerkleTreePath, // Path in a Merkle tree leading to a leaf
         ContractAddress, // Address of a contract
         CoinInfo, // Description of a newly created coin
         QualifiedCoinInfo, // Description of an existing coin in the ledger
         ZswapCoinPublicKey, // Public key for coin outputs
         SendResult // Result of send/send_immediate operations
         };

</StandardLiberary.compact>
<another-example>
pragma language_version >= 0.17;

import CompactStandardLibrary;

export enum EFFECT_TYPE {
    attack_phys,
    attack_fire,
    attack_ice,
    block,
}

// a note on attack base damage:
// damage is subject to resistances in EnemyStats and can go from half damage (weak) to +50% (effective) to double (super effective)
export struct Effect {
    effect_type: EFFECT_TYPE,
    amount: Uint<32>,
    is_aoe: Boolean,
}

export struct Ability {
    effect: Maybe<Effect>,
    // effects triggered by energy generation. one energy triggers all corresponding effects of all abilities
    on_energy: Vector<3, Maybe<Effect>>,
    // which type of energy to generate
    generate_color: Maybe<Uint<0..2>>,
    upgrade_level: Uint<0..3>,
}

export enum BOSS_TYPE {
    normal,
    miniboss,
    boss,
}

export struct EnemyStats {
    boss_type: BOSS_TYPE,
    /// Visual indication of what the enemy should be
    enemy_type: Uint<32>,
    hp: Uint<32>,
    moves: Vector<3, EnemyMove>,
    move_count: Uint<32>,
    physical_def: Uint<0..4>,
    fire_def: Uint<0..4>,
    ice_def: Uint<0..4>,
}

export struct EnemyMove {
    attack: Uint<32>,
    block_self: Uint<32>,
    block_allies: Uint<32>,
    heal_self: Uint<32>,
    heal_allies: Uint<32>,
}

// index by ability id
export /*sealed*/ ledger all_abilities: Map<Field, Ability>;

export pure circuit derive_ability_id(ability: Ability): Field {
    return transientCommit<Ability>(ability, 30);
}

// helper function for creating abilities. returns the ability id
circuit register_ability(ability: Ability): Field {
    const id = derive_ability_id(ability);
    all_abilities.insert(id, ability);
    return id;
}

// base abilities given at the start
export sealed ledger ability_base_phys_id: Field;
export sealed ledger ability_base_block_id: Field;
export sealed ledger ability_base_fire_aoe_id: Field;
export sealed ledger ability_base_ice_id: Field;

// ranks how "good" an ability is. higher is better. useful for ordering in the UI
export pure circuit ability_score(ability: Ability): Uint<32> {
    return ((3 * effect_score(ability.effect) + effect_score(ability.on_energy[0]) + effect_score(ability.on_energy[1]) + effect_score(ability.on_energy[2])) * (2 + (ability.generate_color.is_some as Uint<1>))) as Uint<32>;
}

// ranks how "good" an effect is. higher is better
pure circuit effect_score(effect: Maybe<Effect>): Uint<32> {
    const aoe = (1 + (effect.value.is_aoe as Uint<1>));
    // attacks are half that of block stats for efficient computations (* 2 is normal resistance) so adjust that here
    const attack_compensate = (1 + ((effect.value.effect_type == EFFECT_TYPE.attack_phys || effect.value.effect_type == EFFECT_TYPE.attack_ice || effect.value.effect_type == EFFECT_TYPE.attack_fire) as Uint<1>));
    return ((effect.is_some as Uint<1>) * (effect.value.amount * aoe * attack_compensate)) as Uint<32>;
}

// starting 4 abilities
export pure circuit ability_base_phys(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.attack_phys,
            5,
            false
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()],
        none<Uint<0..2>>(),
        0
    };
}

export pure circuit ability_base_block(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.block,
            10,
            false
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()],
        none<Uint<0..2>>(),
        0
    };
}

export pure circuit ability_base_fire_aoe(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.attack_fire,
            5,
            true
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()],
        none<Uint<0..2>>(),
        0
    };
}

export pure circuit ability_base_ice(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.attack_ice,
            10,
            false
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()],
        none<Uint<0..2>>(),
        0
    };
}

constructor() {
    deployer = derive_player_pub_key(disclose(player_secret_key()));
    ability_base_phys_id = register_ability(ability_base_phys());
    ability_base_block_id = register_ability(ability_base_block());
    ability_base_fire_aoe_id = register_ability(ability_base_fire_aoe());
    ability_base_ice_id = register_ability(ability_base_ice());
    players.resetToDefault();
}

// raw witness to do division/mod
// do not use directly - output must be validated
// please call div() and mod() circuits instead
witness _divMod(x: Uint<32>, y: Uint<32>): [Uint<32>, Uint<32>];

export circuit div(x: Uint<32>, y: Uint<32>): Uint<32> {
    const res = disclose(_divMod(x, y));
    const quotient = res[0];
    const remainder = res[1];
    assert(remainder < y && x == y * quotient + remainder, "Invalid divMod witness impl");
    return quotient;
}

export circuit mod(x: Uint<32>, y: Uint<32>): Uint<32> {
    const res = disclose(_divMod(x, y));
    const quotient = res[0];
    const remainder = res[1];
    assert(remainder < y && x == y * quotient + remainder, "Invalid divMod witness impl");
    return remainder;
}

// used to compute player ID. secret witness only known to the player.
witness player_secret_key(): Bytes<32>;

// compute player ID from the secret bytes (player_secret_key())
export pure circuit derive_player_pub_key(sk: Bytes<32>): Field {
    return transientCommit<Bytes<32>>(sk, 1024);
}

// indexed by user ID then by battle ID

// index by battle id
export ledger active_battle_states: Map<Field, BattleState>;
// index by battle id
export ledger active_battle_configs: Map<Field, BattleConfig>;

// index by quest id
export ledger quests: Map<Field, QuestConfig>;

export struct Player {
    gold: Uint<32>,
    rng: Bytes<32>,
}

// registered players. Key is Player ID
export ledger players: Map<Field, Player>;

// player id -> { ability id -> amount player has } (TODO: modified when sent to battle / quests? or should we only allow battling when not questing?)
// this isn't a part of Player as you can't sore Map/List/etc ledger types inside a regular compact type
export ledger player_abilities: Map<Field, Map<Field, Uint<32>>>;

// player progress tracking: player id -> biome -> difficulty -> boss completed
export ledger player_boss_progress: Map<Field, Map<Uint<32>, Map<Uint<32>, Boolean>>>;

export struct QuestConfig {
    level: Level,
    player_pub_key: Field,
    loadout: PlayerLoadout,
}

export struct BattleRewards {
    alive: Boolean;
    gold: Uint<32>;
    // reward ability that has been added to the player's available abilities
    ability: Maybe<Field>;
    // what else?
}

export struct EnemiesConfig {
    stats: Vector<3, EnemyStats>,
    count: Uint<0..3>,
}

export struct BattleConfig {
    level: Level,
    enemies: EnemiesConfig,
    player_pub_key: Field,
    loadout: PlayerLoadout,
}

export pure circuit derive_battle_id(battle: BattleConfig): Field {
    // TODO: swap to persistent?
    return transientCommit<BattleConfig>(battle, 0);
}

export pure circuit derive_quest_id(quest: QuestConfig): Field {
    // TODO: swap to persistent?
    return transientCommit<QuestConfig>(quest, 0);
}

export struct BattleState {
    /// Current round. This allows us to ignore outdated state
    round: Uint<32>;
    deck_indices: Vector<3, Uint<32>>;
    damage_to_player: Uint<32>;
    damage_to_enemy_0: Uint<32>;
    damage_to_enemy_1: Uint<32>;
    damage_to_enemy_2: Uint<32>;
    enemy_move_index_0: Uint<32>;
    enemy_move_index_1: Uint<32>;
    enemy_move_index_2: Uint<32>;
}

export struct PlayerLoadout {
    abilities: Vector<7, Field>,
}

export circuit register_new_player(): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    const initial_rng = persistentHash<Field>(player_id + players.size());
    players.insert(player_id, Player { 0, initial_rng });
    player_abilities.insertDefault(player_id);
    player_abilities.lookup(player_id).insert(ability_base_phys_id, 4);
    player_abilities.lookup(player_id).insert(ability_base_block_id, 4);
    player_abilities.lookup(player_id).insert(ability_base_ice_id, 1);
    player_abilities.lookup(player_id).insert(ability_base_fire_aoe_id, 1);
    player_boss_progress.insertDefault(player_id);
}

// both validates and drops from the player's current available abilities
circuit verify_loadout(loadout: PlayerLoadout): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    for (const ability_id of loadout.abilities) {
        player_remove_ability(player_id, ability_id);
    }
}

// gives player access to all their abilities used in this battle/quest. TODO: do we want to store the currently used ones somewhere?
circuit return_loadout(loadout: PlayerLoadout): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    for (const ability_id of loadout.abilities) {
        player_add_ability(player_id, ability_id);
    }
}

circuit ability_value(ability: Ability): Uint<32> {
    const score = ability_score(ability);
    return div((score * score) as Uint<32>, 500);
}

export circuit sell_ability(ability: Ability): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    const ability_id = derive_ability_id(disclose(ability));
    assert(ability_id != ability_base_block_id && ability_id != ability_base_phys_id, "Can't sell base abilities");
    player_remove_ability(player_id, ability_id);
    players.insert(player_id, Player {
        (players.lookup(player_id).gold + ability_value(disclose(ability))) as Uint<32>,
        players.lookup(player_id).rng
    });
}

export circuit upgrade_ability(ability: Ability, sacrifice: Ability): Field {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    const score = ability_score(ability);
    const sacrifice_score = ability_score(sacrifice);
    const upgrade_cost = ability_value(disclose(ability));

    assert(players.lookup(player_id).gold >= upgrade_cost, "Insufficient gold for upgrade");

    assert(score <= sacrifice_score, "Sacrificed ability must have score equal or greater to the ability to upgrade");

    players.insert(player_id, Player {
        (players.lookup(player_id).gold - upgrade_cost) as Uint<32>,
        players.lookup(player_id).rng
    });

    player_remove_ability(player_id, derive_ability_id(disclose(ability)));

    player_remove_ability(player_id, derive_ability_id(disclose(sacrifice)));

    assert(ability.upgrade_level < 3, "Ability can't be upgraded any more");

    const upgraded = compute_upgraded_ability(disclose(ability));
    const upgraded_id = derive_ability_id(upgraded);

    all_abilities.insert(upgraded_id, upgraded);
    player_add_ability(player_id, upgraded_id);

    return upgraded_id;
}

circuit player_add_ability(player_id: Field, ability_id: Field): [] {
    const count = player_abilities.lookup(player_id).member(ability_id) ? player_abilities.lookup(player_id).lookup(ability_id) : 0;
    player_abilities.lookup(player_id).insert(ability_id, (count + 1) as Uint<32>);
}

circuit player_remove_ability(player_id: Field, ability_id: Field): [] {
    const count = player_abilities.lookup(player_id).member(ability_id) ? player_abilities.lookup(player_id).lookup(ability_id) : 0;
    assert(count >= 1, "Must own ability to remove it");
    if (count > 1) {
        player_abilities.lookup(player_id).insert(ability_id, (count - 1) as Uint<32>);
    } else {
        player_abilities.lookup(player_id).remove(ability_id);
    }
}

circuit compute_upgraded_ability(ability: Ability): Ability {
    return Ability {
        effect: compute_upgraded_effect(ability.effect),
        on_energy: [compute_upgraded_effect(ability.on_energy[0]), compute_upgraded_effect(ability.on_energy[1]), compute_upgraded_effect(ability.on_energy[2])],
        generate_color: ability.generate_color,
        upgrade_level: (ability.upgrade_level + 1) as Uint<0..3>,
    };
}

circuit compute_upgraded_effect(effect: Maybe<Effect>): Maybe<Effect> {
    if (effect.is_some) {
        return some<Effect>(Effect {
            effect_type: effect.value.effect_type,
            amount: (div((13 * effect.value.amount) as Uint<32>, 10)) as Uint<32>,
            is_aoe: effect.value.is_aoe,
        });
    }
    return none<Effect>();
}

export pure circuit filler_move(): EnemyMove {
    return EnemyMove {
        0,
        0,
        0,
        0,
        0
    };
}

export pure circuit filler_enemy_stats(): EnemyStats {
    return EnemyStats { BOSS_TYPE.normal, 0, 0, [filler_move(), filler_move(), filler_move()], 0, 0, 0, 0 };
}

export circuit start_new_quest(loadout: PlayerLoadout, level: Level): Field {
    verify_loadout(disclose(loadout));

    // Validate difficulty access - level 1 is always allowed, higher levels require previous boss completion
    if (disclose(level.difficulty) > 1) {
        const player_id = derive_player_pub_key(disclose(player_secret_key()));
        const prevLevel = disclose(level.difficulty) - 1;
        assert(player_boss_progress.lookup(player_id).member(disclose(level.biome)) &&
               player_boss_progress.lookup(player_id).lookup(disclose(level.biome)).member(prevLevel) &&
               player_boss_progress.lookup(player_id).lookup(disclose(level.biome)).lookup(prevLevel),
               "Must complete previous level boss to access this level");
    }

    const player_pub_key = derive_player_pub_key(disclose(player_secret_key()));
    const quest = QuestConfig {
        level,
        player_pub_key,
        loadout
    };
    const quest_id = derive_quest_id(quest);
    quests.insert(disclose(quest_id), disclose(quest));

    return quest_id;
}

circuit random_ability(rng: Vector<32, Uint<8>>, factor: Uint<32>): Ability {
    const color = mod(rng[0], 6);
    const trigger1 = color != 0 && mod(rng[1], 3) == 0;
    const trigger2 = color != 1 && mod(rng[2], 3) == 0;
    const trigger3 = color != 2 && mod(rng[3], 3) == 0;
    const main_factor = factor * (1 + (trigger1 ? 0 : 1) + (trigger2 ? 0 : 1) + (trigger3 ? 0 : 1) + (color <= 2 ? 0 : 1));
    const main_effect = random_effect(rng[4], main_factor as Uint<32>);
    const trigger_factor = (2 * factor) as Uint<32>;
    return Ability {
        some<Effect>(main_effect),
        [
            trigger1 ? some<Effect>(random_effect(rng[5], trigger_factor)) : none<Effect>(),
            trigger2 ? some<Effect>(random_effect(rng[6], trigger_factor)) : none<Effect>(),
            trigger3 ? some<Effect>(random_effect(rng[7], trigger_factor)) : none<Effect>()
        ],
        color <= 2 ? some<Uint<0..2>>(color as Uint<0..2>) : none<Uint<0..2>>(),
        0
    };
}

circuit random_effect(rng: Uint<8>, factor: Uint<32>): Effect {
    const effect_type = cast_to_effect_type(mod(rng, 4) as Uint<0..4>);
    const aoe = effect_type != EFFECT_TYPE.block ? rng > 180 : false;
    // damage needs to be half that of block due to resistance calculations. see Effect comment
    const block_factor = effect_type != EFFECT_TYPE.block ? 1 : 2;
    const final_factor = factor * block_factor * (aoe ? 1 : 2);
    const amount = div((4 * final_factor/* + mod(rng, final_factor as Uint<32>)*/) as Uint<32>, 5);
    return Effect {
        effect_type,
        amount as Uint<32>,
        aoe
    };
}

// a workaround here would be nice...
pure circuit cast_to_effect_type(x: Uint<0..4>): EFFECT_TYPE {
    if (x == 0) {
        return EFFECT_TYPE.attack_phys;
    } else if (x == 1) {
        return EFFECT_TYPE.attack_fire;
    } else if (x == 2) {
        return EFFECT_TYPE.attack_ice;
    }
    return EFFECT_TYPE.block;
}

/**
 * Check if a quest is ready to be finalized (i.e. the player can enter the boss battle)
 * 
 * @returns a boolean indicating if the quest is ready
 */
export circuit is_quest_ready(quest_id: Field): Boolean {
    const quest = quests.lookup(disclose(quest_id));
    const player_pub_key = disclose(derive_player_pub_key(player_secret_key()));
    assert(quest.player_pub_key == player_pub_key, "Player auth failed");

    // TODO: check block height here - for now always return true
    // In the future, this would check if enough time has passed based on block height
    
    return true;
}

/**
 * Attempt to finalize a quest (enter into the boss battle)
 * 
 * @returns The battle ID of the resulting boss battle, or none if quest not ready yet
 */
export circuit finalize_quest(quest_id: Field): Maybe<Field> {
    const quest = quests.lookup(disclose(quest_id));
    const player_pub_key = derive_player_pub_key(disclose(player_secret_key()));
    
    assert(quest.player_pub_key == player_pub_key, "Player auth failed");

    const rng = (get_player_rng() as Vector<32, Uint<8>>);
    // TODO: check block height here
    const battle_config = BattleConfig {
        quest.level,
        bosses.lookup(quest.level),
        quest.player_pub_key,
        quest.loadout
    };
    const battle_id = derive_battle_id(battle_config);
    active_battle_states.insert(battle_id, init_battlestate(rng, battle_config));
    active_battle_configs.insert(battle_id, battle_config);

    quests.remove(disclose(quest_id));

    return some<Field>(battle_id);
}

export circuit start_new_battle(loadout: PlayerLoadout, level: Level): BattleConfig {
    verify_loadout(disclose(loadout));

    // Validate difficulty access - level 1 is always allowed, higher levels require previous boss completion
    if (disclose(level.difficulty) > 1) {
        const player_id = derive_player_pub_key(disclose(player_secret_key()));
        const prevLevel = disclose(level.difficulty) - 1;
        assert(player_boss_progress.lookup(player_id).member(disclose(level.biome)) &&
               player_boss_progress.lookup(player_id).lookup(disclose(level.biome)).member(prevLevel) &&
               player_boss_progress.lookup(player_id).lookup(disclose(level.biome)).lookup(prevLevel),
               "Must complete previous level boss to access this level");
    }

    const rng = (get_player_rng() as Vector<32, Uint<8>>);
    const player_pub_key = derive_player_pub_key(disclose(player_secret_key()));
    const battle = BattleConfig {
        disclose(level),
        get_random_enemy_config(rng[0], level),
        player_pub_key,
        disclose(loadout)
    };
    const battle_id = derive_battle_id(disclose(battle));
    active_battle_states.insert(disclose(battle_id), init_battlestate(rng, disclose(battle)));
    active_battle_configs.insert(disclose(battle_id), disclose(battle));

    return battle;
}

// is there a simple way to programatically do this more efficiently (circuit size)?
circuit random_deck_indices(rng: Uint<8>): Vector<3, Uint<32>> {
    const mod_6 = mod(rng, 6);
    if (mod_6 == 0) {
        return [0 as Uint<8>, 1 as Uint<8>, 2 as Uint<8>];
    } else if (mod_6 == 1) {
        return [0 as Uint<8>, 2 as Uint<8>, 1 as Uint<8>];
    } else if (mod_6 == 2) {
        return [1 as Uint<8>, 0 as Uint<8>, 2 as Uint<8>];
    } else if (mod_6 == 3) {
        return [1 as Uint<8>, 2 as Uint<8>, 0 as Uint<8>];
    } else if (mod_6 == 4) {
        return [2 as Uint<8>, 0 as Uint<8>, 1 as Uint<8>];
    }
    return [2 as Uint<8>, 1 as Uint<8>, 0 as Uint<8>];
}

export circuit init_battlestate(rng: Vector<32, Uint<8>>, battle: BattleConfig): BattleState {
    return BattleState {
        0,
        random_deck_indices(rng[1]),
        0,
        0,
        0,
        0,
        // this is to avoid division by 0
        mod(rng[2], (battle.enemies.stats[0].move_count + ((battle.enemies.count < 1) as Uint<1>)) as Uint<32>),
        mod(rng[3], (battle.enemies.stats[1].move_count + ((battle.enemies.count < 2) as Uint<1>)) as Uint<32>),
        mod(rng[4], (battle.enemies.stats[2].move_count + ((battle.enemies.count < 3) as Uint<1>)) as Uint<32>)
    };
}

// zk-Circuits can only handle indexing by constants but to handle how deck iteration works
// we need it to be dynamic, so we use this helper function
pure circuit index<T>(array: Vector<7, T>, i: Uint<32>): T {
    if (i == 0) {
        return array[0];
    }
    if (i == 1) {
        return array[1];
    }
    if (i == 2) {
        return array[2];
    }
    if (i == 3) {
        return array[3];
    }
    if (i == 4) {
        return array[4];
    }
    if (i == 5) {
        return array[5];
    }
    return array[6];
}

// pure circuit add_mod<#n>(start: Uint<0..n>, add: Uint<0..n>): Uint<0..n> {
//     if (start + add > n) {
//         return start + add - n;
//     }
//     return start + add;
// }

// computes (start + add) % n, ONLY when start + add < 2n (which for our indices is always true)
pure circuit add_mod(start: Uint<32>, add: Uint<32>, n: Uint<32>): Uint<32> {
    // Due to a bug in Compact the below doesn't work so we work around it with binary arithmetic
    // if (start + add >= n) {
    //     return (start + add - n) as Uint<32>;
    // }
    // return (start + add) as Uint<32>;
    return (start + add - (((start + add >= n) as Uint<1>) * n)) as Uint<32>;
}

export pure circuit boss_type_reward_factor(boss_type: BOSS_TYPE): Uint<8> {
    if (boss_type == BOSS_TYPE.miniboss) {
        return 1;
    } else if (boss_type == BOSS_TYPE.boss) {
        return 3;
    }
    return 0;
}

export pure circuit battle_gold_reward(reward_factor: Uint<32>, difficulty: Uint<32>): Uint<32> {
    return ((10 + reward_factor * 5) * difficulty * difficulty) as Uint<32>;
}

export circuit combat_round(battle_id: Field, ability_targets: Vector<3, Uint<0..2>>): Maybe<BattleRewards> {
    const player_pub_key = derive_player_pub_key(disclose(player_secret_key()));
    assert(player_pub_key == active_battle_configs.lookup(disclose(battle_id)).player_pub_key, "Player auth failed");
    const rng = get_player_rng() as Vector<32, Uint<8>>;
    const config = disclose(active_battle_configs.lookup(disclose(battle_id)));
    const loadout = config.loadout;
    const state = disclose(active_battle_states.lookup(disclose(battle_id)));
    const round_abilities = [
        all_abilities.lookup(index<Field>(loadout.abilities, state.deck_indices[0])),
        all_abilities.lookup(index<Field>(loadout.abilities, state.deck_indices[1])),
        all_abilities.lookup(index<Field>(loadout.abilities, state.deck_indices[2])),
    ];

    const result = combat_round_impl(disclose(battle_id), round_abilities, disclose(ability_targets));

    active_battle_states.insert(disclose(battle_id), result);
    if (result.damage_to_player >= 100) {
        active_battle_configs.remove(disclose(battle_id));
        active_battle_states.remove(disclose(battle_id));

        return some<BattleRewards>(BattleRewards {
            false,
            0,
            none<Field>()
        });
    } else if (result.damage_to_enemy_0 >= config.enemies.stats[0].hp && (config.enemies.count < 2 || result.damage_to_enemy_1 >= config.enemies.stats[1].hp) && (config.enemies.count < 3 || result.damage_to_enemy_2 >= config.enemies.stats[2].hp)) {
        return_loadout(loadout);

        const reward_factor = boss_type_reward_factor(config.enemies.stats[0].boss_type)
                            + boss_type_reward_factor(config.enemies.count >= 2 ? config.enemies.stats[1].boss_type : BOSS_TYPE.normal)
                            + boss_type_reward_factor(config.enemies.count >= 3 ? config.enemies.stats[2].boss_type : BOSS_TYPE.normal);
        const reward_ability_id = give_random_ability_if_applicable(reward_factor, config.level.difficulty, rng, player_pub_key);

        // Mark boss completion if this was a boss battle
        if (config.enemies.stats[0].boss_type == BOSS_TYPE.boss) {
            if (!player_boss_progress.lookup(player_pub_key).member(config.level.biome)) {
                player_boss_progress.lookup(player_pub_key).insertDefault(config.level.biome);
            }
            player_boss_progress.lookup(player_pub_key).lookup(config.level.biome).insert(config.level.difficulty, true);
        }

        const reward = BattleRewards {
            true,
            battle_gold_reward(reward_factor, config.level.difficulty),
            reward_ability_id
        };
        const player_stats = players.lookup(derive_player_pub_key(disclose(player_secret_key())));

        players.insert(derive_player_pub_key(disclose(player_secret_key())), add_player_rewards(player_stats, reward));
        active_battle_configs.remove(disclose(battle_id));
        active_battle_states.remove(disclose(battle_id));

        return some<BattleRewards>(reward);
    }
    return none<BattleRewards>();
}

circuit give_random_ability_if_applicable(reward_factor: Uint<32>, difficulty: Uint<32>, rng: Vector<32, Uint<8>>, player_pub_key: Field): Maybe<Field> {
    if (reward_factor == 0) {
        return none<Field>();
    }
    const reward_ability = random_ability(rng, (difficulty * reward_factor) as Uint<8>);
    const reward_ability_id = derive_ability_id(reward_ability);
    if (reward_factor > 0) {
        if (!all_abilities.member(reward_ability_id)) {
            all_abilities.insert(reward_ability_id, reward_ability);
        }
        player_add_ability(player_pub_key, reward_ability_id);
    }
    return some<Field>(reward_ability_id);
}

/**
 * Retreat from an active battle without penalty
 * Returns the loadout to the player and removes the battle from active battles
 */
export circuit retreat_from_battle(battle_id: Field): [] {
    const player_pub_key = derive_player_pub_key(disclose(player_secret_key()));
    assert(player_pub_key == active_battle_configs.lookup(disclose(battle_id)).player_pub_key, "Player auth failed");

    const config = disclose(active_battle_configs.lookup(disclose(battle_id)));

    // Return the loadout to the player
    return_loadout(config.loadout);

    // Remove battle config and state
    active_battle_configs.remove(disclose(battle_id));
    active_battle_states.remove(disclose(battle_id));
}


pure circuit add_player_rewards(player: Player, reward: BattleRewards): Player {
    return Player {
        (player.gold + reward.gold) as Uint<32>,
        player.rng
    };
}

pure circuit select_move(moves: Vector<3, EnemyMove>, move_index: Uint<32>): EnemyMove {
    if (move_index == 0) {
        return moves[0];
    } else if (move_index == 1) {
        return moves[1];
    }
    return moves[2];
}

circuit combat_round_impl(battle_id: Field, abilities: Vector<3, Ability>, ability_targets: Vector<3, Uint<0..2>>): BattleState {
    const battle = active_battle_configs.lookup(battle_id);
    const old_state = active_battle_states.lookup(battle_id);
    const enemy_moves = [
        select_move(battle.enemies.stats[0].moves, old_state.enemy_move_index_0),
        select_move(battle.enemies.stats[1].moves, old_state.enemy_move_index_1),
        select_move(battle.enemies.stats[2].moves, old_state.enemy_move_index_2)
    ];

    // See generate.js for an explanation of the code generation

    // CODE-GENERATION START

    INSERT_ENEMY_BLOCK_CODE_HERE

    INSERT_PLAYER_BLOCK_CODE_HERE

    INSERT_PLAYER_DAMAGE_CODE_HERE


    // we need to write these that way using boolean multiplication to avoid temporary underflow checks in non-executed branches
    // I'm not quite sure why since the simplest case e.g. a < b ? b - a : a - b on its own doesn't seem to break?
    const new_damage_to_enemy_0 = (old_state.damage_to_enemy_0 + ((enemy_block_0 < damage_to_enemy_0) as Uint<1>) * damage_to_enemy_0 - ((enemy_block_0 < damage_to_enemy_0) as Uint<1>) * enemy_block_0) as Uint<32>;
    const new_damage_to_enemy_1 = (old_state.damage_to_enemy_1 + ((enemy_block_1 < damage_to_enemy_1) as Uint<1>) * damage_to_enemy_1 - ((enemy_block_1 < damage_to_enemy_1) as Uint<1>) * enemy_block_1) as Uint<32>;
    const new_damage_to_enemy_2 = (old_state.damage_to_enemy_2 + ((enemy_block_2 < damage_to_enemy_2) as Uint<1>) * damage_to_enemy_2 - ((enemy_block_2 < damage_to_enemy_2) as Uint<1>) * enemy_block_2) as Uint<32>;


    INSERT_ENEMY_DAMAGE_CODE_HERE

    INSERT_ENEMY_HEAL_CODE_HERE

    INSERT_DECK_INDEX_CALCULATION_CODE_HERE

    // CODE-GENERATION END

    return BattleState {
        (old_state.round + 1) as Uint<32>,
        INSERT_DECK_INDEX_BATTLE_STATE_INIT_CODE_HERE,
        (old_state.damage_to_player + ((player_block < damage_to_player) as Uint<1>) * damage_to_player - ((player_block < damage_to_player) as Uint<1>) * player_block) as Uint<32>,
        new_damage_to_enemy_0 - (enemy_heal_0 > new_damage_to_enemy_0 ? new_damage_to_enemy_0 : enemy_heal_0),
        new_damage_to_enemy_1 - (enemy_heal_1 > new_damage_to_enemy_1 ? new_damage_to_enemy_1 : enemy_heal_1),
        new_damage_to_enemy_2 - (enemy_heal_2 > new_damage_to_enemy_2 ? new_damage_to_enemy_2 : enemy_heal_2),
        // TODO: randomize?
        add_mod(old_state.enemy_move_index_0, 1, battle.enemies.stats[0].move_count),
        add_mod(old_state.enemy_move_index_1, 1, battle.enemies.stats[1].move_count),
        add_mod(old_state.enemy_move_index_2, 1, battle.enemies.stats[2].move_count)
    };
}

// total damage (after resistances) done by an effect to an enemy
export pure circuit effect_damage(effect: Effect, stats: EnemyStats): Uint<32> {
    return ((((effect.effect_type == EFFECT_TYPE.attack_phys) as Uint<1>) * (4 - stats.physical_def) * effect.amount + ((effect.effect_type == EFFECT_TYPE.attack_fire) as Uint<1>) * (4 - stats.fire_def) * (effect.amount)) + ((effect.effect_type == EFFECT_TYPE.attack_ice) as Uint<1>) * (4 - stats.ice_def) * effect.amount) as Uint<32>;
}


// TODO: do we want to get rid of this entirely? is there non-per-player RNG?
// mock RNG functionality using an incrementing global nonce
// ledger mock_nonce: Uint<32>;
// struct MockHasher {
//     nonce: Uint<32>,
//     sk: Bytes<32>,
// }
// circuit get_rng(): Bytes<32> {
//     mock_nonce = (mock_nonce + 1 as Uint<32>);
//     return persistentHash<MockHasher>(MockHasher { mock_nonce, disclose(player_secret_key()) });
// }

circuit get_player_rng(): Bytes<32> {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    const old_player = players.lookup(player_id);
    const new_rng = persistentHash<Bytes<32>>(old_player.rng);
    players.insert(player_id, Player { old_player.gold, new_rng });
    return old_player.rng;
}

circuit get_random_enemy_config(rng: Uint<8>, level: Level): EnemiesConfig {
    const index = mod(rng, levels.lookup(level).size() as Uint<32>);
    return levels.lookup(level).lookup(index);
}


// ADMIN ONLY CODE AFTER THIS POINT

// player pub key of the person who deployed it. this authorizes them to add new levels/etc
sealed ledger deployer: Field;

export struct Level {
    // this is not an enum to allow for updating the game without the contract changing.
    biome: Uint<32>,
    difficulty: Uint<32>,
}

// configs for enemies in each level
export ledger levels: Map<Level, Map<Uint<64>, EnemiesConfig>>;

export ledger bosses: Map<Level, EnemiesConfig>;

export circuit admin_level_new(level: Level, boss: EnemiesConfig): [] {
    admin_verify();
    levels.insertDefault(disclose(level));
    bosses.insert(disclose(level), disclose(boss));
}

export circuit admin_level_add_config(level: Level, enemies: EnemiesConfig): [] {
    admin_verify();
    levels.lookup(level).insert(levels.lookup(level).size(), disclose(enemies));
}

circuit admin_verify(): [] {
    assert(derive_player_pub_key(disclose(player_secret_key())) == deployer, "Admin auth failed");
}
</another-example>
<grammar>
Compact Grammar
Compact language version 0.18.0.

Notational note: In the grammar productions below, ellipses are used to specify repetition. The notation X ... X, where X is a grammar symbol, represents zero or more occurrences of X. The notation X s ... s X, where X is a grammar symbol and s is a separator such as a comma or or semicolon, represents zero or more occurrences of X separated by s. In either case, when the ellipsis is marked with the superscript 1, the notation represents a sequence containing at least one X. When such a sequence is followed by sopt, an optional trailing separator is allowed, but only if there is at least one X. For example, id … id represents zero or more ids, and expr , …¹ , expr ,opt represents one or more comma-separated exprs possibly followed by an extra comma.

end-of-file (eof)
end of file

identifier (id, module-name, function-name, struct-name, enum-name, contract-name, tvar-name)
identifiers have the same syntax as Typescript identifiers

field-literal (nat)
a field literal is 0 or a natural number formed from a sequence of digits starting with 1-9, e.g. 723, whose value does not exceed the maximum field value

string-literal (str, file)
a string literal has the same syntax as a Typescript string

version-literal (version)
a version literal takes the form nat or nat.nat or nat.nat.nat, e.g., 1.2 or 1.2.3, representing major, minor, and bugfix versions

Compact (program)
program 	→	  pelt … pelt  eof
Program-element (pelt)
pelt 	→	  pragma
 	→	  incld
 	→	  mdefn
 	→	  idecl
 	→	  xdecl
 	→	  ldecl
 	→	  lconstructor
 	→	  cdefn
 	→	  edecl
 	→	  wdecl
 	→	  ecdecl
 	→	  struct
 	→	  enumdef
Pragma (pragma)
pragma 	→	  pragma  id  version-expr  ;
Version-expression (version-expr)
version-expr 	→	  version-expr  ||  version-expr0
 	→	  version-expr0
Version-expression0 (version-expr0)
version-expr0 	→	  version-expr0  &&  version-term
 	→	  version-term
Version-Term (version-term)
version-term 	→	  version-atom
 	→	  !  version-atom
 	→	  <  version-atom
 	→	  <=  version-atom
 	→	  >=  version-atom
 	→	  >  version-atom
 	→	  (  version-expr  )
Version-atom (version-atom)
version-atom 	→	  nat
 	→	  version
Include (incld)
incld 	→	  include  file  ;
Module-definition (mdefn)
mdefn 	→	  exportopt  module  module-name  gparamsopt  {  pelt … pelt  }
Generic-parameter-list (gparams)
gparams 	→	  <  generic-param , … , generic-param ,opt  >
Generic-parameter (generic-param)
generic-param 	→	  #  tvar-name
 	→	  tvar-name
Import-declaration (idecl)
idecl 	→	  import  import-name  gargsopt  import-prefixopt  ;
Import-name (import-name)
import-name 	→	  id
 	→	  file
Import-prefix (import-prefix)
import-prefix 	→	  prefix  id
Generic-argument-list (gargs)
gargs 	→	  <  garg , … , garg ,opt  >
Generic-argument (garg)
garg 	→	  nat
 	→	  type
Export-declaration (xdecl)
xdecl 	→	  export  {  id , … , id ,opt  }  ;opt
Ledger-declaration (ldecl)
ldecl 	→	  exportopt  sealedopt  ledger  id  :  type  ;
Constructor (lconstructor)
lconstructor 	→	  constructor  pattern-parameter-list  block
Circuit-definition (cdefn)
cdefn 	→	  exportopt  pureopt  circuit  function-name  gparamsopt  pattern-parameter-list  :  type  block
External-declaration (edecl)
edecl 	→	  exportopt  circuit  id  gparamsopt  simple-parameter-list  :  type  ;
Witness-declaration (wdecl)
wdecl 	→	  exportopt  witness  id  gparamsopt  simple-parameter-list  :  type  ;
External-contract-declaration (ecdecl)
ecdecl 	→	  exportopt  contract  contract-name  {  ecdecl-circuit ; … ; ecdecl-circuit ;opt  }  ;opt
 	→	  exportopt  contract  contract-name  {  ecdecl-circuit , … , ecdecl-circuit ,opt  }  ;opt
External-contract-circuit (ecdecl-circuit)
ecdecl-circuit 	→	  pureopt  circuit  id  simple-parameter-list  :  type
Structure-definition (struct)
struct 	→	  exportopt  struct  struct-name  gparamsopt  {  typed-identifier ; … ; typed-identifier ;opt  }  ;opt
 	→	  exportopt  struct  struct-name  gparamsopt  {  typed-identifier , … , typed-identifier ,opt  }  ;opt
Enum-definition (enumdef)
enumdef 	→	  exportopt  enum  enum-name  {  id , …¹ , id ,opt  }  ;opt
Typed-identifier (typed-identifier)
typed-identifier 	→	  id  :  type
Simple-parameter-list (simple-parameter-list)
simple-parameter-list 	→	  (  typed-identifier , … , typed-identifier ,opt  )
Typed-pattern (typed-pattern)
typed-pattern 	→	  pattern  :  type
Pattern-parameter-list (pattern-parameter-list)
pattern-parameter-list 	→	  (  typed-pattern , … , typed-pattern ,opt  )
Type (type)
type 	→	  tref
 	→	  Boolean
 	→	  Field
 	→	  Uint  <  tsize  >
 	→	  Uint  <  tsize  ..  tsize  >
 	→	  Bytes  <  tsize  >
 	→	  Opaque  <  str  >
 	→	  Vector  <  tsize  ,  type  >
 	→	  [  type , … , type ,opt  ]
Type-reference (tref)
tref 	→	  id  gargsopt
Type-size (tsize)
tsize 	→	  nat
 	→	  id
Block (block)
block 	→	  {  stmt … stmt  }
Statement (stmt)
stmt 	→	  expr-seq  ;
 	→	  return  expr-seq  ;
 	→	  return  ;
 	→	  if  (  expr-seq  )  stmt  else  stmt
 	→	  if  (  expr-seq  )  stmt
 	→	  for  (  const  id  of  nat  ..  nat  )  stmt
 	→	  for  (  const  id  of  expr-seq  )  stmt
 	→	  const  cbinding , …¹ , cbinding   ;
 	→	  block
Pattern (pattern)
pattern 	→	  id
 	→	  [  patternopt , … , patternopt ,opt  ]
 	→	  {  pattern-struct-elt , … , pattern-struct-elt ,opt  }
Pattern-tuple-element (pattern-tuple-elt)
pattern-tuple-elt 	→	  (empty)
 	→	  pattern
Pattern-struct-element (pattern-struct-elt)
pattern-struct-elt 	→	  id
 	→	  id  :  pattern
Expression-sequence (expr-seq)
expr-seq 	→	  expr
 	→	  expr , …¹ , expr   ,  expr
Expression (expr)
expr 	→	  expr0  ?  expr  :  expr
 	→	  expr0  =  expr
 	→	  expr0  +=  expr
 	→	  expr0  -=  expr
 	→	  expr0
Expression0 (expr0)
expr0 	→	  expr0  ||  expr1
 	→	  expr1
Expression1 (expr1)
expr1 	→	  expr1  &&  expr2
 	→	  expr2
Expression2 (expr2)
expr2 	→	  expr2  ==  expr3
 	→	  expr2  !=  expr3
 	→	  expr3
Expression3 (expr3)
expr3 	→	  expr4  <  expr4
 	→	  expr4  <=  expr4
 	→	  expr4  >=  expr4
 	→	  expr4  >  expr4
 	→	  expr4
Expression4 (expr4)
expr4 	→	  expr4  as  type
 	→	  expr5
Expression5 (expr5)
expr5 	→	  expr5  +  expr6
 	→	  expr5  -  expr6
 	→	  expr6
Expression6 (expr6)
expr6 	→	  expr6  *  expr7
 	→	  expr7
Expression7 (expr7)
expr7 	→	  !  expr7
 	→	  expr8
Expression8 (expr8)
expr8 	→	  expr8  [  expr  ]
 	→	  expr8  .  id
 	→	  expr8  .  id  (  expr , … , expr ,opt  )
 	→	  expr9
Expression9 (expr9)
expr9 	→	  fun  (  expr , … , expr ,opt  )
 	→	  map  (  fun  ,  expr , …¹ , expr ,opt  )
 	→	  fold  (  fun  ,  expr  ,  expr , …¹ , expr ,opt  )
 	→	  slice  <  tsize  >  (  expr  ,  expr  )
 	→	  [  tuple-arg , … , tuple-arg ,opt  ]
 	→	  Bytes  [  bytes-arg , … , bytes-arg ,opt  ]
 	→	  tref  {  struct-arg , … , struct-arg ,opt  }
 	→	  assert  (  expr  ,  str  )
 	→	  disclose  (  expr  )
 	→	  term
Term (term)
term 	→	  id
 	→	  true
 	→	  false
 	→	  nat
 	→	  str
 	→	  pad  (  nat  ,  str  )
 	→	  default  <  type  >
 	→	  (  expr-seq  )
Tuple-argument (tuple-arg, bytes-arg)
tuple-arg 	→	  expr
 	→	  ...  expr
Structure-argument (struct-arg)
struct-arg 	→	  expr
 	→	  id  :  expr
 	→	  ...  expr
Function (fun)
fun 	→	  id  gargsopt
 	→	  arrow-parameter-list  return-typeopt  =>  block
 	→	  arrow-parameter-list  return-typeopt  =>  expr
 	→	  (  fun  )
Return-type (return-type)
return-type 	→	  :  type
Optionally-typed-pattern (optionally-typed-pattern)
optionally-typed-pattern 	→	  pattern
 	→	  typed-pattern
Const-Binding (cbinding)
cbinding 	→	  optionally-typed-pattern  =  expr
Arrow-parameter-list (arrow-parameter-list)
arrow-parameter-list 	→	  (  optionally-typed-pattern , … , optionally-typed-pattern ,opt  )
</grammar>
</data-type>
Ledger data types
Compact language version 0.18.0, compiler version 0.26.0.

Kernel
This ADT is a special ADT defining various built-in operations and valid only as a top-level ADT type.

blockTimeGreaterThan
blockTimeGreaterThan(time: Uint<64>): Boolean

Checks whether the current block time (measured in seconds since the Unix epoch) is greater than the given amount.

blockTimeLessThan
blockTimeLessThan(time: Uint<64>): Boolean

Checks whether the current block time (measured in seconds since the Unix epoch) is less than the given amount.

checkpoint
checkpoint(): []

Marks all execution up to this point as being a single atomic unit, allowing partial transaction failures to be split across it.

claimContractCall
claimContractCall(addr: Bytes<32>, entry_point: Bytes<32>, comm: Field): []

Require the presence of another contract call in the containing transaction, with a match address, entry point hash, and communication commitment, that is not claimed by any other call.

claimZswapCoinReceive
claimZswapCoinReceive(note: Bytes<32>): []

Requires the presence of a commitment in the containing transaction and that no other call claims it as a receive.

claimZswapCoinSpend
claimZswapCoinSpend(note: Bytes<32>): []

Requires the presence of a commitment in the containing transaction and that no other call claims it as a spend.

claimZswapNullifier
claimZswapNullifier(nul: Bytes<32>): []

Requires the presence of a nullifier in the containing transaction and that no other call claims it.

mint
mint(domain_sep: Bytes<32>, amount: Uint<64>): []

Mints a given amount of shielded coins with a token type derived from the contract's address, and a given domain separator.

self
self(): ContractAddress

Returns the current contract's address. ContractAddress is defined in CompactStandardLibrary.

Cell<value_type>
This ADT is a single Cell containing a value of type value_type and is used implicitly when the ledger field type is an ordinary Compact type. Programmers cannot write Cell explicitly when declaring a ledger field..

read
read(): value_type

Returns the current contents of this Cell.

available from Typescript as a getter on the ledger field

resetToDefault
resetToDefault(): []

Resets this Cell to the default value of its type.

write
write(value: value_type): []

Overwrites the content of this Cell with the given value.

writeCoin
writeCoin(coin: CoinInfo, recipient: Either<ZswapCoinPublicKey, ContractAddress>): []

Writes a CoinInfo to this Cell, which is transformed into a QualifiedCoinInfo at runtime by looking up the relevant Merkle tree index. This index must have been allocated within the current transaction or this write fails. CoinInfo, ContractAddress, Either, and ZswapCoinPublicKey are defined in CompactStandardLibrary.

available only for QualifiedCoinInfo value_type

Counter
This ADT is a simple counter.

decrement
decrement(amount: Uint<16>): []

Decrements the counter by a given amount. Decrementing below zero results in a run-time error.

increment
increment(amount: Uint<16>): []

Increments the counter by the given amount.

lessThan
lessThan(threshold: Uint<64>): Boolean

Returns if the counter is less than the given threshold value.

read
read(): Uint<64>

Retrieves the current value of the counter.

available from Typescript as a getter on the ledger field

resetToDefault
resetToDefault(): []

Resets this Counter to its default value of 0.

Set<value_type>
This ADT is an unbounded set of values of type value_type.

insert
insert(elem: value_type): []

Updates this Set to include a given element.

insertCoin
insertCoin(coin: CoinInfo, recipient: Either<ZswapCoinPublicKey, ContractAddress>): []

Inserts a CoinInfo into this Set, which is transformed into a QualifiedCoinInfo at runtime by looking up the relevant Merkle tree index. This index must have been allocated within the current transaction or this insertion fails. CoinInfo, ContractAddress, Either, and ZswapCoinPublicKey are defined in CompactStandardLibrary.

available only for QualifiedCoinInfo value_type

isEmpty
isEmpty(): Boolean

Returns whether this Set is the empty set.

available from Typescript as isEmpty(): boolean

member
member(elem: value_type): Boolean

Returns if an element is contained within this Set.

available from Typescript as member(elem: value_type): boolean

remove
remove(elem: value_type): []

Update this Set to not include a given element.

resetToDefault
resetToDefault(): []

Resets this Set to the empty set.

size
size(): Uint<64>

Returns the number of unique entries in this Set.

available from Typescript as size(): bigint

[Symbol.iterator]
callable only from TypeScript

[Symbol.iterator](): Iterator<value_type>

Iterates over the entries in this Set.

Map<key_type, value_type>
This ADT is an unbounded set of mappings between values of type key_type and values of type value_type.

insert
insert(key: key_type, value: value_type): []

Updates this Map to include a new value at a given key.

insertCoin
insertCoin(key: key_type, coin: CoinInfo, recipient: Either<ZswapCoinPublicKey, ContractAddress>): []

Inserts a CoinInfo into this Map at a given key, where the CoinInfo is transformed into a QualifiedCoinInfo at runtime by looking up the relevant Merkle tree index. This index must have been allocated within the current transaction or this insertion fails. CoinInfo, ContractAddress, Either, and ZswapCoinPublicKey are defined in CompactStandardLibrary.

available only for QualifiedCoinInfo value_type

insertDefault
insertDefault(key: key_type): []

Updates this Map to include the value type's default value at a given key.

isEmpty
isEmpty(): Boolean

Returns if this Map is the empty map.

available from Typescript as isEmpty(): boolean

lookup
lookup(key: key_type): value_type

Looks up the value of a key within this Map. The returned value may be another ADT.

available from Typescript as lookup(key: key_type): value_type

member
member(key: key_type): Boolean

Returns if a key is contained within this Map.

available from Typescript as member(key: key_type): boolean

remove
remove(key: key_type): []

Updates this Map to not include a given key.

resetToDefault
resetToDefault(): []

Resets this Map to the empty map.

size
size(): Uint<64>

Returns the number of entries in this Map.

available from Typescript as size(): bigint

[Symbol.iterator]
callable only from TypeScript

[Symbol.iterator](): Iterator<[key_type, value_type]>

Iterates over the key-value pairs contained in this Map.

List<value_type>
This ADT is an unbounded list of values of type value_type.

head
head(): Maybe<value_type>

Retrieves the head of this List, returning a Maybe, ensuring this call succeeds on the empty list. Maybe is defined in CompactStandardLibrary (compact-runtime runtime.ts from Typescript).

available from Typescript as head(): Maybe<value_type>

isEmpty
isEmpty(): Boolean

Returns if this List is the empty list.

available from Typescript as isEmpty(): boolean

length
length(): Uint<64>

Returns the number of elements contained in this List.

available from Typescript as length(): bigint

popFront
popFront(): []

Removes the first element from the front of this list.

pushFront
pushFront(value: value_type): []

Pushes a new element onto the front of this list.

pushFrontCoin
pushFrontCoin(coin: CoinInfo, recipient: Either<ZswapCoinPublicKey, ContractAddress>): []

Pushes a CoinInfo onto the front of this List, where the CoinInfo is transformed into a QualifiedCoinInfo at runtime by looking up the relevant Merkle tree index. This index must have been allocated within the current transaction or this push fails. CoinInfo, ContractAddress, Either, and ZswapCoinPublicKey are defined in CompactStandardLibrary.

available only for QualifiedCoinInfo value_type

resetToDefault
resetToDefault(): []

Resets this List to the empty list.

[Symbol.iterator]
callable only from TypeScript

[Symbol.iterator](): Iterator<value_type>

Iterates over the entries in this List.

MerkleTree<nat, value_type>
This ADT is a bounded Merkle tree of depth nat containing values of type value_type.

checkRoot
checkRoot(rt: MerkleTreeDigest): Boolean

Tests if the given Merkle tree root is the root for this Merkle tree. MerkleTreeDigest is defined in CompactStandardLibrary (compact-runtime runtime.ts from Typescript).

available from Typescript as checkRoot(rt: MerkleTreeDigest): boolean

insert
insert(item: value_type): []

Inserts a new leaf at the first free index in this Merkle tree.

insertHash
insertHash(hash: Bytes<32>): []

Inserts a new leaf with a given hash at the first free index in this Merkle tree.

insertHashIndex
insertHashIndex(hash: Bytes<32>, index: Uint<64>): []

Inserts a new leaf with a given hash at a specific index in this Merkle tree.

insertIndex
insertIndex(item: value_type, index: Uint<64>): []

Inserts a new leaf at a specific index in this Merkle tree.

insertIndexDefault
insertIndexDefault(index: Uint<64>): []

Inserts a default value leaf at a specific index in this Merkle tree. This can be used to emulate a removal from the tree.

isFull
isFull(): Boolean

Returns if this Merkle tree is full and further items cannot be directly inserted.

available from Typescript as isFull(): boolean

resetToDefault
resetToDefault(): []

Resets this Merkle tree to the empty Merkle tree.

findPathForLeaf
callable only from TypeScript

findPathForLeaf(leaf: value_type): MerkleTreePath<value_type> | undefined

Finds the path for a given leaf in a Merkle tree. Be warned that this is O(n) and should be avoided for large trees. Returns undefined if no such leaf exists. MerkleTreePath is defined in compact-runtime runtime.ts.

firstFree
callable only from TypeScript

firstFree(): bigint

Retrieves the first (guaranteed) free index in the Merkle tree.

pathForLeaf
callable only from TypeScript

pathForLeaf(index: bigint, leaf: value_type): MerkleTreePath<value_type>

Returns the Merkle path, given the knowledge that a specified leaf is at the given index. It is an error to call this if this leaf is not contained at the given index. MerkleTreePath is defined in compact-runtime runtime.ts.

root
callable only from TypeScript

root(): MerkleTreeDigest

Retrieves the root of the Merkle tree. MerkleTreeDigest is defined in compact-runtime runtime.ts.

HistoricMerkleTree<nat, value_type>
This ADT is a bounded Merkle tree of depth nat containing values of type value_type, with history.

checkRoot
checkRoot(rt: MerkleTreeDigest): Boolean

Tests if the given Merkle tree root is one of the past roots for this Merkle tree. MerkleTreeDigest is defined in CompactStandardLibrary (compact-runtime runtime.ts from Typescript).

available from Typescript as checkRoot(rt: MerkleTreeDigest): boolean

insert
insert(item: value_type): []

Inserts a new leaf at the first free index in this Merkle tree.

insertHash
insertHash(hash: Bytes<32>): []

Inserts a new leaf with a given hash at the first free index in this Merkle tree.

insertHashIndex
insertHashIndex(hash: Bytes<32>, index: Uint<64>): []

Inserts a new leaf with a given hash at a specific index in this Merkle tree.

insertIndex
insertIndex(item: value_type, index: Uint<64>): []

Inserts a new leaf at a specific index in this Merkle tree.

insertIndexDefault
insertIndexDefault(index: Uint<64>): []

Inserts a default value leaf at a specific index in this Merkle tree. This can be used to emulate a removal from the tree.

isFull
isFull(): Boolean

Returns if this Merkle tree is full and further items cannot be directly inserted.

available from Typescript as isFull(): boolean

resetHistory
resetHistory(): []

Resets the history for this Merkle tree, leaving only the current root valid.

resetToDefault
resetToDefault(): []

Resets this Merkle tree to the empty Merkle tree.

findPathForLeaf
callable only from TypeScript

findPathForLeaf(leaf: value_type): MerkleTreePath<value_type> | undefined

Finds the path for a given leaf in a Merkle tree. Be warned that this is O(n) and should be avoided for large trees. Returns undefined if no such leaf exists. MerkleTreePath is defined in compact-runtime runtime.ts.

firstFree
callable only from TypeScript

firstFree(): bigint

Retrieves the first (guaranteed) free index in the Merkle tree.

history
callable only from TypeScript

history(): Iterator<MerkleTreeDigest>

An iterator over the roots that are considered valid past roots for this Merkle tree. MerkleTreeDigest is defined in compact-runtime runtime.ts.

pathForLeaf
callable only from TypeScript

pathForLeaf(index: bigint, leaf: value_type): MerkleTreePath<value_type>

Returns the Merkle path, given the knowledge that a specified leaf is at the given index. It is an error to call this if this leaf is not contained at the given index. MerkleTreePath is defined in compact-runtime runtime.ts.

root
callable only from TypeScript

root(): MerkleTreeDigest

Retrieves the root of the Merkle tree. MerkleTreeDigest is defined in compact-runtime runtime.ts.
</data-types>
<compact-std-api>
# Detailed API reference

## Structs

### `Maybe`

Encapsulates an optionally present value. If `isSome` is `false`, `value`
should be `default<T>` by convention.

```compact
struct Maybe<T> {
  isSome: Boolean;
  value: T;
}
```

### `Either`

Disjoint union of `A` and `B`. Iff `isLeft` if `true`, `left` should be
populated, otherwise `right`. The other should be `default< >` by convention.

```compact
struct Either<A, B> {
  isLeft: Boolean;
  left: A;
  right: B;
}
```

### `CurvePoint`

A point on the proof systems embedded curve, in affine coordinates.

Only outputs of elliptic curve operations are actually guaranteed to lie on the
curve.

```compact
struct CurvePoint {
  x: Field;
  y: Field;
}
```

### `MerkleTreeDigest`

The root hash of a Merkle tree, represented by a single `Field`.

```compact
struct MerkleTreeDigest { field: Field; }
```

### `MerkleTreePathEntry`

An entry in a Merkle tree path, indicating if the path leads left or right, and
the root of the sibling node. Primarily used in [`MerkleTreePath`](#merkletreepath)

```compact
struct MerkleTreePathEntry {
  sibling: MerkleTreeDigest;
  goesLeft: Boolean;
}
```

### `MerkleTreePath`

A path in a depth `n` Merkle tree, leading to a leaf of type `T`.
Primarily used for [`merkleTreePathRoot`](#merkletreepathroot).

This can be constructed from `witness`es that use the compiler output's
`findPathForLeaf` and `pathForLeaf` functions.

```compact
struct MerkleTreePath<#n, T> {
  leaf: T;
  path: Vector<n, MerkleTreePathEntry>;
}
```

### `ContractAddress`

The address of a contract, used as a recipient in [`send`](#send),
[`sendImmediate`](#sendimmediate),
[`createZswapOutput`](#createzswapoutput), and [`mintToken`](#minttoken).

```compact
struct ContractAddress { bytes: Bytes<32>; }
```

### `CoinInfo`

The description of a newly created shielded coin, used in outputting shielded coins, or
spending/receiving shielded coins that originate in the current transaction.

`nonce` can be deterministically derived with [`evolveNonce`](#evolvenonce).

Used in:
- [`receive`](#receive)
- [`sendImmediate`](#sendimmediate)
- [`mergeCoin`](#mergecoin)
- [`mergeCoinImmediate`](#mergecoinimmediate)
- [`createZswapOutput`](#createzswapoutput)

```compact
struct CoinInfo {
  nonce: Bytes<32>;
  color: Bytes<32>;
  value: Uint<128>;
}
```

### `QualifiedCoinInfo`

The description of an existing shielded coin in the ledger, ready to be spent.

Used in:
- [`send`](#send)
- [`mergeCoin`](#mergecoin)
- [`mergeCoinImmediate`](#mergecoinimmediate)
- [`createZswapInput`](#createzswapinput)

```compact
struct QualifiedCoinInfo {
  nonce: Bytes<32>;
  color: Bytes<32>;
  value: Uint<128>;
  mtIndex: Uint<64>;
}
```

### `ZswapCoinPublicKey`

The public key used to output a [`CoinInfo`](#coininfo) to a user, used as a
recipient in [`send`](#send), [`sendImmediate`](#sendimmediate), and
[`createZswapOutput`](#createzswapoutput).

```compact
struct ZswapCoinPublicKey { bytes: Bytes<32>; }
```

### `SendResult`

The output of [`send`](#send) and [`sendImmediate`](#sendimmediate),
detailing the created shielded coin, and the change from spending the input, if
applicable.

```compact
struct SendResult {
  change: Maybe<CoinInfo>;
  sent: CoinInfo;
}
```

## Circuits

### `some`

Constructs a [`Maybe<T>`](#maybe) containing an element of type `T`

```compact
circuit some<T>(value: T): Maybe<T>;
```

### `none`

Constructs a [`Maybe<T>`](#maybe) containing nothing

```compact
circuit none<T>(): Maybe<T>;
```

### `left`

Construct an [`Either<A, B>`](#either) containing the `A` item of the disjoint
union

```compact
circuit left<A, B>(value: A): Either<A, B>;
```

### `right`

Constructs an [`Either<A, B>`](#either) containing the `B` item of the disjoint
union

```compact
circuit right<A, B>(value: B): Either<A, B>;
```

### `transientHash`

Builtin transient hash compression function

This function is a circuit-efficient compression function from arbitrary values
to field elements, which is not guaranteed to persist between upgrades. It
should not be used to derive state data, but can be used for consistency
checks.

Although this function returns a hash of its inputs, it is not considered sufficient
to protect its input from disclosure.
If its input contains any value returned from a witness, the program must acknowledge
disclosure (via a `disclose` wrapper) if the result can be stored in the public ledger,
returned from an exported circuit, or passed to another contract via a cross-contract call.

```compact
circuit transientHash<T>(value: T): Field;
```

### `transientCommit`

Builtin transient commitment function

This function is a circuit-efficient commitment function over arbitrary
types, and a field element commitment opening, to field elements, which is not
guaranteed to persist between upgrades. It should not be used to derive state
data, but can be used for consistency checks.

Unlike `transientHash`, this function is considered sufficient to protect
its input from disclosure, under the assumption that the `rand` argument is
sufficiently random.
Thus, even if its input contains a value or values returned from one or more
witnesses, the program need not acknowledge disclosure (via a `disclose` wrapper) if
the result can be stored in the public ledger, returned from an exported circuit, or
passed to another contract via a cross-contract call.

```compact
circuit transientCommit<T>(value: T, rand: Field): Field;
```

### `persistentHash`

Builtin persistent hash compression function

This function is a non-circuit-optimised compression function from arbitrary values
to a 256-bit bytestring. It is guaranteed to persist between
upgrades, and to consistently use the SHA-256 compression algorithm. It
*should* be used to derive state data, and not for consistency checks where
avoidable.

The note about disclosing under `transientHash` also applies to this function.

```compact
circuit persistentHash<T>(value: T): Bytes<32>;
```

### `persistentCommit`

Builtin persistent commitment function

This function is a non-circuit-optimised commitment function from arbitrary
values representable in Compact, and a 256-bit bytestring opening, to a 256-bit
bytestring. It is guaranteed to persist between upgrades, and use the SHA-256
compression algorithm. It *should* be used to derive state data, and not for
consistency checks where avoidable.

The note about disclosing under `transientCommit` also applies to this function.

```compact
circuit persistentCommit<T>(value: T, rand: Bytes<32>): Bytes<32>;
```

### `degradeToTransient`

This function "degrades" the output of a [`persistentHash`](#persistenthash)
or [`persistentCommit`](#persistentcommit) to a field element, which can then
be used in [`transientHash`](#transienthash) or
[`transientCommit`](#transientcommit).

```compact
circuit degradeToTransient(x: Bytes<32>) : Field;
```

### `upgradeFromTransient`
This function "upgrades" a field element to the output of a
[`persistentHash`](#persistenthash) or [`persistentCommit`](#persistentcommit).

```compact
circuit upgradeFromTransient(x: Field): Bytes<32>;

```

### `ecAdd`

This function add two elliptic [`CurvePoint`](#curvepoint)s (in multiplicative
notation)

```compact
circuit ecAdd(a: CurvePoint, b: CurvePoint): CurvePoint;
```

### `ecMul`

This function multiplies an elliptic [`CurvePoint`](#curvepoint) by a scalar
(in multiplicative notation)

```compact
circuit std_ecMul(a: CurvePoint, b: Field): CurvePoint;
```

### `ecMulGenerator`

This function multiplies the primary group generator of the embedded curve
by a scalar (in multiplicative notation)

```compact
circuit std_ecMulGenerator(b: Field): CurvePoint;
```

### `hashToCurve`

This function maps arbitrary types to [`CurvePoint`](#curvepoint)s.

Outputs are guaranteed to have unknown discrete logarithm with respect to
the group base, and any other output, but are not guaranteed to be unique (a
given input can be proven correct for multiple outputs).

Inputs of different types `T` may have the same output, if they have the same
field-aligned binary representation.

```compact
circuit hashToCurve<T>(value: T): CurvePoint;
```

### `merkleTreePathRoot`

Derives the Merkle tree root of a [`MerkleTreePath`](#merkletreepath), which
should match the root of the tree that this path originated from.

```compact
circuit merkleTreePathRoot<#n, T>(path: MerkleTreePath<n, T>): MerkleTreeDigest;
```

### `merkleTreePathRootNoLeafHash`

Derives the Merkle tree root of a [`MerkleTreePath`](#merkletreepath), which
should match the root of the tree that this path originated from. As opposed to
[`merkleTreePathRoot`](#merkletreepathroot), this variant assumes that
the tree leaves have already been hashed externally.

```compact
circuit merkleTreePathRootNoLeafHash<#n>(path: MerkleTreePath<n, Bytes<32>>): MerkleTreeDigest;
```

### `nativeToken`

Returns the token type of the native token

```compact
circuit nativeToken(): Bytes<32>;
```

### `tokenType`

Transforms a domain separator for the given contract into a globally namespaced
token type. A contract can issue tokens for its domain separators, which lets
it create new tokens, but due to collision resistance, it cannot mint tokens
for another contract's token type. This is used as the `color` field in 
[`CoinInfo`](#coininfo).

```compact
circuit tokenType(domainSep: Bytes<32>, contract: ContractAddress): Bytes<32>;
```

### `mintToken`

Creates a new shielded coin, minted by this contract, and sends it to the given
recipient. Returns the corresponding [`CoinInfo`](#coininfo). This requires
inputting a unique nonce to function securely, it is left to the user how to
produce this.

```compact
circuit mintToken(
  domainSep: Bytes<32>,
  value: Uint<128>,
  nonce: Bytes<32>,
  recipient: Either<ZswapCoinPublicKey, ContractAddress>
): CoinInfo;
```

### `evolveNonce`

Deterministically derives a [`CoinInfo`](#coininfo) nonce from a counter index,
and a prior nonce.

```compact
circuit evolveNonce(
  index: Uint<64>,
  nonce: Bytes<32>
): Bytes<32>;
```

### `burnAddress`

Returns a payment address that guarantees any shielded coins sent to it are burned.

```compact
circuit burnAddress(): Either<ZswapCoinPublicKey, ContractAddress>;
```

### `receive`

Receives a shielded coin, adding a validation condition requiring this coin to be
present as an output addressed to this contract, and not received by another
call

```compact
circuit receive(coin: CoinInfo): [];
```

### `send`

Sends given value from a shielded coin owned by the contract to a recipient. Any change
is returned and should be managed by the contract.

Note that this does not currently create coin ciphertexts, so sending to a user
public key except for the current user will not lead to this user being
informed of the coin they've been sent.

```compact
circuit send(input: QualifiedCoinInfo, recipient: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>): SendResult;
```

### `sendImmediate`

Like [`send`](#send), but for coins created within this transaction

```compact
circuit sendImmediate(input: CoinInfo, target: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>): SendResult;
```

### `mergeCoin`

Takes two coins stored on the ledger, and combines them into one

```compact
circuit mergeCoin(a: QualifiedCoinInfo, b: QualifiedCoinInfo): CoinInfo;
```

### `mergeCoinImmediate`

Takes one coin stored on the ledger, and one created within this transaction,
and combines them into one

```compact
circuit mergeCoinImmediate(a: QualifiedCoinInfo, b: CoinInfo): CoinInfo;
```

### `ownPublicKey`

Returns the [`ZswapCoinPublicKey`](#zswapcoinpublickey) of the end-user
creating this transaction.

```compact
circuit ownPublicKey(): ZswapCoinPublicKey;
```

### `createZswapInput`

Notifies the context to create a new Zswap input originating from this call.
Should typically not be called manually, prefer [`send`](#send) and
[`sendImmediate`](#sendimmediate) instead.

The note about disclosing under `transientHash` also applies to this function.

```compact
circuit createZswapInput(coin: QualifiedCoinInfo): [];
```

### `createZswapOutput`

Notifies the context to create a new Zswap output originating from this call.
Should typically not be called manually, prefer [`send`](#send) and
[`sendImmediate`](#sendimmediate), and [`receive`](#receive)instead.

The note about disclosing under `transientHash` also applies to this function.

```compact
circuit createZswapOutput(coin: CoinInfo, recipient: Either<ZswapCoinPublicKey, ContractAddress>): [];
```

### `blockTimeLt`

Returns true if the current block time is less than the given value.

```compact
circuit blockTimeLt(time: Uint<64>): Boolean;
```

### `blockTimeGte`

Returns true if the current block time is greater than or equal to the given value.

```compact
circuit blockTimeGte(time: Uint<64>): Boolean;
```

### `blockTimeGt`

Returns true if the current block time is greater than the given value.

```compact
circuit blockTimeGt(time: Uint<64>): Boolean;
```

### `blockTimeLte`

Returns true if the current block time is less than or equal to the given value.

```compact
circuit blockTimeLte(time: Uint<64>): Boolean;
```
</compact-std-api>
<notes>
prefer importing as: import CompactStandardLibrary prefix std_;
and using: std_ownPublicKey();

current pragma: pragma language_version >= 0.19;

</notes>