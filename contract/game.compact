pragma language_version >= 0.19.0;

// ============================================
// GO FISH GAME CONTRACT
// ============================================
// 
// SECURITY MODEL:
// This contract enforces all game rules cryptographically. Players cannot
// cheat because every action is validated by zero-knowledge proofs.
//
// EXPORTED (PUBLIC) METHODS:
//   Setup:     applyMask, dealCards
//   Gameplay:  askForCardAndProcess, goFish, afterGoFish, switchTurn
//   Scoring:   checkAndScoreBook, checkAndEndGame  
//   Queries:   getGamePhase, getCurrentTurn, getScores, getHandSizes, etc.
//
// INTERNAL METHODS (not callable externally):
//   getTopCardForOpponent, transferAllCardsOfRank, transferCardOfRank,
//   moveCardFromPlayerToPlayerCardInHand, dealCard, countCardsOfRank
//
// GAME RULES ENFORCED BY THIS CONTRACT:
//
// 1. SETUP RULES:
//    - Both players must apply their mask before dealing (applyMask)
//    - Each player can only apply their mask once
//    - Dealing only happens after both masks are applied (dealCards)
//
// 2. TURN RULES:
//    - Only the current player can perform actions on their turn
//    - Turn is tracked by go_fish_currentTurn (1 or 2)
//    - Players must provide their playerId which is validated
//
// 3. ASKING RULES (askForCardAndProcess):
//    - Can only ask during TurnStart phase
//    - Must be the asking player's turn
//    - MUST have at least one card of the rank being asked for
//    - Valid ranks are 0-12 (A through K)
//    - Contract verifies opponent's hand and transfers cards automatically
//
// 4. DRAWING RULES (goFish):
//    - Can only draw during WaitForDraw phase
//    - Must be the current player drawing
//    - Deck must not be empty
//
// 5. DRAW VERIFICATION (afterGoFish):
//    - Must be in WaitForDrawCheck phase
//    - Only current player can call
//    - If claiming drew requested card, contract verifies player has that rank
//
// 6. PHASE FLOW:
//    Setup -> TurnStart (via dealCards, after both masks applied)
//    TurnStart -> WaitForDraw (via askForCardAndProcess, if opponent has no cards)
//    TurnStart -> TurnStart (via askForCardAndProcess, if opponent had cards)
//    WaitForDraw -> WaitForDrawCheck (via goFish)
//    WaitForDrawCheck -> TurnStart (via afterGoFish, same player if drew asked rank)
//    WaitForDrawCheck -> TurnStart (via afterGoFish, switch turn if didn't)
//    Any -> GameOver (when all 13 books scored or deck empty + hand empty)
//
// 7. BOOK RULES:
//    - Can score a book when player has all 4 cards of a rank
//    - Cards are removed from hand and score is incremented
//    - Cannot score during Setup or after GameOver
//
// ============================================

import CompactStandardLibrary;
import CompactStandardLibrary prefix std_;

import './Deck' prefix deck_;
import './Hand' prefix hand_p1_;
import './Hand' prefix hand_p2_;
import './GoFish' prefix go_fish_;

constructor() {
    deck_init_deck();
    go_fish_init_game();
    hand_p1_init_hand();
    hand_p2_init_hand();
}

// ============================================
// SETUP PHASE CIRCUITS
// ============================================

// Deal 7 cards to each player and start the game
// RULE: Must be in Setup phase
// RULE: Both players must have applied their masks first
export circuit dealCards(): [] {
    // RULE 1: Must be in Setup phase
    assert(go_fish_phase == go_fish_GamePhase.Setup, "Can only deal cards during setup");
    
    // RULE 2: Both players must have applied their masks
    assert(go_fish_hasMaskApplied(1 as Uint<64>), "Player 1 must apply mask before dealing");
    assert(go_fish_hasMaskApplied(2 as Uint<64>), "Player 2 must apply mask before dealing");
    
    for (const i of 0..7) {
        dealCard(1 as Uint<64>);
        dealCard(2 as Uint<64>);
    }
    startGame();
    return [];
}

// Deal a single card to a player during setup (call 7 times per player)
circuit dealCard(toPlayerId: Uint<64>): CurvePoint {
    assert(go_fish_phase == go_fish_GamePhase.Setup, "Not in setup phase");
    const disclosed_playerId = disclose(toPlayerId);
    assert(disclosed_playerId == 1 as Uint<64> || disclosed_playerId == 2 as Uint<64>, "Invalid player index");
    
    const card = getTopCardForOpponent(toPlayerId);
    go_fish_markCardDealt(toPlayerId);
    return card;
}

// Both players must apply mask before dealing
// RULE: Must be in Setup phase
// RULE: Each player can only apply their mask once
export circuit applyMask(playerId: Uint<64>): [] {
    const disclosed_playerId = disclose(playerId);
    
    // RULE 1: Must be in Setup phase
    assert(go_fish_phase == go_fish_GamePhase.Setup, "Can only apply mask during setup");
    
    // RULE 2: Valid player
    assert(disclosed_playerId == 1 as Uint<64> || disclosed_playerId == 2 as Uint<64>, "Invalid player index");
    
    // RULE 3: Player hasn't already applied their mask
    assert(!go_fish_hasMaskApplied(playerId), "Player has already applied their mask");
    
    deck_apply_mask_to_deck(playerId);
    go_fish_markMaskApplied(playerId);
    return [];
}

// Start the game after dealing is complete
circuit startGame(): [] {
    return go_fish_startGame();
}

export circuit get_top_card_index(): Uint<32> {
    return deck_topCardIndex;
}
export circuit get_deck_size(): Uint<64> {
    return deck_deckSize;
}

// ============================================
// CARD TRANSFER CIRCUITS
// ============================================
export circuit partial_decryption(point: CurvePoint, playerId: Uint<64>): CurvePoint {
    return deck_partial_decryption(point, playerId);
}

// Transfer a single card from one player to another (internal use)
// RULE: Valid player (1 or 2)
// RULE: Card must exist in the player's hand
circuit moveCardFromPlayerToPlayerCardInHand(fromPlayerId: Uint<64>, semiMaskedPoint: CurvePoint): [] {
    const disclosed_playerId = disclose(fromPlayerId);
    
    // RULE: Valid player
    assert(disclosed_playerId == 1 as Uint<64> || disclosed_playerId == 2 as Uint<64>, "Invalid player index");
 
    if (disclosed_playerId == 1 as Uint<64>) {
        assert(hand_p1_playerHand.member(disclose(semiMaskedPoint)), "Card not in player1 hand");
        hand_p1_removeCardFromHand(disclose(semiMaskedPoint));
        const decrypted_point = deck_partial_decryption(semiMaskedPoint, 1);

        const [secret, invScalar] = deck_getSecretFromPlayerId(2);
        const masked_point = std_ecMul(decrypted_point, secret);
        hand_p2_insertCardIntoHand(disclose(masked_point));
    } else if (disclosed_playerId == 2 as Uint<64>) {
        assert(hand_p2_playerHand.member(disclose(semiMaskedPoint)), "Card not in player2 hand");
        hand_p2_removeCardFromHand(disclose(semiMaskedPoint));
        const decrypted_point = deck_partial_decryption(semiMaskedPoint, 2);
        
        const [secret, invScalar] = deck_getSecretFromPlayerId(1);
        const masked_point = std_ecMul(decrypted_point, secret);
        hand_p1_insertCardIntoHand(disclose(masked_point));
    } else {
        assert(false, "Invalid player index");
    }
}


// INTERNAL: Transfer all cards of a rank from opponent to current player
// NOTE: Not exported - only called internally by askForCardAndProcess()
circuit transferAllCardsOfRank(fromPlayerId: Uint<64>, targetRank: Uint<32>): [] {
    const disclosed_playerId = disclose(fromPlayerId);
    const disclosed_rank = disclose(targetRank);
    assert(disclosed_rank >= 0 && disclosed_rank < 13, "Invalid card rank");
    assert(disclosed_playerId == 1 as Uint<64> || disclosed_playerId == 2 as Uint<64>, "Invalid player index");

    transferCardOfRank(fromPlayerId, targetRank, 0 as Uint<32>);
    transferCardOfRank(fromPlayerId, targetRank, 1 as Uint<32>);
    transferCardOfRank(fromPlayerId, targetRank, 2 as Uint<32>);
    transferCardOfRank(fromPlayerId, targetRank, 3 as Uint<32>);
}
// Transfer a single card of a specific rank (for when opponent has the card)
// Returns true if a card was transferred, false otherwise
// This should be called multiple times until no more cards of that rank exist
// RULE: Must be in WaitForResponse or WaitForTransfer phase
// RULE: The fromPlayer must be the opponent (not current turn player)
circuit transferCardOfRank(fromPlayerId: Uint<64>, targetRank: Uint<32>, cardSuit: Uint<32>): Boolean {
    const disclosed_playerId = disclose(fromPlayerId);
    const disclosed_rank = disclose(targetRank);
    const disclosed_suit = disclose(cardSuit);
    
    // RULE 1: Must be in response or transfer phase
    assert(go_fish_phase == go_fish_GamePhase.WaitForResponse || 
           go_fish_phase == go_fish_GamePhase.WaitForTransfer, 
           "Can only transfer cards during response/transfer phase");
    
    // RULE 2: The fromPlayer must be the opponent (not the current player)
    assert(disclosed_playerId != go_fish_currentTurn, "Cannot transfer cards from current player - must be opponent");
    
    // RULE 3: Valid card parameters
    assert(disclosed_rank >= 0 && disclosed_rank < 13, "Invalid card rank");
    assert(disclosed_suit >= 0 && disclosed_suit < 4, "Invalid card suit");
    
    // Calculate card index: rank + (suit * 13)
    const cardIndex = (disclosed_rank + (disclosed_suit * 13 as Uint<32>)) as Uint<32>;
    const baseCard = deck_reverseDeckCurveToCard.lookup(cardIndex) as CurvePoint;
    
    if (disclosed_playerId == 1 as Uint<64>) {
        // Cards in hand are masked with player's secret: baseCard × playerSecret
        // Must check for the masked version, not the base card
        const [secret1, inv1] = deck_getSecretFromPlayerId(1);
        const maskedCard = std_ecMul(baseCard, secret1);
        
        if (hand_p1_playerHand.member(disclose(maskedCard))) {
            moveCardFromPlayerToPlayerCardInHand(1 as Uint<64>, maskedCard);
            return true;
        }
    } else if (disclosed_playerId == 2 as Uint<64>) {
        // Cards in hand are masked with player's secret: baseCard × playerSecret
        const [secret2, inv2] = deck_getSecretFromPlayerId(2);
        const maskedCard = std_ecMul(baseCard, secret2);
        
        if (hand_p2_playerHand.member(disclose(maskedCard))) {
            moveCardFromPlayerToPlayerCardInHand(2 as Uint<64>, maskedCard);
            return true;
        }
    }
    
    return false;
}

// ============================================
// ASKING FOR CARDS (Core Go Fish Action)
// ============================================

// Ask opponent for cards of a specific rank AND process the response in one call
// Returns: [opponentHadCard: Boolean, cardsTransferred: Uint<8>]
// - opponentHadCard: true if opponent had cards (player goes again), false if "Go Fish"
// - cardsTransferred: number of cards transferred (0 if Go Fish)
// RULE: Can only ask for a rank if you have at least one card of that rank
// RULE: Can only ask on your turn
// RULE: Must be in TurnStart phase
export circuit askForCardAndProcess(askingPlayerId: Uint<64>, targetRank: Uint<32>): [Boolean, Uint<8>] {
    const disclosed_playerId = disclose(askingPlayerId);
    const disclosed_rank = disclose(targetRank);
    
    // RULE 1: Must be in TurnStart phase
    assert(go_fish_phase == go_fish_GamePhase.TurnStart, "Can only ask for cards at turn start");
    
    // RULE 2: Must be the asking player's turn
    assert(disclosed_playerId == go_fish_currentTurn, "Not your turn - only current player can ask for cards");
    
    // RULE 3: Asking player must have at least one card of the requested rank
    const hasCard = doesPlayerHaveCard(askingPlayerId, targetRank);
    assert(hasCard, "Cannot ask for a rank you don't have in your hand");
    
    // RULE 4: Valid rank (0-12)
    assert(disclosed_rank >= 0 && disclosed_rank < 13, "Invalid card rank");
    
    // Determine opponent
    const opponentId: Uint<64> = disclosed_playerId == 1 as Uint<64> ? 2 as Uint<64> : 1 as Uint<64>;
    
    // Count how many cards opponent has of this rank
    const opponentCardCount = countCardsOfRank(opponentId, targetRank);
    
    if (opponentCardCount > 0 as Uint<8>) {
        // Opponent has cards! Transfer all of them
        go_fish_setPhase(go_fish_GamePhase.WaitForTransfer);
        transferAllCardsOfRank(opponentId, targetRank);
        
        // Player gets another turn
        go_fish_setPhase(go_fish_GamePhase.TurnStart);
        return [true, opponentCardCount];
    } else {
        // Go Fish! Store the asked rank for afterGoFish check
        go_fish_setLastAskedRank(targetRank);
        go_fish_setPhase(go_fish_GamePhase.WaitForDraw);
        return [false, 0 as Uint<8>];
    }
}

// Ask opponent for cards of a specific rank (old version - requires separate response handling)
circuit askForCard(askingPlayerId: Uint<64>, targetRank: Uint<32>): [] {
    const disclosed_playerId = disclose(askingPlayerId);
    const disclosed_rank = disclose(targetRank);
    
    // RULE 1: Must be in TurnStart phase
    assert(go_fish_phase == go_fish_GamePhase.TurnStart, "Can only ask for cards at turn start");
    
    // RULE 2: Must be the asking player's turn
    assert(disclosed_playerId == go_fish_currentTurn, "Not your turn - only current player can ask for cards");
    
    // RULE 3: Asking player must have at least one card of the requested rank
    const hasCard = doesPlayerHaveCard(askingPlayerId, targetRank);
    assert(hasCard, "Cannot ask for a rank you don't have in your hand");
    
    // RULE 4: Valid rank (0-12)
    assert(disclosed_rank >= 0 && disclosed_rank < 13, "Invalid card rank");
    
    // Store the asked rank for state recovery
    go_fish_setLastAskedRank(targetRank);
    
    // Transition to waiting for response
    go_fish_setPhase(go_fish_GamePhase.WaitForResponse);
    
    return [];
}

// ============================================
// DRAWING CARDS
// ============================================

// INTERNAL: Draw a card from deck for a player (used during setup and "Go Fish")
// Returns a card masked with only the receiving player's key
// NOTE: Not exported - only called internally by dealCard() and goFish()
//
// How it works:
//   - Deck cards are masked: P × s1 × s2 (both players' secrets)
//   - getTopCard(1) removes P2's mask → P × s1 (only P1's mask remains)
//   - getTopCard(2) removes P1's mask → P × s2 (only P2's mask remains)
//   - So to give card to PlayerX, call getTopCard(X) to keep their mask
circuit getTopCardForOpponent(toPlayerId: Uint<64>): CurvePoint {
    const disclosed_playerId = disclose(toPlayerId);
    assert(disclosed_playerId == 1 as Uint<64> || disclosed_playerId == 2 as Uint<64>, "Invalid player index");
    if (disclosed_playerId == 1 as Uint<64>) {
        // For P1: getTopCard(1) removes P2's mask, keeps P1's → P1 can decrypt
        const semi_encrypted_point = deck_getTopCard(1);
        hand_p1_insertCardIntoHand(semi_encrypted_point);
        return semi_encrypted_point;
    } else { // (disclosed_playerId == 2 as Uint<64>) {
        // For P2: getTopCard(2) removes P1's mask, keeps P2's → P2 can decrypt
        const semi_encrypted_point = deck_getTopCard(2);
        hand_p2_insertCardIntoHand(semi_encrypted_point);
        return semi_encrypted_point;
    }
}

// "Go Fish" - draw a card when opponent doesn't have requested rank
// Returns the drawn card point
// RULE: Must be in correct phase (WaitForDraw or TurnStart for empty hand)
// RULE: Must be the current player drawing
export circuit goFish(playerId: Uint<64>): CurvePoint {
    const disclosed_playerId = disclose(playerId);
    
    // RULE 1: Must be in draw phase or turn start (for empty hand case)
    assert(go_fish_phase == go_fish_GamePhase.WaitForDraw || 
           go_fish_phase == go_fish_GamePhase.TurnStart, "Not in draw phase");
    
    // RULE 2: Must be the current player's turn
    assert(disclosed_playerId == go_fish_currentTurn, "Not your turn - only current player can draw");
    
    // RULE 3: Deck must not be empty
    assert(deck_topCardIndex < deck_deckSize, "Cannot draw - deck is empty");
    
    const card = getTopCardForOpponent(playerId);
    
    // After drawing, switch turns (unless they drew the card they asked for)
    go_fish_setPhase(go_fish_GamePhase.WaitForDrawCheck);
    
    return card;
}

// After Go Fish, check if drawn card matches requested rank
// If yes, player gets another turn; if no, switch turns
// RULE: Must be in WaitForDrawCheck phase
// RULE: Must be called by current player
// RULE: If claiming drew requested card, contract verifies by checking hand
export circuit afterGoFish(playerId: Uint<64>, drewRequestedCard: Boolean): [] {
    const disclosed_playerId = disclose(playerId);
    
    // RULE 1: Must be waiting for draw check
    assert(go_fish_phase == go_fish_GamePhase.WaitForDrawCheck, "Not waiting for draw check");
    
    // RULE 2: Must be the current player
    assert(disclosed_playerId == go_fish_currentTurn, "Only current player can call afterGoFish");
    
    // Get the last asked rank before clearing it
    const lastRank = go_fish_lastAskedRank;
    
    // RULE 3: Verify the claim - if player claims they drew the requested card,
    // they must now have a card of that rank in their hand
    // (They asked for it, so they already had at least one. If they drew another,
    // they still have it. This verification ensures they can't lie about drawing it.)
    if (disclose(drewRequestedCard)) {
        // Verify: player must have at least one card of the requested rank
        // (which they do if they asked for it, but this confirms the draw claim is plausible)
        const hasRequestedRank = doesPlayerHaveCard(playerId, lastRank);
        assert(hasRequestedRank, "Invalid claim: you don't have the requested rank");
        
        // Player drew the card they asked for - they get another turn
        go_fish_clearLastAskedRank();
        go_fish_setPhase(go_fish_GamePhase.TurnStart);
    } else {
        // Player didn't draw requested card - switch turns
        go_fish_clearLastAskedRank();
        go_fish_switchTurn();
    }
    return [];
}

export circuit get_card_from_point(point: CurvePoint): Field {
    return deck_getCardFromPoint(point);
}

// ============================================
// CARD CHECKING CIRCUITS
// ============================================

// Check if a player has any card of a specific rank
// Note: Cards in hand are MASKED (basePoint × playerSecret), so we must
// mask the base points before checking membership
export circuit doesPlayerHaveCard(playerId: Uint<64>, _targetRank: Uint<32>): Boolean {
    // 1. Validate Input (Standard deck ranks are 0..12 for A-K)
    const disclosed_playerId = disclose(playerId);
    const targetRank = disclose(_targetRank);
    assert(targetRank >= 0 && targetRank < 13, "Invalid card rank");
    assert(playerId == 1 as Uint<64> || playerId == 2 as Uint<64>, "Invalid player index");

    // Get base (unmasked) card points for all 4 suits of this rank
    const baseCard1 = deck_reverseDeckCurveToCard.lookup(targetRank) as CurvePoint;
    const baseCard2 = deck_reverseDeckCurveToCard.lookup(targetRank+13 as Uint<32>) as CurvePoint;
    const baseCard3 = deck_reverseDeckCurveToCard.lookup(targetRank+26 as Uint<32>) as CurvePoint;
    const baseCard4 = deck_reverseDeckCurveToCard.lookup(targetRank+39 as Uint<32>) as CurvePoint;

    if (disclosed_playerId == 1 as Uint<64>) {
        // Mask cards with P1's secret to match what's stored in hand
        const [secret1, inv1] = deck_getSecretFromPlayerId(1);
        const card1 = std_ecMul(baseCard1, secret1);
        const card2 = std_ecMul(baseCard2, secret1);
        const card3 = std_ecMul(baseCard3, secret1);
        const card4 = std_ecMul(baseCard4, secret1);
        return (
            hand_p1_playerHand.member(disclose(card1)) ||
            hand_p1_playerHand.member(disclose(card2)) ||
            hand_p1_playerHand.member(disclose(card3)) ||
            hand_p1_playerHand.member(disclose(card4))
        );
    } else if (disclosed_playerId == 2 as Uint<64>) {
        // Mask cards with P2's secret
        const [secret2, inv2] = deck_getSecretFromPlayerId(2);
        const card1 = std_ecMul(baseCard1, secret2);
        const card2 = std_ecMul(baseCard2, secret2);
        const card3 = std_ecMul(baseCard3, secret2);
        const card4 = std_ecMul(baseCard4, secret2);
        return (
            hand_p2_playerHand.member(disclose(card1)) ||
            hand_p2_playerHand.member(disclose(card2)) ||
            hand_p2_playerHand.member(disclose(card3)) ||
            hand_p2_playerHand.member(disclose(card4))
        );
    }
    return false;
}

// Count how many cards of a specific rank a player has (0-4)
// Note: Cards in hand are MASKED, so we mask base points before checking
circuit countCardsOfRank(playerId: Uint<64>, targetRank: Uint<32>): Uint<8> {
    const disclosed_playerId = disclose(playerId);
    const disclosed_rank = disclose(targetRank);
    assert(disclosed_rank >= 0 && disclosed_rank < 13, "Invalid card rank");

    // Get base (unmasked) card points for all 4 suits of this rank
    const baseCard1 = deck_reverseDeckCurveToCard.lookup(disclosed_rank) as CurvePoint;
    const baseCard2 = deck_reverseDeckCurveToCard.lookup(disclosed_rank+13 as Uint<32>) as CurvePoint;
    const baseCard3 = deck_reverseDeckCurveToCard.lookup(disclosed_rank+26 as Uint<32>) as CurvePoint;
    const baseCard4 = deck_reverseDeckCurveToCard.lookup(disclosed_rank+39 as Uint<32>) as CurvePoint;
    
    if (disclosed_playerId == 1 as Uint<64>) {
        // Mask cards with P1's secret to match what's stored in hand
        const [secret1, inv1] = deck_getSecretFromPlayerId(1);
        const card1 = std_ecMul(baseCard1, secret1);
        const card2 = std_ecMul(baseCard2, secret1);
        const card3 = std_ecMul(baseCard3, secret1);
        const card4 = std_ecMul(baseCard4, secret1);
        
        const c1: Uint<8> = hand_p1_doesPlayerHaveCardN(disclose(card1));
        const c2: Uint<8> = hand_p1_doesPlayerHaveCardN(disclose(card2));
        const c3: Uint<8> = hand_p1_doesPlayerHaveCardN(disclose(card3));
        const c4: Uint<8> = hand_p1_doesPlayerHaveCardN(disclose(card4));
        return (c1 + c2 + c3 + c4) as Uint<8>;
    } else if (disclosed_playerId == 2 as Uint<64>) {
        // Mask cards with P2's secret
        const [secret2, inv2] = deck_getSecretFromPlayerId(2);
        const card1 = std_ecMul(baseCard1, secret2);
        const card2 = std_ecMul(baseCard2, secret2);
        const card3 = std_ecMul(baseCard3, secret2);
        const card4 = std_ecMul(baseCard4, secret2);
        
        const c1: Uint<8> = hand_p2_doesPlayerHaveCardN(disclose(card1));
        const c2: Uint<8> = hand_p2_doesPlayerHaveCardN(disclose(card2));
        const c3: Uint<8> = hand_p2_doesPlayerHaveCardN(disclose(card3));
        const c4: Uint<8> = hand_p2_doesPlayerHaveCardN(disclose(card4));
        return (c1 + c2 + c3 + c4) as Uint<8>;
    }
    return 0;
}

// ============================================
// BOOK SCORING CIRCUITS
// ============================================

// Check if a player has a book (4 of a kind) and score it
// Removes the 4 cards from hand and adds a point
// RULE: Can only score books for valid players
// RULE: Valid rank (0-12)
// RULE: Game must not be in Setup phase
// RULE: Players can only score their own books
export circuit checkAndScoreBook(playerId: Uint<64>, targetRank: Uint<32>): Boolean {
    const disclosed_playerId = disclose(playerId);
    const disclosed_rank = disclose(targetRank);
    
    // RULE 1: Valid player
    assert(disclosed_playerId == 1 as Uint<64> || disclosed_playerId == 2 as Uint<64>, "Invalid player index");
    
    // RULE 2: Valid rank
    assert(disclosed_rank >= 0 && disclosed_rank < 13, "Invalid card rank");
    
    // RULE 3: Game must have started (not in Setup phase)
    assert(go_fish_phase != go_fish_GamePhase.Setup, "Cannot score books during setup");
    
    // RULE 4: Game must not be over
    assert(go_fish_phase != go_fish_GamePhase.GameOver, "Game is already over");
    
    const cardCount = countCardsOfRank(playerId, targetRank);
    
    if (cardCount == 4 as Uint<8>) {
        // Player has a book! Remove all 4 cards and score
        const disclosed_playerId = disclose(playerId);
        const disclosed_rank = disclose(targetRank);
        
        const card1 = deck_reverseDeckCurveToCard.lookup(disclosed_rank) as CurvePoint;
        const card2 = deck_reverseDeckCurveToCard.lookup(disclosed_rank+13 as Uint<32>) as CurvePoint;
        const card3 = deck_reverseDeckCurveToCard.lookup(disclosed_rank+26 as Uint<32>) as CurvePoint;
        const card4 = deck_reverseDeckCurveToCard.lookup(disclosed_rank+39 as Uint<32>) as CurvePoint;
        
        if (disclosed_playerId == 1 as Uint<64>) {
            // Get masked versions and remove from hand
            const [secret1, inv1] = deck_getSecretFromPlayerId(1);
            hand_p1_removeCardFromHandForBook(std_ecMul(card1, secret1));
            hand_p1_removeCardFromHandForBook(std_ecMul(card2, secret1));
            hand_p1_removeCardFromHandForBook(std_ecMul(card3, secret1));
            hand_p1_removeCardFromHandForBook(std_ecMul(card4, secret1));
        } else if (disclosed_playerId == 2 as Uint<64>) {
            const [secret2, inv2] = deck_getSecretFromPlayerId(2);
            hand_p2_removeCardFromHandForBook(std_ecMul(card1, secret2));
            hand_p2_removeCardFromHandForBook(std_ecMul(card2, secret2));
            hand_p2_removeCardFromHandForBook(std_ecMul(card3, secret2));
            hand_p2_removeCardFromHandForBook(std_ecMul(card4, secret2));
        }
        
        // Add score
        go_fish_addScore(playerId);
        return true;
    }
    
    return false;
}

// ============================================
// GAME STATE QUERIES
// ============================================

// Get current game phase
export circuit getGamePhase(): go_fish_GamePhase {
    return go_fish_phase;
}

// Get current player's turn
export circuit getCurrentTurn(): Uint<64> {
    return go_fish_currentTurn;
}

// Get player scores
export circuit getScores(): [Uint<8>, Uint<8>] {
    return [go_fish_scoreP1, go_fish_scoreP2];
}

// Get hand sizes
export circuit getHandSizes(): [Uint<64>, Uint<64>] {
    return [hand_p1_handSize, hand_p2_handSize];
}

// Check if game is over
export circuit isGameOver(): Boolean {
    return go_fish_phase == go_fish_GamePhase.GameOver;
}

// Check if deck is empty
export circuit isDeckEmpty(): Boolean {
    return deck_topCardIndex >= deck_deckSize;
}

// End game when deck is empty and a player has no cards
export circuit checkAndEndGame(): Boolean {
    if (isDeckEmpty()) {
        const handSizes = getHandSizes();
        if (handSizes[0] == 0 as Uint<64> || handSizes[1] == 0 as Uint<64>) {
            go_fish_endGame();
            return true;
        }
    }
    return false;
}

// ============================================
// TURN MANAGEMENT
// ============================================

// NOTE: opponentHadCard() and opponentDidNotHaveCard() have been REMOVED
// They were legacy methods that allowed unverified claims about opponent's cards.
// The askForCardAndProcess() circuit now handles the complete ask-and-respond flow
// with cryptographic verification of the opponent's hand.

// Switch to other player's turn
// RULE: Can only switch turn from TurnStart phase (for edge cases like empty hand)
// RULE: Only the current player can voluntarily switch turns
export circuit switchTurn(playerId: Uint<64>): [] {
    const disclosed_playerId = disclose(playerId);
    
    // RULE 1: Can only switch during TurnStart phase
    assert(go_fish_phase == go_fish_GamePhase.TurnStart, 
           "Can only switch turn during TurnStart phase");
    
    // RULE 2: Only current player can switch (e.g., when they have no valid moves)
    assert(disclosed_playerId == go_fish_currentTurn, 
           "Only current player can switch turns");
    
    return go_fish_switchTurn();
}

export circuit get_player_hand_size(playerId: Uint<64>): Uint<64> {
    const disclosed_playerId = disclose(playerId);
    if (disclosed_playerId == 1 as Uint<64>) {
        return hand_p1_handSize;
    } else if (disclosed_playerId == 2 as Uint<64>) {
        return hand_p2_handSize;
    }
    return 0 as Uint<64>;
}

// ============================================
// STATE RECOVERY CIRCUITS
// ============================================

// Check if a player has a specific card (by card index 0-51)
// Card index = rank + (suit * 13), e.g.: A♠=0, 2♠=1, ..., K♠=12, A♥=13, ..., K♣=51
export circuit doesPlayerHaveSpecificCard(playerId: Uint<64>, cardIndex: Uint<32>): Boolean {
    const disclosed_playerId = disclose(playerId);
    const disclosed_cardIndex = disclose(cardIndex);
    
    assert(disclosed_cardIndex >= 0 && disclosed_cardIndex < 52, "Invalid card index");
    assert(disclosed_playerId == 1 as Uint<64> || disclosed_playerId == 2 as Uint<64>, "Invalid player index");
    
    // Get the base (unmasked) card point for this card index
    const baseCard = deck_reverseDeckCurveToCard.lookup(disclosed_cardIndex) as CurvePoint;
    
    if (disclosed_playerId == 1 as Uint<64>) {
        // Mask with P1's secret to match what's stored in hand
        const [secret1, inv1] = deck_getSecretFromPlayerId(1);
        const maskedCard = std_ecMul(baseCard, secret1);
        return hand_p1_playerHand.member(disclose(maskedCard));
    } else if (disclosed_playerId == 2 as Uint<64>) {
        // Mask with P2's secret
        const [secret2, inv2] = deck_getSecretFromPlayerId(2);
        const maskedCard = std_ecMul(baseCard, secret2);
        return hand_p2_playerHand.member(disclose(maskedCard));
    }
    return false;
}

// Get the last asked rank (255 = no pending request)
export circuit getLastAskedRank(): Uint<32> {
    return go_fish_getLastAskedRank();
}

// Check if a player has applied their shuffle mask
export circuit hasMaskApplied(playerId: Uint<64>): Boolean {
    return go_fish_hasMaskApplied(playerId);
}

// Get how many cards have been dealt to a player during setup
export circuit getCardsDealt(playerId: Uint<64>): Uint<64> {
    return go_fish_getCardsDealt(playerId);
}