pragma language_version >= 0.19.0;

import CompactStandardLibrary;
import CompactStandardLibrary prefix std_;

// Witnesses
witness getFieldInverse(x: Field): Field;
witness player_secret_key(player: Field): Field;
witness shuffle_seed(player: Field): Bytes<32>;
witness split_field_bits(f: Field): [Field, Uint<64>];
witness get_sorted_deck_witness(input: Vector<52, WeightedCard>): Vector<52, WeightedCard>;

// Printers
witness print_field(in: Field): Boolean;
witness print_bytes_32(in: Bytes<32>): Boolean;
witness print_vector_2_field(in: Vector<2, Field>): Boolean;
witness print_curve_point(in: CurvePoint): Boolean;
witness print_uint_64(in: Uint<64>): Boolean;

struct WeightedCard {
    point: CurvePoint,
    weight: Uint<248>
}

// Map CurvePoint to Card Value
export ledger deckCurveToCard: Map<CurvePoint, Field>;
export ledger reverseDeckCurveToCard: Map<Uint<32>, CurvePoint>;
// Map Card in Deck
export ledger deck: Map<Field, CurvePoint>;
// Size of the deck
export ledger deckSize: Counter;
// Index of the top card
export ledger topCardIndex: Uint<32>;
// Player secret hash
export ledger playersKeysHashes: Map<Bytes<32>, Uint<64>>;
// Inverse secret hash
export ledger playersKeysInverses: Map<Bytes<32>, Bytes<32>>;
// Player Hand
export ledger player1Hand: Set<CurvePoint>;
export ledger player2Hand: Set<CurvePoint>;


constructor() {
    topCardIndex = 0 as Uint<32>;
}

// Create the deck
// Store cards mapping in persistent Map<card, point>
export circuit init_deck(): [] {
    assert(deckSize == 0, "Deck already initialized");
    for (const i of 0..52) { 
        const cardPoint: CurvePoint = getPointFromValue(i);
        deckCurveToCard.insert(cardPoint, (i) as Field);
        reverseDeckCurveToCard.insert((i) as Uint<32>, cardPoint);
        deck.insert((i) as Field, cardPoint);
        deckSize.increment(1);
    }
}

export circuit apply_mask_to_deck(playerIndex: Uint<64>): [] {
    const [secret, invScalar] = getSecretFromPlayerId(playerIndex);
    const secret_hash = std_persistentHash<Field>(secret);
    const invScalar_hash = std_persistentHash<Field>(invScalar);

    // Disallow multiple shuffles/masks with the same secret key
    assert(!playersKeysHashes.member(disclose(secret_hash)), "Player secret key already used");
    playersKeysHashes.insert(disclose(secret_hash), disclose(playerIndex));
    playersKeysInverses.insert(disclose(secret_hash), disclose(invScalar_hash));
    shuffle_deck(playerIndex);
}

// Given a known CurvePoint, get the card value
export circuit getCardFromPoint(point: CurvePoint): Field {
    const index = deckCurveToCard.lookup(disclose(point)) as Field;
    return index;
}

// This muse be called by the opponent, who hands your the card
export circuit getTopCard(_playerId: Uint<64>): CurvePoint {
    const disclosed_playerId = disclose(_playerId);
    const point = deck.lookup(disclose(topCardIndex)) as CurvePoint;
    topCardIndex = topCardIndex + 1 as Uint<32>;
    assert(topCardIndex <= deckSize, "Top card index is greater than deck size");
    
    if (disclosed_playerId == 1 as Uint<64>) {
        const masked_card = partial_decryption(disclose(point), 2);
        player1Hand.insert(disclose(masked_card));
        return masked_card;
    }
    else if (disclosed_playerId == 2 as Uint<64>) {
        const masked_card = partial_decryption(disclose(point), 1);
        player2Hand.insert(disclose(masked_card));
        return masked_card;
    }
    else { 
        assert(false, "Invalid player index");
    }

    // This will never be reached.
    return point;
}

export circuit removeCardFromHand(playerId: Uint<64>, semiMaskedPoint: CurvePoint): CurvePoint {
    const disclosed_playerId = disclose(playerId);
    if (disclosed_playerId == 1 as Uint<64>) {
        assert(player1Hand.member(disclose(semiMaskedPoint)), "Card not in player1 hand");
        player1Hand.remove(disclose(semiMaskedPoint));
        return semiMaskedPoint;
    } else if (disclosed_playerId == 2 as Uint<64>) {
        assert(player2Hand.member(disclose(semiMaskedPoint)), "Card not in player2 hand");
        player2Hand.remove(disclose(semiMaskedPoint));
        return semiMaskedPoint;
    } 
           assert(false, "Invalid player index");
    return semiMaskedPoint;
}

circuit getSecretFromPlayerId(playerId: Uint<64>): [Field, Field] {
    const secret = player_secret_key(playerId);
    const secret_hash = std_persistentHash<Field>(secret);

    const invScalar = getFieldInverse(disclose(secret));
    const invScalar_hash = std_persistentHash<Field>(invScalar);
    
    const rawPoint = std_hashToCurve<Bytes<32>>(secret_hash);
    const randomPoint = ecMul(rawPoint, 8 as Field);
    const mappedPoint = ecMul(randomPoint, secret);
    const verifyPoint = ecMul(mappedPoint, invScalar);
    assert(verifyPoint == randomPoint, "Witness failed: Invalid Field inverse");
    return [secret, invScalar];
}

export circuit moveCardFromPlayerToPlayerCardInHand(fromPlayerId: Uint<64>, semiMaskedPoint: CurvePoint): [] {
    const disclosed_playerId = disclose(fromPlayerId);
 
    if (disclosed_playerId == 1 as Uint<64>) {
        assert(player1Hand.member(disclose(semiMaskedPoint)), "Card not in player1 hand");
        player1Hand.remove(disclose(semiMaskedPoint));
        const decrypted_point = partial_decryption(semiMaskedPoint, 1);
        // TODO This is duplicated code we can move this to a helper function
        const [secret, invScalar] = getSecretFromPlayerId(2);
        const masked_point = ecMul(decrypted_point, secret);
        player2Hand.insert(disclose(masked_point));
    } else if (disclosed_playerId == 2 as Uint<64>) {
        assert(player2Hand.member(disclose(semiMaskedPoint)), "Card not in player2 hand");
        player2Hand.remove(disclose(semiMaskedPoint));
        const decrypted_point = partial_decryption(semiMaskedPoint, 2);
        const [secret, invScalar] = getSecretFromPlayerId(1);
        const masked_point = ecMul(decrypted_point, secret);
        player1Hand.insert(disclose(masked_point));
    } else {
        assert(false, "Invalid player index");
    }
}

export circuit doesPlayerHaveCard(player: Uint<64>, _targetRank: Uint<32>): Boolean {
    // 1. Validate Input (Standard deck ranks are 0..13)
    const disclosed_playerId = disclose(player);
    const targetRank = disclose(_targetRank);
    assert(targetRank >= 0 && targetRank < 14, "Invalid card rank");
    assert(player == 1 as Uint<64> || player == 2 as Uint<64>, "Invalid player index");

    const INDICES_13: Vector<13, Uint<64>> = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    if (disclosed_playerId == 1) {
            const card1 = reverseDeckCurveToCard.lookup(targetRank) as CurvePoint;
        const card2 = reverseDeckCurveToCard.lookup(targetRank+13 as Uint<32>) as CurvePoint;
        const card3 = reverseDeckCurveToCard.lookup(targetRank+26 as Uint<32>) as CurvePoint;
        const card4 = reverseDeckCurveToCard.lookup(targetRank+39 as Uint<32>)  as CurvePoint;

         return (
            player1Hand.member(card1) ||
            player1Hand.member(card2) ||
            player1Hand.member(card3) ||
            player1Hand.member(card4)
         );
    } 
    else if (disclosed_playerId == 2) { 
        const card1 = reverseDeckCurveToCard.lookup(targetRank);
        const card2 = reverseDeckCurveToCard.lookup(targetRank+13 as Uint<32>);
        const card3 = reverseDeckCurveToCard.lookup(targetRank+26 as Uint<32>);
        const card4 = reverseDeckCurveToCard.lookup(targetRank+39 as Uint<32>);
         return (
            player2Hand.member(card1) ||
            player2Hand.member(card2) ||
            player2Hand.member(card3) ||
            player2Hand.member(card4)
         );
    } else {
        assert(false, "Invalid player index");
    }
    // this never is reached.
    return false;
}

export circuit doesPlayerHaveAllCards(player: Uint<64>, _targetRank: Uint<32>): Boolean {
    const disclosed_playerId = disclose(player);
    const targetRank = disclose(_targetRank);
    assert(targetRank >= 0 && targetRank < 14, "Invalid card rank");
    assert(player == 1 as Uint<64> || player == 2 as Uint<64>, "Invalid player index");

    const INDICES_13: Vector<13, Uint<64>> = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    if (disclosed_playerId == 1) {
            const card1 = reverseDeckCurveToCard.lookup(targetRank) as CurvePoint;
        const card2 = reverseDeckCurveToCard.lookup(targetRank+13 as Uint<32>) as CurvePoint;
        const card3 = reverseDeckCurveToCard.lookup(targetRank+26 as Uint<32>) as CurvePoint;
        const card4 = reverseDeckCurveToCard.lookup(targetRank+39 as Uint<32>)  as CurvePoint;

         return (
            player1Hand.member(card1) &&
            player1Hand.member(card2) &&
            player1Hand.member(card3) &&
            player1Hand.member(card4)
         );
    } 
    else if (disclosed_playerId == 2) { 
        const card1 = reverseDeckCurveToCard.lookup(targetRank);
        const card2 = reverseDeckCurveToCard.lookup(targetRank+13 as Uint<32>);
        const card3 = reverseDeckCurveToCard.lookup(targetRank+26 as Uint<32>);
        const card4 = reverseDeckCurveToCard.lookup(targetRank+39 as Uint<32>);
         return (
            player2Hand.member(card1) &&
            player2Hand.member(card2) &&
            player2Hand.member(card3) &&
            player2Hand.member(card4)
         );
    } else {
        assert(false, "Invalid player index");
    }
    // this never is reached.
    return false;
}

export circuit partial_decryption(point: CurvePoint, playerId: Uint<64>): CurvePoint {
    const secret = player_secret_key(playerId);
    const secret_hash = std_persistentHash<Field>(secret);
    assert(playersKeysHashes.member(disclose(secret_hash)), "Player secret key unknown");

    const invScalar = getFieldInverse(disclose(secret));
    const invScalar_hash = std_persistentHash<Field>(invScalar);
    const expected_invScalar_hash = playersKeysInverses.lookup(disclose(secret_hash)) as Bytes<32>;
    assert(invScalar_hash == expected_invScalar_hash, "Witness failed: Invalid Field inverse");

    print_field(secret);
    print_field(invScalar);
    print_field((secret * invScalar));

    const decrypted_point = ecMul(disclose(point), disclose(invScalar));
    return decrypted_point;
}

circuit getPointFromValue(value: Field): CurvePoint {
    const card_seed: Bytes<32> = std_persistentHash<Field>(value);
    const raw_point: CurvePoint = std_hashToCurve<Bytes<32>>(card_seed);
    return ecMul(raw_point, 8 as Field);
}

circuit applyMaskToPoint(point: CurvePoint, playerIndex: Uint<64>): CurvePoint {
    const secret = player_secret_key(playerIndex);
    return ecMul(disclose(point), disclose(secret));
}

export circuit shuffle_deck(playerIndex: Uint<64>): [] {
    const seed = shuffle_seed(playerIndex);
    
    const INDICES_52: Vector<52, Uint<64>> = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];

    const cards: Vector<52, WeightedCard> = map(
        (idx) => make_weighted_masked_card(idx as Uint<248>, seed, playerIndex),
        INDICES_52
    );

    const sorted_cards = get_sorted_deck_witness(cards);

    // Verify Order
    // We check that each weight is >= the previous weight
    // We can use fold to check this, accumulating a boolean "isValid"
    // Range 0..51 to check i vs i+1
    const INDICES_51: Vector<51, Uint<64>> = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50];
    
    const is_sorted = fold(
        (ok, i) => {
            const w1 = sorted_cards[i].weight;
            const w2 = sorted_cards[i + 1].weight;
            return ok && (w1 <= w2); // Ensure ascending order
        },
        true,
        INDICES_51
    );
    assert(is_sorted, "Witness failed: Deck is not sorted");
    
    // Compress cards to Field elements
    const original_hashes = map((c) => hash_card_to_field(c), cards);
    const sorted_hashes = map((c) => hash_card_to_field(c), sorted_cards);

    // Generate random challenge 'gamma' (Fiat-Shamir)
    // We verify against a random value derived from the input data itself.
    const gamma = std_transientHash<Vector<52, Field>>(original_hashes);

    // Compute Grand Products
    const prod_original = fold((acc, h) => acc * (h + gamma), 1 as Field, original_hashes);
    const prod_sorted   = fold((acc, h) => acc * (h + gamma), 1 as Field, sorted_hashes);

    // If the multisets are equal, the polynomials P(gamma) and Q(gamma) will match
    assert(prod_original == prod_sorted, "Witness failed: Cheating detected (cards modified)");

    // Write back
    for (const i of 0..52) {
        deck.insert(disclose(i as Field), disclose(sorted_cards[i].point));
    }
}

// Helper to compress a card struct into a single Field for the permutation check
circuit hash_card_to_field(card: WeightedCard): Field {
    return std_transientHash<WeightedCard>(card);
}

circuit make_weighted_masked_card(index: Uint<248>, seed: Bytes<32>, playerIndex: Uint<64>): WeightedCard {
    const original_point = deck.lookup(index as Field);
    const masked_point = applyMaskToPoint(original_point, playerIndex);
    
    const seed_field = std_degradeToTransient(seed);
    const weight = std_transientHash<Vector<2, Field>>([seed_field, index as Field]);
    const weight_uint = field_to_uint64_safe(weight);

    return WeightedCard {
        point: masked_point,
        weight: weight_uint
    };
}

circuit field_to_uint64_safe(val: Field): Uint<64> {
    const parts = split_field_bits(val);
    const high_part = parts[0];
    const low_part = parts[1];
    const SHIFT: Field = 18446744073709551616 as Field;
    // Verify: val == high * 2^64 + low
    // We cast low_part to Field to perform the check
    assert(val == high_part * SHIFT + (low_part as Field), "Safe truncation failed");
    return low_part;
}
